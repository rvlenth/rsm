[{"path":"https://github.com/rvlenth/rsm/articles/article-JSS.html","id":"abstract","dir":"Articles","previous_headings":"","what":"Abstract","title":"Response-Surface Methods in R, Using rsm","text":"introduction R package rsm modified version Lenth (2009), published Journal Statistical Software. package rsm designed provide R support standard response-surface methods. Functions provided generate central-composite Box-Behnken designs. analysis resulting data, package provides estimating response surface, testing lack fit, displaying ensemble contour plots fitted surface, follow-analyses steepest ascent, canonical analysis, ridge analysis. also implements coded-data structure aid essential aspect methodology. functions designed hopes providing intuitive effective user interface. Potential exists expanding package variety ways.","code":""},{"path":"https://github.com/rvlenth/rsm/articles/article-JSS.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Response-Surface Methods in R, Using rsm","text":"Response-surface methodology comprises body methods exploring optimum operating conditions experimental methods. Typically, involves several experiments, using results one experiment provide direction next. next action focus experiment around different set conditions, collect data current experimental region order fit higher-order model confirm seem found. Different levels values operating conditions comprise factors experiment. may categorical (e.g., supplier raw material) others may quantitative (feed rates, temperatures, ). practice, categorical variables must handled separately comparing best operating conditions respect quantitative variables across different combinations categorical ones. fundamental methods quantitative variables involve fitting first-order (linear) second-order (quadratic) functions predictors one response variables, examining characteristics fitted surface decide action appropriate. Given , may seem like response-surface analysis simply regression problem. However, several intricacies analysis commonly used enough different routine regression problems special help warranted. intricacies include common use (importance) coded predictor variables; assessment fit; different follow-analyses used depending type model fitted, well outcome analysis; importance visualizing response surface. Response-surface methods also involve unique experimental-design issues, due emphasis iterative experimentation need relatively sparse designs can built-piece--piece according evolving needs experimenter. rsm package R (R Development Core Team 2009) provides several functions facilitate classical response-surface methods, described texts Box Draper (1987), Khuri Cornell (1996, Chapters 1U5), Wu Hamada (2000, Chapter 9), Myers, Montgomery, Anderson-Cook (2009), Box, Hunter, Hunter (2005, Chapters 11U12), Ryan (2007, Chapter 10). current form, rsm covers standard first-second order designs methods one response variable; covers reasonably well, expanded future. Multiple-response optimization covered package, desirability package (Kuhn 2009) may used conjunction predictions obtained using rsm package. rsm package available Comprehensive R Archive Network https://CRAN.R-project.org/package=rsm. general overview rsm. First, provides functions data types provide coding decoding factor levels, since appropriate coding important element response-surface analysis. discussed [coding section]{#coding). Second, provides functions generating standard designs (currently, central-composite Box-Behnken), building blocks thereof, examining variance function; see designs section. Third fitting section extends R’s lm function simplify specification standard response-surface models, provide appropriate summaries. Fourth, contour section provides means visualizing fitted response surface (fact lm object). Finally steepest ascent section provides guidance experimentation, e.g., along path steepest ascent. rsm functions take advantage R’s formula capabilities provide intuitive transparent ways obtaining needed results. provide context, good commercial software available help designing analyzing response-surface experiments. popular include Design-Expert (StatEase, Inc. 2009), JMP (SAS Institute, Inc. 2009), Statgraphics (StatPoint Technologies, Inc. 2009). provide generating Box-Behnken central-composite designs, fitting first- second-order response surfaces, visualizing . programs generally exceed rsm’s capabilities (example, types designs, provisions mixture experiments, etc.); rsm makes important methods available R. knowledge, functionality rsm’s ccd.pick function provided software, rsm may exceed capabilities programs generality central-composite designs can create. goal vignette present overview rsm functions may used design analyze response-surface experiments. important functions package illustrated, provide comprehensive documentation ; instead, reader referred manual online documentation provided package. “Response-Surface Illustration” vignette details building-blockock approach generating designs newer features rsm.","code":""},{"path":"https://github.com/rvlenth/rsm/articles/article-JSS.html","id":"coding","dir":"Articles","previous_headings":"","what":"Coding of data","title":"Response-Surface Methods in R, Using rsm","text":"important aspect response-surface analysis using appropriate coding transformation data. way data coded affects results canonical analysis (see sections fitting steepest-ascent analysis); example, unless scaling factors equal, path steepest ascent obtained fitting model raw predictor values differ path obtained coded units, decoded original scale. Using coding method makes coded variables experiment vary range way giving predictor equal share potentially determining steepest-ascent path. Thus, coding important step response-surface analysis. Accordingly, rsm package provides coded.data class objects, extension data.frame. functions coded.data, .coded.data, decode.data, recode.data, code2val, val2code create decode objects. coded.data object used place ordinary data.frame call rsm functions rsm steepest, appropriate additional output provided translates results original units. print method coded.data object displays coding formulas data either coded decoded form. example, consider provided dataset ChemReact, comes Table 7.6 Myers et al. (2009). experiment, data block B1 collected first analyzed, block B2 added new analysis done. provided datasets ChemReact1 ChemReact2 provide separate blocks. first block, ChemReact1, uses factor settings \\(\\text{Time}=85\\pm5\\) \\(\\text{Temp}=175\\pm5\\), three center points. Thus, coded variables \\(x_1 = (\\text{Time}-85)/5\\) \\(x_1 = (\\text{Temp}-175)/5\\). create coded dataset appropriate codings, provide information via formulas: listing looks much like original data, internally, data saved coded form, can seen coercing data.frame: way writing linear transformation acceptable; example, written x1 ~ 0.2 * Time - 17. Observe coded.data actually transforms predictor values replaces variables coded versions. create coded.data object data already coded, use .coded.data. function decode.data decodes coded.data object. may also easily encode decode matrices data frames arbitrary values; example,","code":"library(`rsm`) ChemReact ##     Time   Temp Block Yield ## 1  80.00 170.00    B1  80.5 ## 2  80.00 180.00    B1  81.5 ## 3  90.00 170.00    B1  82.0 ## 4  90.00 180.00    B1  83.5 ## 5  85.00 175.00    B1  83.9 ## 6  85.00 175.00    B1  84.3 ## 7  85.00 175.00    B1  84.0 ## 8  85.00 175.00    B2  79.7 ## 9  85.00 175.00    B2  79.8 ## 10 85.00 175.00    B2  79.5 ## 11 92.07 175.00    B2  78.4 ## 12 77.93 175.00    B2  75.6 ## 13 85.00 182.07    B2  78.5 ## 14 85.00 167.93    B2  77.0 CR1 <- coded.data(ChemReact1, x1 ~ (Time - 85)/5, x2 ~ (Temp - 175)/5) CR1 ##   Time Temp Yield ## 1   80  170  80.5 ## 2   80  180  81.5 ## 3   90  170  82.0 ## 4   90  180  83.5 ## 5   85  175  83.9 ## 6   85  175  84.3 ## 7   85  175  84.0 ##  ## Data are stored in coded form using these coding formulas ... ## x1 ~ (Time - 85)/5 ## x2 ~ (Temp - 175)/5 as.data.frame(CR1) ##   x1 x2 Yield ## 1 -1 -1  80.5 ## 2 -1  1  81.5 ## 3  1 -1  82.0 ## 4  1  1  83.5 ## 5  0  0  83.9 ## 6  0  0  84.3 ## 7  0  0  84.0 code2val(data.frame(x1 = c(0.25, 0.5), x2 = c(-1.5, -0.5)), codings(CR1)) ##    Time  Temp ## 1 86.25 167.5 ## 2 87.50 172.5"},{"path":"https://github.com/rvlenth/rsm/articles/article-JSS.html","id":"designs","dir":"Articles","previous_headings":"","what":"Generating a design","title":"Response-Surface Methods in R, Using rsm","text":"functions ccd bbd available generate standard response-surface designs. example, generate 3-factor Box-Behnken design (Box Behnken, 1960) two center points: default, variable names x1, x2, … experiment randomized. \\(4\\) \\(5\\) factors, design blocked default (possible numbers factors), blocks randomized separately. One popular response-surface designs central-composite design (CCD), due Box Wilson (1951). simple example chemical-reaction experiment presented preceding section. designs allow sequential augmentation, may first experiment just one block suitable fitting first-order model, add block(s) second-order fit needed. blocks CCD two types—one type, called “cube” block, contains design points two-level factorial fractional factorial design, plus center points; type, called “star” block, contains axis points plus center points. following discussion, term “design points” refers non-center points block. levels factors coded, cube blocks contain design points coordinate values equal \\(\\pm1\\), center points \\((0,0,\\ldots,0)\\). design points star blocks positions \\(\\pm\\alpha\\) along coordinate axis. value \\(\\alpha\\), choices replications design points center points, often selected based considerations rotatability (.e., variance prediction depends distance center) orthogonality blocks (coefficients fitted response-surface equation correlated block effects). table displays parameters CCD, along names used function ccd.pick described shortly. Suppose \\(k\\) variables varied. cube blocks, start given \\(2^{k-p}\\) fractional factorial design (full factorial, \\(p=0\\)). may either use design -define design points cube block(s). Alternatively, may confound one effects blocks split design blks.c smaller cube blocks, case cube block contains \\(2^{k-p}/\\mathtt{blks.c}\\) distinct design points. star blocks always contain \\(2k\\) distinct design points—two axis. designs decided, may, like, replicate within blocks. may also replicate center points. names wbr.c wbr.s (“within-block reps”) refer number replicates design point within cube block star block, respectively. Thus, cube block total \\(\\mathtt{n.c} = \\mathtt{wbr.c}\\cdot2^{k-p}/\\mathtt{blks.c}\\) design points, star block contains \\(\\mathtt{wbr.s}\\cdot2k\\) design points. may also replicate center points—n0.c times cube block, n0.s times within star block. Finally, may replicate blocks ; numbers -block replications denoted bbr.c bbr.s cube blocks star blocks, respectively. important understand block separately randomized, effect mini-experiment within larger experiment. -block replications means repeating mini-experiments. run entire block running another block. function ccd.pick designed help identify good CCDs. simply creates grid combinations design choices, computes \\(\\alpha\\) values required orthogonality rotatability, sorts specified criterion (default, measure discrepancy two \\(\\alpha\\)s), presents best . example, suppose want experiment \\(k=5\\) factors, willing consider CCDs \\(\\mathtt{blks.c}=1\\), \\(2\\), \\(4\\) cube blocks sizes \\(\\mathtt{n.c}=8\\) \\(16\\) . many factors, number different star points (\\(2k=10\\)) relatively small compared size cube blocks (\\(16\\)), seems reasonable consider either one two replications (\\(\\mathtt{wbr.s}\\\\{1,2\\}\\)) point within star block. Finally, suppose want total size experiment \\(N=65\\) runs (see restrict call ). ten best choices based criteria: first design listed also smallest; consists one cube block \\(16\\) runs, plus \\(6\\) center points; one star block points replicated one center point; thus, total number runs \\(N=(16+6)+(10+1) = 33\\). choose \\(\\alpha=2\\), design orthogonal rotatable seen noting alpha.rot alpha.orth equal \\(2\\). \\(16\\) design points cube block may generated \\(2^{5-1}\\) fractional factorial design. small design, one center point star block, providing way test lack fit star portion. second third designs remedy slightly, designs fairly lopsided cube block much larger star block. next designs require considerably runs. Design number 4 nicely balanced consists three blocks \\(21\\) runs , rotatable orthogonal. However, still lack--fit test star blocks. Designs 5 6 differ whether use two \\(2^{5-1}\\) cubes four \\(2^{5-2}\\) cubes, provide several center points lack--fit test. position axis points \\(\\alpha=2.38\\), design almost orthogonal almost rotatable. remaining designs also come close meeting criteria, also somewhat smaller, Designs 9 10 essentially -sized versions Designs 5 6. choice design best depends tradeoff economy ability assess fitted surface. Design 1 one included Table 7.6 Myers et al. (2009). good able look broader range choices. decide design, ccd function used generate . (Alternatively, starting rsm version 2.0, cube, star, foldover, dupe functions available generating randomizing CCD separate blocks, may combined using djoin.) first illustrate generation Design 1 . design requires \\(2^{5-1}\\) fraction cube block. Typically, done confounding five-way interaction mean; equivalently, create four-factor design, generate levels fifth four-way interaction others. approach implemented ccd. Suppose denote design factors \\(,B,C,D,E\\); let’s opt use \\(E=-ABCD\\) generator. following call generates design (results shown): value \\(\\alpha\\) specified, default uses \\(\\alpha\\) orthogonality. first argument just 4, generator given terms default variable names x1, x2, …. optional left-hand side formula creates place-holders response variable(s), filled-data later. bbd, added coding formulas create coded.data object. Next, illustrate generation Design 10. design four \\(2^{5-2}\\) cube blocks \\(2\\) center points , one unreplicated star block \\(4\\) center points. non-center points cube blocks comprise \\(4\\times8=32\\) runs, likely want create dividing full \\(2^5\\) factorial four fractional blocks. can example opt generate blocks via factors \\(b_1=ABC\\) \\(b_2=CDE\\), blocks determined four combinations \\(b_1\\) \\(b_2\\). block effects confounded effects \\(ABC\\), \\(CDE\\), also \\(b_1b_2\\) interaction \\(ABC^2DE=ABDE\\). important response-surface work avoid confounding second-order interactions, scheme thus acceptable. Unlike Design 1, design includes \\(2^5\\) factor combinations, use generators argument; instead, use blocks fractionation: block randomized separately, order blocks randomized. practice, may opt run blocks different sequence. design, just one cube blocks sufficient estimate first-order response surface. also important examine design’s capabilities. First , adequate fit needed first- second-order model, effective predicting response surface? varfcn function (new addition starting rsm version 2.0) helpful regard. calculates scaled version varaince fitted values specified set design points. default, computes along paths \\((1,0,\\ldots,0),(1,1,\\ldots,0),\\ldots,(1,1,\\ldots,1)\\), grid first two variables. right-hand side intended model must provided. illustrate Design 10:   shows design nearly rotatable (exactly chosen alpha = \"rotatable\" call ccd). can also verified two cube blocks plus axis block sufficient estimate second-order response surface. Just one cube block plus axis points, however, sufficient. possible imagine CCD consists fractional factorial divided blocks. design, generators blocks needed. smaller numbers factors, CCDs require fractionation either type, obviously simple generate. Starting version 1.40 rsm, inscribed argument available ccd. scales entire design fits within unit cube—useful situations constraints region operability. Note example now axis points \\(\\pm1\\), cube points \\(\\pm\\sqrt{1/2}\\). (Incidentally, example also illustrates default codings used coding formulas specified.) several types designs useful response surfaces, mentioned several books referenced article. Provisions generating designs area future development rsm package.","code":"bbd(3, n0 = 2, coding =   list(x1 ~ (Force - 20)/3, x2 ~ (Rate - 50)/10, x3 ~ Polish - 4)) ##    run.order std.order Force Rate Polish ## 1          1         8    23   50      5 ## 2          2        14    20   50      4 ## 3          3        11    20   40      5 ## 4          4         6    23   50      3 ## 5          5         4    23   60      4 ## 6          6         5    17   50      3 ## 7          7         2    23   40      4 ## 8          8        10    20   60      3 ## 9          9        12    20   60      5 ## 10        10         7    17   50      5 ## 11        11         9    20   40      3 ## 12        12         3    17   60      4 ## 13        13         1    17   40      4 ## 14        14        13    20   50      4 ##  ## Data are stored in coded form using these coding formulas ... ## x1 ~ (Force - 20)/3 ## x2 ~ (Rate - 50)/10 ## x3 ~ Polish - 4 ccd.pick(5, n.c = c(8, 16), blks.c = c(1, 2, 4),   wbr.s = 1:2, restrict = \"N<=65\") ##    n.c n0.c blks.c n.s n0.s bbr.c wbr.s bbr.s  N alpha.rot alpha.orth ## 1   16    6      1  10    1     1     1     1 33  2.000000   2.000000 ## 2   16    8      1  10    2     1     1     1 36  2.000000   2.000000 ## 3   16   10      1  10    3     1     1     1 39  2.000000   2.000000 ## 4   16    5      2  20    1     1     2     1 63  2.000000   2.000000 ## 5   16    8      2  10    7     1     1     1 65  2.378414   2.380476 ## 6    8    4      4  10    7     1     1     1 65  2.378414   2.380476 ## 7   16    1      2  10    2     1     1     1 46  2.378414   2.376354 ## 8   16    5      2  10    5     1     1     1 57  2.378414   2.390457 ## 9   16    4      2  10    4     1     1     1 54  2.378414   2.366432 ## 10   8    2      4  10    4     1     1     1 54  2.378414   2.366432 des1 <- ccd (y1 + y2 ~ A + B + C + D,   generators = E ~ - A * B * C * D, n0 = c(6, 1)) des10 <- ccd( ~ A + B + C + D + E,   blocks = Blk ~ c(A * B * C, C * D * E), n0 = c(2, 4)) varfcn(des10, ~ Blk + SO(A,B,C,D,E), dist = seq(0, 3, by = .1)) varfcn(des10, ~ Blk + SO(A,B,C,D,E), dist = seq(0, 3, by = .1), contour = TRUE) ccd(2, n0 = c(1, 1), inscribed = TRUE, randomize = FALSE) ##    run.order std.order   x1.as.is   x2.as.is Block ## 1          1         1 -0.7071068 -0.7071068     1 ## 2          2         2  0.7071068 -0.7071068     1 ## 3          3         3 -0.7071068  0.7071068     1 ## 4          4         4  0.7071068  0.7071068     1 ## 5          5         5  0.0000000  0.0000000     1 ## 6          1         1 -1.0000000  0.0000000     2 ## 7          2         2  1.0000000  0.0000000     2 ## 8          3         3  0.0000000 -1.0000000     2 ## 9          4         4  0.0000000  1.0000000     2 ## 10         5         5  0.0000000  0.0000000     2 ##  ## Data are stored in coded form using these coding formulas ... ## x1 ~ x1.as.is ## x2 ~ x2.as.is"},{"path":"https://github.com/rvlenth/rsm/articles/article-JSS.html","id":"fitting","dir":"Articles","previous_headings":"","what":"Fitting a response-surface model","title":"Response-Surface Methods in R, Using rsm","text":"response surface fitted using rsm function. extension lm, works almost exactly like ; however, model formula rsm must make use special functions FO, TWI, PQ, (“first-order,”, “two-way interaction,” “pure quadratic,” “second-order,” respectively), presence specifies response-surface portion model. terms don’t involve functions may included model; often, terms include blocking factors categorical predictors. illustrate , let us revisit ChemReact data introduced coding section. one response variable, Yield, two coded predictors x1 x2 well blocking factor Block. Supposing experiment done two stages, first act though data second block yet collected; fit first-order response-surface model data first block: see summary usual summary lm object (subtle difference), followed additional information particular response surfaces. subtle difference labeling regression coefficients simplified (don’t see “FO” ). analysis--variance table shown includes breakdown lack fit pure error, also given information direction steepest ascent. Since dataset coded.data object, steepest-ascent information also presented original units. (rsm require coded.data dataset, use one highly recommended.) particular example, steepest-ascent information little use, significant lack fit model (\\(p \\approx 0.01\\)). suggests try higher-order model. example, add two-way interactions: results shown, one finds still small \\(p\\) value lack--fit. go , need data. Thus, let us pretend now collect data second block. data combined blocks: Notice djoin figures fact ChemReact2 coded appropriate uncoded variables Time Temp; codes variables appropriately. Also, Block factor added automatically. now position fitting full second-order model combined data. can done adding PQ(x1, x2) model interaction, easier way use , shorthand model FO, TWI, PQ terms. Also, now need account block effect since data collected separate experiments: lack fit now non-significant (\\(p \\approx 0.69\\)). summary second-order model provides results canonical analysis surface rather steepest ascent. analysis indicates stationary point fitted surface \\((0.37, 0.33)\\) coded units—well within experimental region; eigenvalues negative, indicating stationary point maximum. kind situation dream response-surface experimentation—clear evidence nearby set optimal conditions. probably collect confirmatory data near estimated optimum \\(\\text{Time}\\approx87\\), \\(\\text{Temp}\\approx 177\\), make sure. Another example comes different way paper-helicopter experiment (Box et al. 2005, Table 12.5). another central-composite experiment, four variables two blocks. data provided rsm dataset heli; data already coded. original variables wing area , wing shape R, body width W, body length L. goal make paper helicopter flies long possible. observation dataset represents results ten replicated flights experimental condition. study average flight time, variable name ave, using second-order surface. analysis variance, clear second-order (TWI PQ) terms contribute significantly model, canonical analysis relevant. , stationary point fairly near experimental region, eigenvalues mixed sign, indicating saddle point (neither maximum minimum). analysis results subsequent sections.","code":"CR1.rsm <- rsm(Yield ~ FO(x1, x2), data = CR1) summary(CR1.rsm) ##  ## Call: ## rsm(formula = Yield ~ FO(x1, x2), data = CR1) ##  ##             Estimate Std. Error  t value  Pr(>|t|)     ## (Intercept) 82.81429    0.54719 151.3456 1.143e-08 *** ## x1           0.87500    0.72386   1.2088    0.2933     ## x2           0.62500    0.72386   0.8634    0.4366     ## --- ## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 ##  ## Multiple R-squared:  0.3555, Adjusted R-squared:  0.0333  ## F-statistic: 1.103 on 2 and 4 DF,  p-value: 0.4153 ##  ## Analysis of Variance Table ##  ## Response: Yield ##             Df Sum Sq Mean Sq F value  Pr(>F) ## FO(x1, x2)   2 4.6250  2.3125  1.1033 0.41534 ## Residuals    4 8.3836  2.0959                 ## Lack of fit  2 8.2969  4.1485 95.7335 0.01034 ## Pure error   2 0.0867  0.0433                 ##  ## Direction of steepest ascent (at radius 1): ##        x1        x2  ## 0.8137335 0.5812382  ##  ## Corresponding increment in original units: ##     Time     Temp  ## 4.068667 2.906191 CR1.rsmi <- update(CR1.rsm, . ~ . + TWI(x1, x2)) summary(CR1.rsmi) ( CR2 <- djoin(CR1, ChemReact2) ) ##     Time   Temp Yield Block ## 1  80.00 170.00  80.5     1 ## 2  80.00 180.00  81.5     1 ## 3  90.00 170.00  82.0     1 ## 4  90.00 180.00  83.5     1 ## 5  85.00 175.00  83.9     1 ## 6  85.00 175.00  84.3     1 ## 7  85.00 175.00  84.0     1 ## 8  85.00 175.00  79.7     2 ## 9  85.00 175.00  79.8     2 ## 10 85.00 175.00  79.5     2 ## 11 92.07 175.00  78.4     2 ## 12 77.93 175.00  75.6     2 ## 13 85.00 182.07  78.5     2 ## 14 85.00 167.93  77.0     2 ##  ## Data are stored in coded form using these coding formulas ... ## x1 ~ (Time - 85)/5 ## x2 ~ (Temp - 175)/5 CR2.rsm <- rsm(Yield ~ Block + SO(x1, x2), data = CR2) summary(CR2.rsm) ##  ## Call: ## rsm(formula = Yield ~ Block + SO(x1, x2), data = CR2) ##  ##              Estimate Std. Error  t value  Pr(>|t|)     ## (Intercept) 84.095427   0.079631 1056.067 < 2.2e-16 *** ## Block2      -4.457530   0.087226  -51.103 2.877e-10 *** ## x1           0.932541   0.057699   16.162 8.444e-07 *** ## x2           0.577712   0.057699   10.012 2.122e-05 *** ## x1:x2        0.125000   0.081592    1.532    0.1694     ## x1^2        -1.308555   0.060064  -21.786 1.083e-07 *** ## x2^2        -0.933442   0.060064  -15.541 1.104e-06 *** ## --- ## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 ##  ## Multiple R-squared:  0.9981, Adjusted R-squared:  0.9964  ## F-statistic: 607.2 on 6 and 7 DF,  p-value: 3.811e-09 ##  ## Analysis of Variance Table ##  ## Response: Yield ##             Df Sum Sq Mean Sq   F value    Pr(>F) ## Block        1 69.531  69.531 2611.0950 2.879e-10 ## FO(x1, x2)   2  9.626   4.813  180.7341 9.450e-07 ## TWI(x1, x2)  1  0.063   0.063    2.3470    0.1694 ## PQ(x1, x2)   2 17.791   8.896  334.0539 1.135e-07 ## Residuals    7  0.186   0.027                     ## Lack of fit  3  0.053   0.018    0.5307    0.6851 ## Pure error   4  0.133   0.033                     ##  ## Stationary point of response surface: ##        x1        x2  ## 0.3722954 0.3343802  ##  ## Stationary point in original units: ##      Time      Temp  ##  86.86148 176.67190  ##  ## Eigenanalysis: ## eigen() decomposition ## $values ## [1] -0.9233027 -1.3186949 ##  ## $vectors ##          [,1]       [,2] ## x1 -0.1601375 -0.9870947 ## x2 -0.9870947  0.1601375 heli.rsm <- rsm(ave ~ block + SO(x1, x2, x3, x4), data = heli) summary(heli.rsm) ##  ## Call: ## rsm(formula = ave ~ block + SO(x1, x2, x3, x4), data = heli) ##  ##               Estimate Std. Error  t value  Pr(>|t|)     ## (Intercept) 372.800000   1.506375 247.4815 < 2.2e-16 *** ## block2       -2.950000   1.207787  -2.4425 0.0284522 *   ## x1           -0.083333   0.636560  -0.1309 0.8977075     ## x2            5.083333   0.636560   7.9856 1.398e-06 *** ## x3            0.250000   0.636560   0.3927 0.7004292     ## x4           -6.083333   0.636560  -9.5566 1.633e-07 *** ## x1:x2        -2.875000   0.779623  -3.6877 0.0024360 **  ## x1:x3        -3.750000   0.779623  -4.8100 0.0002773 *** ## x1:x4         4.375000   0.779623   5.6117 6.412e-05 *** ## x2:x3         4.625000   0.779623   5.9324 3.657e-05 *** ## x2:x4        -1.500000   0.779623  -1.9240 0.0749257 .   ## x3:x4        -2.125000   0.779623  -2.7257 0.0164099 *   ## x1^2         -2.037500   0.603894  -3.3739 0.0045424 **  ## x2^2         -1.662500   0.603894  -2.7530 0.0155541 *   ## x3^2         -2.537500   0.603894  -4.2019 0.0008873 *** ## x4^2         -0.162500   0.603894  -0.2691 0.7917877     ## --- ## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 ##  ## Multiple R-squared:  0.9555, Adjusted R-squared:  0.9078  ## F-statistic: 20.04 on 15 and 14 DF,  p-value: 6.54e-07 ##  ## Analysis of Variance Table ##  ## Response: ave ##                     Df  Sum Sq Mean Sq F value    Pr(>F) ## block                1   16.81   16.81  1.7281  0.209786 ## FO(x1, x2, x3, x4)   4 1510.00  377.50 38.8175 1.965e-07 ## TWI(x1, x2, x3, x4)  6 1114.00  185.67 19.0917 5.355e-06 ## PQ(x1, x2, x3, x4)   4  282.54   70.64  7.2634  0.002201 ## Residuals           14  136.15    9.72                   ## Lack of fit         10  125.40   12.54  4.6660  0.075500 ## Pure error           4   10.75    2.69                   ##  ## Stationary point of response surface: ##         x1         x2         x3         x4  ##  0.8607107 -0.3307115 -0.8394866 -0.1161465  ##  ## Stationary point in original units: ##         A         R         W         L  ## 12.916426  2.434015  1.040128  1.941927  ##  ## Eigenanalysis: ## eigen() decomposition ## $values ## [1]  3.258222 -1.198324 -3.807935 -4.651963 ##  ## $vectors ##          [,1]       [,2]       [,3]        [,4] ## x1  0.5177048 0.04099358  0.7608371 -0.38913772 ## x2 -0.4504231 0.58176202  0.5056034  0.45059647 ## x3 -0.4517232 0.37582195 -0.1219894 -0.79988915 ## x4  0.5701289 0.72015994 -0.3880860  0.07557783"},{"path":"https://github.com/rvlenth/rsm/articles/article-JSS.html","id":"contour","dir":"Articles","previous_headings":"","what":"Displaying a response surface","title":"Response-Surface Methods in R, Using rsm","text":"canonical analysis gives us handle behavior second-order response surface, effective graph lot easier present explain. end, rsm includes function making contour plots fitted response surface. function restricted rsm results, however; can used plotting regression surface produced lm. detailed information, see associated vignette provide lm rsm object, formula predictors use, various optional parameters. Consider paper-helicopter example preceding section; four response-surface predictors, making six pairs predictors. want visualize behavior fitted surface around stationary point, can provide location argument:  image argument causes plot display color image overlaid contour lines. multiple plots like produced, color levels held consistent across plots. Note condition set center coordinate systems (default variable ranges derived data); sets values hold variables one coordinate axes, shown subtitles.","code":"par(mfrow = c(2, 3)) contour(heli.rsm, ~ x1 + x2 + x3 + x4, image = TRUE,   at = summary(heli.rsm)$canonical$xs)"},{"path":"https://github.com/rvlenth/rsm/articles/article-JSS.html","id":"steepest","dir":"Articles","previous_headings":"","what":"Direction for further experimentation","title":"Response-Surface Methods in R, Using rsm","text":"many first-order cases, well second-order cases find saddle point stationary point distant, useful action decide direction explore . case first-order models, one can follow direction steepest ascent. already seen , summary method rsm objects provides information path. detailed information available via steepest function; example, general, can specify set distances along path. decoded coordinate values displayed model fitted coded.data dataset. point worth emphasizing , although fitted values also displayed, one must careful understand predictions , distance increases, poor predictions taken grain salt. one conduct actual experimental runs points along path, use observed response values, predictions, guidance locate next factorial experiment. second-order case, steepest function still works, uses ridge analysis method (Hoerl 1959; Draper 1963), analog steepest ascent sense specified distance \\(d\\), finds point predicted response maximum among predictor combinations radius \\(d\\). method makes sense stationary point distance away; point nearby, makes sense start saddle point (rather origin) follow steeply rising ridge directions. path obtained using canonical.path function. function, distance signed quantity, according direction along ridge. heli example, nearby stationary point. points within radius \\(5\\) along canonical path: Box et al. (2005, Table12.7 Figure12.6) reports results experimentation along path. found promising location next experiment distance \\(3.5\\) (\\(-3.5\\) scale signs reversed ).","code":"steepest(CR1.rsm, dist = c(0, 0.5, 1)) ## Path of steepest ascent from ridge analysis: ##   dist    x1    x2 |   Time    Temp |   yhat ## 1  0.0 0.000 0.000 | 85.000 175.000 | 82.814 ## 2  0.5 0.407 0.291 | 87.035 176.455 | 83.352 ## 3  1.0 0.814 0.581 | 89.070 177.905 | 83.890 canonical.path(heli.rsm, dist = seq(-5, 5, by = 0.5)) ##    dist     x1     x2     x3     x4 |       A       R       W      L |    yhat ## 1  -5.0 -1.728  1.921  1.419 -2.967 | 11.3632 3.01946 1.60475 0.5165 | 453.627 ## 2  -4.5 -1.469  1.696  1.193 -2.682 | 11.5186 2.96096 1.54825 0.6590 | 438.150 ## 3  -4.0 -1.210  1.471  0.967 -2.397 | 11.6740 2.90246 1.49175 0.8015 | 424.302 ## 4  -3.5 -0.951  1.246  0.742 -2.112 | 11.8294 2.84396 1.43550 0.9440 | 412.094 ## 5  -3.0 -0.692  1.021  0.516 -1.827 | 11.9848 2.78546 1.37900 1.0865 | 401.504 ## 6  -2.5 -0.434  0.795  0.290 -1.541 | 12.1396 2.72670 1.32250 1.2295 | 392.534 ## 7  -2.0 -0.175  0.570  0.064 -1.256 | 12.2950 2.66820 1.26600 1.3720 | 385.203 ## 8  -1.5  0.084  0.345 -0.162 -0.971 | 12.4504 2.60970 1.20950 1.5145 | 379.502 ## 9  -1.0  0.343  0.120 -0.388 -0.686 | 12.6058 2.55120 1.15300 1.6570 | 375.429 ## 10 -0.5  0.602 -0.105 -0.614 -0.401 | 12.7612 2.49270 1.09650 1.7995 | 372.986 ## 11  0.0  0.861 -0.331 -0.839 -0.116 | 12.9166 2.43394 1.04025 1.9420 | 372.172 ## 12  0.5  1.120 -0.556 -1.065  0.169 | 13.0720 2.37544 0.98375 2.0845 | 372.987 ## 13  1.0  1.378 -0.781 -1.291  0.454 | 13.2268 2.31694 0.92725 2.2270 | 375.428 ## 14  1.5  1.637 -1.006 -1.517  0.739 | 13.3822 2.25844 0.87075 2.3695 | 379.499 ## 15  2.0  1.896 -1.232 -1.743  1.024 | 13.5376 2.19968 0.81425 2.5120 | 385.206 ## 16  2.5  2.155 -1.457 -1.969  1.309 | 13.6930 2.14118 0.75775 2.6545 | 392.538 ## 17  3.0  2.414 -1.682 -2.195  1.594 | 13.8484 2.08268 0.70125 2.7970 | 401.498 ## 18  3.5  2.673 -1.907 -2.421  1.879 | 14.0038 2.02418 0.64475 2.9395 | 412.088 ## 19  4.0  2.932 -2.132 -2.646  2.164 | 14.1592 1.96568 0.58850 3.0820 | 424.295 ## 20  4.5  3.190 -2.358 -2.872  2.449 | 14.3140 1.90692 0.53200 3.2245 | 438.140 ## 21  5.0  3.449 -2.583 -3.098  2.734 | 14.4694 1.84842 0.47550 3.3670 | 453.615"},{"path":"https://github.com/rvlenth/rsm/articles/article-JSS.html","id":"stationary-and-rising-ridge-situations","dir":"Articles","previous_headings":"","what":"Stationary and rising-ridge situations","title":"Response-Surface Methods in R, Using rsm","text":"Canonical analysis becomes unstable cases matrix \\(\\mathbf{B}\\) second-order coefficients singular nearly . example, consider dataset codata provided rsm used example Box et al. (2005). comes coded form, relate things actual variables, let’s add codings: \\(3^2\\) design one block. fit second-order model obtain canonical analysis: Note , due automatic thresholding provision, one eigenvalues set zero. causes stationary point estimated based surviving eigenvector, one assumed stationary ridge. ignore thresholding, set threshold zero: Now, stationary point \\((-15,15)\\) coded units—distant design center. following statements produce illustrative plot situation.  displays fitted response surface, well results canonical.path without threshold (blue red points, respectively). region design shown green box. stationary point (different symbol) seen saddle point near upper-left corner thresholded, near design center whern thresholded. Otherwise, canonical paths much different origins. form path along rising ridge occurs vicinity design. important note stationary point obtained default thresholding really stationary point, rather nearby point represents center important canonical directions. example, true stationary point distant, thresholded stationary point nearest place rising ridge emanates true stationary point. thresholded canonical.path results give us much usable set factor settings explore ones without threshold.","code":"CO = as.coded.data(codata,  x1 ~ (Ethanol - 0.2)/0.1,  x2 ~ A.F.ratio - 15) names(CO)[3] = \"CO.conc\" head(CO) ##   Ethanol A.F.ratio CO.conc ## 1     0.1        14    61.9 ## 2     0.1        14    65.6 ## 3     0.2        14    80.9 ## 4     0.2        14    78.0 ## 5     0.3        14    89.7 ## 6     0.3        14    93.8 ##  ## Data are stored in coded form using these coding formulas ... ## x1 ~ (Ethanol - 0.2)/0.1 ## x2 ~ A.F.ratio - 15 CO.rsm = rsm(CO.conc ~ SO(x1,x2), data = CO) canonical(CO.rsm) ## Near-stationary-ridge situation detected -- stationary point altered ##  Change 'threshold' if this is not what you intend ## $xs ##          x1          x2  ## -0.06302658 -0.05997463  ##  ## $eigen ## eigen() decomposition ## $values ## [1]  0.000000 -8.886833 ##  ## $vectors ##          [,1]       [,2] ## x1  0.6893497 -0.7244288 ## x2 -0.7244288 -0.6893497 canonical(CO.rsm, threshold = 0) ## $xs ##        x1        x2  ## -14.81387  15.44149  ##  ## $eigen ## eigen() decomposition ## $values ## [1]  0.1868328 -8.8868328 ##  ## $vectors ##          [,1]       [,2] ## x1  0.6893497 -0.7244288 ## x2 -0.7244288 -0.6893497 contour(CO.rsm, x2 ~ x1, bounds = list(x1 = c(-16, 2), x2 = c(-2, 16)),          zlim = c(-100, 100), col = \"gray\", decode = FALSE) lines(c(-1,1,1,-1,-1), c(-1,-1,1,1,-1), col = \"green\") # design region points(x2 ~ x1, data = canonical.path(CO.rsm),          col = \"blue\", pch = 1 + 6*(dist == 0)) points(x2 ~ x1, data = canonical.path(CO.rsm, threshold = 0),          col = \"red\", pch = 1 + 6*(dist == 0)) points(x2 ~ x1, data=steepest(CO.rsm),          col = \"magenta\", pch = 1 + 6*(dist == 0)) ## Path of steepest ascent from ridge analysis: ## Path of steepest ascent from ridge analysis:"},{"path":"https://github.com/rvlenth/rsm/articles/article-JSS.html","id":"technical-details","dir":"Articles","previous_headings":"Stationary and rising-ridge situations","what":"Technical details","title":"Response-Surface Methods in R, Using rsm","text":"subsection provides technical backing canonical analysis threshold active, case ’re interested. Let \\(\\mathbf{b}\\) \\(\\mathbf{B}\\) denote first second-order coefficients fitted second-order surface, fitted value coded point \\(\\mathbf{x}\\) \\(\\hat{y}(\\mathbf{x}) = b_0 + \\mathbf{b}'\\mathbf{x} + \\mathbf{x}'\\mathbf{B}\\mathbf{x}\\). stationary point \\(\\mathbf{x}_s\\) solves equation \\(2\\mathbf{B}\\mathbf{x}_s + \\mathbf{b} = \\mathbf{0}\\), .e., \\(\\mathbf{x}_s = -\\frac12\\mathbf{B}^{-1}\\mathbf{b}\\). canonical analysis yields decomposition \\[ \\mathbf{B} = \\mathbf{U}\\mathbf{\\Lambda}\\mathbf{U}' = \\lambda_1\\mathbf{u}_1\\mathbf{u}_1' + \\lambda_2\\mathbf{u}_2\\mathbf{u}_2' + \\cdots + \\lambda_k\\mathbf{u}_k\\mathbf{u}_k' \\] \\(k\\) predictors, \\(\\mathbf{u}_j\\) form orthonormal columns \\(\\mathbf{U}\\), \\(\\lambda_j\\) eigenvalues, \\(\\mathbf{\\Lambda} = \\mathrm{diag}(\\lambda_1,\\lambda_2,\\ldots,\\lambda_k)\\). also happens true \\[ \\mathbf{B}^{-1} = \\mathbf{U}\\mathbf{\\Lambda}^{-1}\\mathbf{U}' = \\textstyle\\frac1{\\lambda_1}\\mathbf{u}_1\\mathbf{u}_1' + \\frac1{\\lambda_2}\\mathbf{u}_2\\mathbf{u}_2' + \\cdots + \\frac1{\\lambda_k}\\mathbf{u}_k\\mathbf{u}_k'  \\] Thus, really small value \\(\\lambda_j\\) hardly affects \\(\\mathbf{B}\\), huge influence \\(\\mathbf{B}^{-1}\\). Now, \\(m<k\\), let \\(\\mathbf{\\Lambda}_*\\) \\(m\\times m\\) diagonal matrix subset \\(m\\) eigenvalues; let \\(\\mathbf{U}_*\\) \\(k \\times m\\) matrix corresponding \\(\\mathbf{u}_j\\). excluded smallest absolute eigenvalues, \\(\\mathbf{B}_* = \\mathbf{U}_*\\mathbf{\\Lambda}_*\\mathbf{U}'_* \\approx \\mathbf{B}\\). Moreover, orthogonality, \\(\\mathbf{U}'\\mathbf{B} = \\mathbf{\\Lambda}\\mathbf{U}'\\) \\(\\mathbf{U}_*'\\mathbf{B} = \\mathbf{\\Lambda}_*\\mathbf{U}_*'\\). stationary point satisfies \\(2\\mathbf{B}\\mathbf{x} + \\mathbf{b} = \\mathbf{0}\\) \\(2\\mathbf{U}_*'\\mathbf{B}\\mathbf{x} + \\mathbf{U}_*'\\mathbf{b} = \\mathbf{0}\\). Accordingly, propose define pseudo-stationary point \\(\\mathbf{x}_*\\) \\(2\\mathbf{U}_*'\\mathbf{B}\\mathbf{x}_* + \\mathbf{U}_*'\\mathbf{b} = \\mathbf{0}\\); .e., \\(2\\mathbf{\\Lambda}_*\\mathbf{U}_*'\\mathbf{x}_* + \\mathbf{U}_*'\\mathbf{b} = \\mathbf{0}\\). comprises \\(m\\) equations \\(k>m\\) unknowns. make unique, opt choose solution closest origin; , minimize \\(\\mathbf{x}'\\mathbf{x}\\) subject constraint \\(2\\mathbf{\\Lambda}_*\\mathbf{U}_*'\\mathbf{x} + \\mathbf{U}_*'\\mathbf{b} = \\mathbf{0}\\). Using variational methods (Lagrange multipliers), find resulting solution \\(\\mathbf{x}_*= -\\frac12\\mathbf{U}_*\\mathbf{\\Lambda}_*^{-1}\\mathbf{U}_*'\\mathbf{b}\\). words, simply exclude terms corresponding small \\(\\lambda_i\\) expression \\(\\mathbf{B}^{-1}\\). stationary point returned rsm’s canonical related functions threshold used exclude small eigenvalues.","code":""},{"path":"https://github.com/rvlenth/rsm/articles/article-JSS.html","id":"discussion","dir":"Articles","previous_headings":"","what":"Discussion","title":"Response-Surface Methods in R, Using rsm","text":"current version rsm provides standard tools first- second-order response-surface design analysis. package can quite useful standard situations, implements many analyses presented textbooks. However, clearly great deal work done response-surface methods represented . Even quick glance review article Myers, Montgomery, Vining, Borror, Kowalski (2004) – even older one Hill Hunter (1989) – reveals great deal added future editions rsm. many useful designs besides central composites Box-Behnken designs. can consider higher-order models use predictor transformations. Mixture designs yet provided . important relationships methods robust parameter design, computer experiments. list goes . However, now least good collection basic tools R platform, starting point.","code":""},{"path":"https://github.com/rvlenth/rsm/articles/article-JSS.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Response-Surface Methods in R, Using rsm","text":"Box GEP,Behnken DW(1960). “New Three Level Designs Study Quantitative Variables.” Technometrics, 2, 455–475. Box GEP, Draper NR (1987). Empirical Model-Building Response Surfaces. John Wiley & Sons, New York. Box GEP, Hunter WG, Hunter JS (2005). Statistics Experimenters: Introduction Design, Data Analysis, Model Building. 2nd edition. John Wiley & Sons, New York. Box GEP, Wilson KB (1951). “Experimental Attainment Optimum Conditions.” Journal Royal Statistical Society B, 13, 1–45. Draper NR (1963). “‘Ridge Analysis’ Response Surfaces.” Technometrics, 5, 469–479. Hill WJ, Hunter WG (1989). “Review Response Surface Methodology: Literature Review.” Technometrics, 8, 571–590. Hoerl AE (1959). “Optimum Solution Many Variables Equations.” Chemical Engineering Progress, 55, 67–78. Khuri AI, Cornell JA (1996). Responses Surfaces: Design Analyses. 2nd edition. Marcel Dekker, Monticello, NY. Kuhn M (2009). desirability: Desirability Function Optimization Ranking. R package version 1.02, URL https://CRAN.R-project.org/package=desirability Lenth RV (2009). “Response-Surface Methods R, Using rsm.” Journal Statistical Software, 32(7), 1–17. URL https://www.jstatsoft.org/v32/i07/. Myers RH, Montgomery DC, Anderson-Cook CM (2009). Response Surface Methodology: Product Process Optimization Using Designed Experiments. 3nd edition. John Wiley & Sons, New York. Myers RH, Montgomery DC, Vining GG, Borror CM, Kowalski SM (2004). “Response Surface Methodology: Retrospective Literature Survey.” Journal Quality Technology, 36, 53–78. R Development Core Team (2009). R: Language Environment Statistical Computing. R Foundation Statistical Computing, Vienna, Austria. ISBN 3-900051-07-0, URL http: //www.R-project.org/. Ryan TP (2007). Modern Experimental Design. John Wiley & Sons, New York. SAS Institute, Inc (2009). JMP 8: Statistical Discovery Software. Cary, NC. URL http: //www.jmp.com/. Stat-Ease, Inc (2009). Design-Expert 7 Windows: Software Design Experiments (DOE). Minneapolis, MN. URL https://www.statease.com/software/design-expert/. StatPoint Technologies, Inc (2009). Statgraphics Centurion: Data Analysis Statistical Software. Warrenton, VA. URL https://www.statgraphics.com/. Wu CFJ, Hamada M (2000). Experiments: Planning, Analysis, Parameter Design Optimization. John Wiley & Sons, New York.","code":""},{"path":"https://github.com/rvlenth/rsm/articles/illus.html","id":"abstract","dir":"Articles","previous_headings":"","what":"Abstract","title":"Response-surface illustration","text":"vignette, give illustration, using simulated data, sequential-experimentation process optimize response surface. hope helpful understanding use rsm package RSM methodology general.","code":""},{"path":"https://github.com/rvlenth/rsm/articles/illus.html","id":"the-scenario","dir":"Articles","previous_headings":"","what":"The scenario","title":"Response-surface illustration","text":"use simulated data hypothetical baking experiment. goal find optimal amounts flour, butter, sugar recipe. response variable rating texture flavor product. baking temperature, procedures, equipment, operating environment held constant.","code":""},{"path":"https://github.com/rvlenth/rsm/articles/illus.html","id":"initial-experiment","dir":"Articles","previous_headings":"","what":"Initial experiment","title":"Response-surface illustration","text":"current recipe calls 1 cup flour, 0.50 cups sugar, 0.25 cups butter. initial experiment center recipe, vary ingredient \\(\\pm0.1\\) cup. Let’s start minimal first-order experiment, half-fraction \\(2^3\\) design plus 4 center points. total 8 experimental runs, quite enough given labor involved. philosophy RSM minimal experiments can augmented later necessary detail needed. ’ll generate randomize experiment using cube, terms coded variables \\(x_1,x_2,x_3\\): protocol first design. ’s important understand cube returns coded dataset; facilitates response-surface methodology analyses best done coded scale. design actually stored coded form, can see looking ordinary data.frame:","code":"library(rsm) expt1 = cube(~ x1 + x2,  x3 ~ x1 * x2, n0 = 4,             coding = c(x1 ~ (flour - 1)/.1, x2 ~ (sugar - .5)/.1, x3 ~ (butter - .25)/.1)) expt1 ##   run.order std.order flour sugar butter ## 1         1         2   1.1   0.4   0.15 ## 2         2         7   1.0   0.5   0.25 ## 3         3         3   0.9   0.6   0.15 ## 4         4         4   1.1   0.6   0.35 ## 5         5         1   0.9   0.4   0.35 ## 6         6         6   1.0   0.5   0.25 ## 7         7         5   1.0   0.5   0.25 ## 8         8         8   1.0   0.5   0.25 ##  ## Data are stored in coded form using these coding formulas ... ## x1 ~ (flour - 1)/0.1 ## x2 ~ (sugar - 0.5)/0.1 ## x3 ~ (butter - 0.25)/0.1 as.data.frame(expt1) ##   run.order std.order x1 x2 x3 ## 1         1         2  1 -1 -1 ## 2         2         7  0  0  0 ## 3         3         3 -1  1 -1 ## 4         4         4  1  1  1 ## 5         5         1 -1 -1  1 ## 6         6         6  0  0  0 ## 7         7         5  0  0  0 ## 8         8         8  0  0  0"},{"path":"https://github.com/rvlenth/rsm/articles/illus.html","id":"but-hold-on-a-minute-first-assess-the-strategy","dir":"Articles","previous_headings":"","what":"But hold on a minute… First, assess the strategy","title":"Response-surface illustration","text":"wait! collecting data, really plan ahead make sure going work.","code":""},{"path":"https://github.com/rvlenth/rsm/articles/illus.html","id":"first-order-design-capability","dir":"Articles","previous_headings":"But hold on a minute… First, assess the strategy","what":"First-order design capability","title":"Response-surface illustration","text":"First , initial design trick? One helpful tool rsm varfcn function, allows us examine variance predictions obtain. don’t data yet, done terms scaled variance, defined \\(\\frac N{\\sigma^2}\\mathrm{Var}(\\hat{y}(\\mathbf{x}))\\), \\(N\\) number design points, \\(\\sigma^2\\) error variance \\(\\hat{y}(\\mathbf{x})\\) predicted value design point \\(\\mathbf{x}\\). turn, \\(\\hat{y}(\\mathbf{x})\\) depends model well experimental design. Usually, \\(\\mathrm{Var}(\\hat{y}(\\mathbf{x}))\\) depends strongly far \\(\\mathbf{x}\\) center design (\\(\\mathbf{0}\\) coded units). Accordingly, varfcn function requires us supply design model, different directions go origin along plot scaled variance (defaults supplied specified). can look either profile plot contour plot:  surprisingly, variance increases go farther —, estimation accurate center design periphery. particular design variance profile directions: called rotatable design. Another important outcome see: error messages. means can actually fit intended model. intend use design fit second-order model, ’s different story: point , varfcn useful way make sure can estimate model need fit, collecting data.","code":"par(mfrow=c(1,2)) varfcn(expt1, ~ FO(x1,x2,x3)) varfcn(expt1, ~ FO(x1,x2,x3), contour = TRUE) varfcn(expt1, ~ SO(x1,x2,x3)) ## Error in solve.default(t(mm) %*% mm): Lapack routine dgesv: system is exactly singular: U[5,5] = 0"},{"path":"https://github.com/rvlenth/rsm/articles/illus.html","id":"lookahead2","dir":"Articles","previous_headings":"But hold on a minute… First, assess the strategy","what":"Looking further ahead","title":"Response-surface illustration","text":"mentioned, response-surface experimentation uses building-block approach. want augment design can fit second-order surface. popular way followup experiment axis “star” points locations \\(\\pm\\alpha\\) two experiments combined may used fit second-order model. work? , variance function look like? Let’s find . turns rotatable design achievable adding star points: characteristics design \\(\\alpha = 1.5\\):  can tell can least augment design fit second-order model. model includes block effect account fact two separately randomized experiments combined.","code":"try(   djoin(expt1, star(n0 = 2, alpha = \"rotatable\")) ) ## Error in star(n0 = 2, alpha = \"rotatable\", basis = structure(list(run.order = 1:8,  :  ##   Rotatable design is not achievable: inconsistent design moments par(mfrow=c(1,2)) followup = djoin(expt1, star(n0 = 2, alpha = 1.5)) varfcn(followup, ~ Block + SO(x1,x2,x3), main = \"Followup\") varfcn(followup, ~ Block + SO(x1,x2,x3), contour = TRUE, main = \"Block + SO(x1,x2,x3)\")"},{"path":"https://github.com/rvlenth/rsm/articles/illus.html","id":"ok-now-we-can-collect-some-data","dir":"Articles","previous_headings":"","what":"OK, now we can collect some data","title":"Response-surface illustration","text":"Now, pretend now go baked cakes according recipes. Time passes… OK, baking , results , entered new ratings column expt1: can now analyze data using first-order model (implemented rsm FO function). model fitted terms coded variables. take-home message first-order model help explain variations response (significant \\(F\\) statistic model, well two three coefficients \\(x_j\\) fairly significant); also real evidence model fit (large P value lack fit). Finally, information direction steepest ascent, suggests improve ratings increasing flour decreasing sugar butter (smaller amounts terms coded units).","code":"expt1 ##   run.order std.order flour sugar butter rating ## 1         1         2   1.1   0.4   0.15   28.9 ## 2         2         7   1.0   0.5   0.25   25.5 ## 3         3         3   0.9   0.6   0.15   20.2 ## 4         4         4   1.1   0.6   0.35   27.1 ## 5         5         1   0.9   0.4   0.35   21.5 ## 6         6         6   1.0   0.5   0.25   24.7 ## 7         7         5   1.0   0.5   0.25   25.0 ## 8         8         8   1.0   0.5   0.25   24.7 ##  ## Data are stored in coded form using these coding formulas ... ## x1 ~ (flour - 1)/0.1 ## x2 ~ (sugar - 0.5)/0.1 ## x3 ~ (butter - 0.25)/0.1 anal1 = rsm(rating ~ FO(x1,x2,x3), data=expt1) summary(anal1) ##  ## Call: ## rsm(formula = rating ~ FO(x1, x2, x3), data = expt1) ##  ##             Estimate Std. Error  t value  Pr(>|t|)     ## (Intercept) 24.70000    0.17963 137.5077 1.678e-08 *** ## x1           3.57500    0.25403  14.0731 0.0001479 *** ## x2          -0.77500    0.25403  -3.0508 0.0379977 *   ## x3          -0.12500    0.25403  -0.4921 0.6484543     ## --- ## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 ##  ## Multiple R-squared:  0.9811, Adjusted R-squared:  0.9669  ## F-statistic:  69.2 on 3 and 4 DF,  p-value: 0.0006658 ##  ## Analysis of Variance Table ##  ## Response: rating ##                Df Sum Sq Mean Sq F value    Pr(>F) ## FO(x1, x2, x3)  3 53.587 17.8625 69.2010 0.0006658 ## Residuals       4  1.033  0.2581                   ## Lack of fit     1  0.605  0.6050  4.2456 0.1314343 ## Pure error      3  0.428  0.1425                   ##  ## Direction of steepest ascent (at radius 1): ##          x1          x2          x3  ##  0.97672947 -0.21173856 -0.03415138  ##  ## Corresponding increment in original units: ##        flour        sugar       butter  ##  0.097672947 -0.021173856 -0.003415138"},{"path":"https://github.com/rvlenth/rsm/articles/illus.html","id":"explore-the-path-of-steepest-ascent","dir":"Articles","previous_headings":"","what":"Explore the path of steepest-ascent","title":"Response-surface illustration","text":"direction steepest ascent best guess can improve recipe. steepest function provides easy way find steps right direction, distance 5 (coded units) default: yhat values show fitted model anticipates rating; move distances, serious extrapolations can’t trusted. need real data! let’s little experiment along path, using distances 0.5 4.0, total 8 runs. dupe function makes copy runs re-randomizes order. Now need baking based design. Time passes… data now collected; results: steepest-ascent path, idea find highest point along path, center next experiment . end, let’s look graphically:  fair amount variation , fitted quadratic curve provides useful guidance. suggests next experiment distance \\(2.5\\) coded units, .e., near point #6 steepest-ascent path, sa1. Let’s use somewhat rounder values: flour:\\(1.25\\)cups, sugar:\\(0.45\\)cups, butter:\\(0.25\\)cups (unchanged expt1).","code":"( sa1 = steepest(anal1) ) ## Path of steepest ascent from ridge analysis: ##    dist    x1     x2     x3 |  flour  sugar butter |   yhat ## 1   0.0 0.000  0.000  0.000 | 1.0000 0.5000 0.2500 | 24.700 ## 2   0.5 0.488 -0.106 -0.017 | 1.0488 0.4894 0.2483 | 26.529 ## 3   1.0 0.977 -0.212 -0.034 | 1.0977 0.4788 0.2466 | 28.361 ## 4   1.5 1.465 -0.318 -0.051 | 1.1465 0.4682 0.2449 | 30.190 ## 5   2.0 1.953 -0.423 -0.068 | 1.1953 0.4577 0.2432 | 32.018 ## 6   2.5 2.442 -0.529 -0.085 | 1.2442 0.4471 0.2415 | 33.851 ## 7   3.0 2.930 -0.635 -0.102 | 1.2930 0.4365 0.2398 | 35.680 ## 8   3.5 3.419 -0.741 -0.120 | 1.3419 0.4259 0.2380 | 37.512 ## 9   4.0 3.907 -0.847 -0.137 | 1.3907 0.4153 0.2363 | 39.341 ## 10  4.5 4.395 -0.953 -0.154 | 1.4395 0.4047 0.2346 | 41.170 ## 11  5.0 4.884 -1.059 -0.171 | 1.4884 0.3941 0.2329 | 43.002 expt2 = dupe(sa1[2:9, ]) expt2 ##   run.order std.order dist    x1     x2     x3 |  flour  sugar butter |.1   yhat rating ## 1         1         8  4.0 3.907 -0.847 -0.137 | 1.3907 0.4153 0.2363   | 39.341   24.3 ## 2         2         4  2.0 1.953 -0.423 -0.068 | 1.1953 0.4577 0.2432   | 32.018   26.6 ## 3         3         1  0.5 0.488 -0.106 -0.017 | 1.0488 0.4894 0.2483   | 26.529   24.8 ## 4         4         3  1.5 1.465 -0.318 -0.051 | 1.1465 0.4682 0.2449   | 30.190   27.5 ## 5         5         7  3.5 3.419 -0.741 -0.120 | 1.3419 0.4259 0.2380   | 37.512   27.3 ## 6         6         6  3.0 2.930 -0.635 -0.102 | 1.2930 0.4365 0.2398   | 35.680   27.8 ## 7         7         5  2.5 2.442 -0.529 -0.085 | 1.2442 0.4471 0.2415   | 33.851   26.0 ## 8         8         2  1.0 0.977 -0.212 -0.034 | 1.0977 0.4788 0.2466   | 28.361   25.3 plot(rating ~ dist, data = expt2) anal2 = lm(rating ~ poly(dist, 2),  data = expt2) with(expt2, {     ord = order(dist)     lines(dist[ord], predict(anal2)[ord]) })"},{"path":"https://github.com/rvlenth/rsm/articles/illus.html","id":"relocated-experiment","dir":"Articles","previous_headings":"","what":"Relocated experiment","title":"Response-surface illustration","text":"can run basically design first time around, new center. easily done using dupe changing codings: , baking … data collected, : … analysis: may seem dissimilar anal1 results, think , suggest just another steepest-ascent step. However, none linear (first-order) effects statistically significant, even jointly significant (\\(P\\approx0.30\\) ANOVA table); don’t compelling case even know direction might ! seems better instead collect data region see get clarity.","code":"expt3 = dupe(expt1) codings(expt3) = c(x1 ~ (flour - 1.25)/.1,  x2 ~ (sugar - .45)/.1,  x3 ~ (butter - .25)/.1) expt3 ##   run.order std.order flour sugar butter rating ## 1         1         5  1.25  0.45   0.25   26.6 ## 2         2         2  1.35  0.35   0.15   25.3 ## 3         3         4  1.35  0.55   0.35   23.7 ## 4         4         3  1.15  0.55   0.15   26.0 ## 5         5         7  1.25  0.45   0.25   27.8 ## 6         6         6  1.25  0.45   0.25   26.2 ## 7         7         1  1.15  0.35   0.35   27.3 ## 8         8         8  1.25  0.45   0.25   27.2 ##  ## Data are stored in coded form using these coding formulas ... ## x1 ~ (flour - 1.25)/0.1 ## x2 ~ (sugar - 0.45)/0.1 ## x3 ~ (butter - 0.25)/0.1 anal3 = rsm(rating ~ FO(x1,x2,x3), data=expt3) summary(anal3) ##  ## Call: ## rsm(formula = rating ~ FO(x1, x2, x3), data = expt3) ##  ##             Estimate Std. Error t value  Pr(>|t|)     ## (Intercept) 26.26250    0.40509 64.8306 3.391e-07 *** ## x1          -1.07500    0.57289 -1.8765    0.1338     ## x2          -0.72500    0.57289 -1.2655    0.2744     ## x3          -0.07500    0.57289 -0.1309    0.9022     ## --- ## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 ##  ## Multiple R-squared:  0.5624, Adjusted R-squared:  0.2341  ## F-statistic: 1.713 on 3 and 4 DF,  p-value: 0.3015 ##  ## Analysis of Variance Table ##  ## Response: rating ##                Df Sum Sq Mean Sq F value  Pr(>F) ## FO(x1, x2, x3)  3 6.7475  2.2492  1.7132 0.30145 ## Residuals       4 5.2512  1.3128                 ## Lack of fit     1 3.7812  3.7812  7.7168 0.06911 ## Pure error      3 1.4700  0.4900                 ##  ## Direction of steepest ascent (at radius 1): ##          x1          x2          x3  ## -0.82768868 -0.55820864 -0.05774572  ##  ## Corresponding increment in original units: ##        flour        sugar       butter  ## -0.082768868 -0.055820864 -0.005774572"},{"path":"https://github.com/rvlenth/rsm/articles/illus.html","id":"foldover-experiment","dir":"Articles","previous_headings":"","what":"Foldover experiment","title":"Response-surface illustration","text":"Recall first experiment half-fraction plus center points. can get information fraction. accomplished using foldover function, reverses signs coded variables (also re-randomizes experiment). case, original experiment generated using \\(x_3=x_1x_2\\), reverse \\(x_1\\), \\(x_3=-x_1x_2\\), thus half experiment. Note experiment indeed different factor combinations (e.g., \\((1.15,.35,.15))\\) present expt3. Back kitchen … data collected, : analysis, combine expt3 expt4, easily accomplished djoin function. Note djoin creates additional blocking factor: ’s important include block effect model two separately randomized experiments. particular case, ’s especially important expt4 seems higher values overall expt3; either raters better mood, ambient conditions changed. analysis: Now one first-order terms significant. lack fit test also quite significant. Response-surface experimentation different kinds experiments ’s actually “ideal” way nonsignificant effects, especially first-order ones, suggest might close peak. Well, one big first-order effect, evidence curvature; let’s carry .","code":"expt4 = foldover(expt3, variable = \"x1\") expt4$rating = NULL  ### discard previous rating data expt4   # Here's the new protocol ##   run.order std.order flour sugar butter ## 1         1         2  1.15  0.35   0.15 ## 2         2         7  1.25  0.45   0.25 ## 3         3         3  1.35  0.55   0.15 ## 4         4         4  1.15  0.55   0.35 ## 5         5         5  1.25  0.45   0.25 ## 6         6         6  1.25  0.45   0.25 ## 7         7         8  1.25  0.45   0.25 ## 8         8         1  1.35  0.35   0.35 ##  ## Data are stored in coded form using these coding formulas ... ## x1 ~ (flour - 1.25)/0.1 ## x2 ~ (sugar - 0.45)/0.1 ## x3 ~ (butter - 0.25)/0.1 expt4 ##   run.order std.order flour sugar butter rating ## 1         1         2  1.15  0.35   0.15   34.0 ## 2         2         7  1.25  0.45   0.25   35.1 ## 3         3         3  1.35  0.55   0.15   31.0 ## 4         4         4  1.15  0.55   0.35   34.6 ## 5         5         5  1.25  0.45   0.25   35.5 ## 6         6         6  1.25  0.45   0.25   34.9 ## 7         7         8  1.25  0.45   0.25   35.1 ## 8         8         1  1.35  0.35   0.35   33.3 ##  ## Data are stored in coded form using these coding formulas ... ## x1 ~ (flour - 1.25)/0.1 ## x2 ~ (sugar - 0.45)/0.1 ## x3 ~ (butter - 0.25)/0.1 names( djoin(expt3, expt4) ) ## [1] \"run.order\" \"std.order\" \"x1\"        \"x2\"        \"x3\"        \"rating\"    \"Block\" anal4 = rsm(rating ~ Block + FO(x1,x2,x3), data = djoin(expt3, expt4)) summary(anal4) ##  ## Call: ## rsm(formula = rating ~ Block + FO(x1, x2, x3), data = djoin(expt3,  ##     expt4)) ##  ##             Estimate Std. Error t value  Pr(>|t|)     ## (Intercept) 26.26250    0.40329 65.1208 1.388e-15 *** ## Block2       7.92500    0.57034 13.8953 2.543e-08 *** ## x1          -1.07500    0.40329 -2.6656   0.02197 *   ## x2          -0.57500    0.40329 -1.4258   0.18169     ## x3           0.32500    0.40329  0.8059   0.43739     ## --- ## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 ##  ## Multiple R-squared:  0.9486, Adjusted R-squared:  0.9299  ## F-statistic: 50.72 on 4 and 11 DF,  p-value: 5.075e-07 ##  ## Analysis of Variance Table ##  ## Response: rating ##                Df  Sum Sq Mean Sq  F value    Pr(>F) ## Block           1 251.223 251.223 193.0793 2.543e-08 ## FO(x1, x2, x3)  3  12.735   4.245   3.2625  0.063177 ## Residuals      11  14.313   1.301                    ## Lack of fit     5  12.653   2.531   9.1464  0.008934 ## Pure error      6   1.660   0.277                    ##  ## Direction of steepest ascent (at radius 1): ##         x1         x2         x3  ## -0.8520282 -0.4557360  0.2575899  ##  ## Corresponding increment in original units: ##       flour       sugar      butter  ## -0.08520282 -0.04557360  0.02575899"},{"path":"https://github.com/rvlenth/rsm/articles/illus.html","id":"augmenting-further-to-estimate-a-second-order-response-surface","dir":"Articles","previous_headings":"Foldover experiment","what":"Augmenting further to estimate a second-order response surface","title":"Response-surface illustration","text":"lack fit, ’s now good idea collect data “star” axis points can fit second-order model. illustrated earlier, star function us. choose parameter alpha (\\(\\alpha\\)) star block orthogonal cube blocks; seems like good idea, given strong observed block effect . next experiment, using six axis points 2 center points (already 8 center points location), 8 runs. analysis based combining cube clock, foldover, star block:  second-order design contemplated earlier, involves adding star points complete \\(2^3\\) design; reasonable prediction-variance properties. Time passes, cakes baked rated, data: fit second-order model, accounting block effect. significant first second-order terms now, nonsignificant lack fit. summary includes canonical analysis gives coordinates estimated stationary point canonical directions (eigenvectors) point. , fitted surface characterized form \\(\\hat{y}(v_1,v_2,v_3) = \\hat{y}_s + \\lambda_1v_1^2 + \\lambda_2v_2^2 + \\lambda_3v_3^2\\) \\(\\hat{y}_s\\) fitted value stationary point, eigenvalues denoted \\(\\lambda_j\\), eigenvectors denoted \\(v_j\\). Since three eigenvalues negative, estimated surface decreases directions value \\(\\hat{y}_s\\) hence maximum . However, stationary point nowhere near experiment, extreme extrapolation trusted . (fact, decoded units, estimated optimum calls negative amount sugar!) best bet now experiment path leads us vaguely toward distant stationary point.","code":"expt5 = star(expt4, n0 = 2, alpha = \"orthogonal\") par(mfrow=c(1,2)) comb = djoin(expt3, expt4, expt5) varfcn(comb, ~ Block + SO(x1,x2,x3), main = \"Further augmented\") varfcn(comb, ~ Block + SO(x1,x2,x3), contour = TRUE, main = \"2nd order\") expt5 ##   run.order std.order    flour     sugar    butter rating ## 1         1         4 1.250000 0.5914214 0.2500000   26.0 ## 2         2         2 1.391421 0.4500000 0.2500000   23.9 ## 3         3         6 1.250000 0.4500000 0.3914214   27.6 ## 4         4         7 1.250000 0.4500000 0.2500000   26.7 ## 5         5         1 1.108579 0.4500000 0.2500000   26.7 ## 6         6         5 1.250000 0.4500000 0.1085786   27.3 ## 7         7         3 1.250000 0.3085786 0.2500000   29.3 ## 8         8         8 1.250000 0.4500000 0.2500000   27.4 ##  ## Data are stored in coded form using these coding formulas ... ## x1 ~ (flour - 1.25)/0.1 ## x2 ~ (sugar - 0.45)/0.1 ## x3 ~ (butter - 0.25)/0.1 anal5 = rsm(rating ~ Block + SO(x1,x2,x3), data = djoin(expt3, expt4, expt5)) summary(anal5) ##  ## Call: ## rsm(formula = rating ~ Block + SO(x1, x2, x3), data = djoin(expt3,  ##     expt4, expt5)) ##  ##                Estimate  Std. Error  t value  Pr(>|t|)     ## (Intercept)  2.6996e+01  2.5051e-01 107.7647 < 2.2e-16 *** ## Block2       7.9250e+00  2.9641e-01  26.7366 4.601e-12 *** ## Block3       6.0000e-01  2.9641e-01   2.0242  0.065795 .   ## x1          -1.0466e+00  1.7113e-01  -6.1160 5.208e-05 *** ## x2          -7.7224e-01  1.7113e-01  -4.5125  0.000711 *** ## x3           2.5202e-01  1.7113e-01   1.4727  0.166578     ## x1:x2       -4.0000e-01  2.0959e-01  -1.9085  0.080537 .   ## x1:x3       -1.5000e-01  2.0959e-01  -0.7157  0.487888     ## x2:x3        7.9051e-16  2.0959e-01   0.0000  1.000000     ## x1^2        -1.2393e+00  1.9405e-01  -6.3865 3.471e-05 *** ## x2^2        -6.4286e-02  1.9405e-01  -0.3313  0.746139     ## x3^2        -1.6429e-01  1.9405e-01  -0.8466  0.413766     ## --- ## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 ##  ## Multiple R-squared:  0.9881, Adjusted R-squared:  0.9772  ## F-statistic: 90.77 on 11 and 12 DF,  p-value: 8.46e-10 ##  ## Analysis of Variance Table ##  ## Response: rating ##                 Df  Sum Sq Mean Sq  F value    Pr(>F) ## Block            2 311.523 155.762 443.2137 5.678e-12 ## FO(x1, x2, x3)   3  21.064   7.021  19.9791 5.849e-05 ## TWI(x1, x2, x3)  3   1.460   0.487   1.3848  0.294838 ## PQ(x1, x2, x3)   3  16.845   5.615  15.9771  0.000172 ## Residuals       12   4.217   0.351                    ## Lack of fit      5   2.312   0.462   1.6993  0.252578 ## Pure error       7   1.905   0.272                    ##  ## Stationary point of response surface: ##         x1         x2         x3  ##  1.0644952 -9.3180901  0.2810583  ##  ## Stationary point in original units: ##      flour      sugar     butter  ##  1.3564495 -0.4818090  0.2781058  ##  ## Eigenanalysis: ## eigen() decomposition ## $values ## [1] -0.03002067 -0.16052168 -1.27731479 ##  ## $vectors ##           [,1]        [,2]       [,3] ## x1  0.16811860 -0.04985422 0.98450530 ## x2 -0.98128332 -0.10360829 0.16232180 ## x3 -0.09391048  0.99336795 0.06633959"},{"path":"https://github.com/rvlenth/rsm/articles/illus.html","id":"ridge-analysis-second-order-steepest-ascent","dir":"Articles","previous_headings":"","what":"Ridge analysis (second-order steepest ascent)","title":"Response-surface illustration","text":"steepest function may used; time computes curved path steepest ascent, based ridge analysis: distance 3, starts venturing unreasonable combinations design factors. let’s experiment 8 distances spread 2/3 apart coded units: cakes baked rated, let’s analysis like expt2:  looks like center new experiment distance 1.5 —perhaps flour still 1.25, sugar butter .30.","code":"steepest(anal5) ## Path of steepest ascent from ridge analysis: ##    dist     x1     x2    x3 |  flour   sugar butter |   yhat ## 1   0.0  0.000  0.000 0.000 | 1.2500  0.4500 0.2500 | 26.996 ## 2   0.5 -0.227 -0.417 0.156 | 1.2273  0.4083 0.2656 | 27.484 ## 3   1.0 -0.235 -0.922 0.307 | 1.2265  0.3578 0.2807 | 27.817 ## 4   1.5 -0.189 -1.431 0.408 | 1.2311  0.3069 0.2908 | 28.102 ## 5   2.0 -0.126 -1.939 0.473 | 1.2374  0.2561 0.2973 | 28.358 ## 6   2.5 -0.055 -2.446 0.514 | 1.2445  0.2054 0.3014 | 28.591 ## 7   3.0  0.020 -2.951 0.536 | 1.2520  0.1549 0.3036 | 28.804 ## 8   3.5  0.098 -3.456 0.546 | 1.2598  0.1044 0.3046 | 28.999 ## 9   4.0  0.178 -3.959 0.546 | 1.2678  0.0541 0.3046 | 29.177 ## 10  4.5  0.258 -4.459 0.538 | 1.2758  0.0041 0.3038 | 29.337 ## 11  5.0  0.339 -4.961 0.525 | 1.2839 -0.0461 0.3025 | 29.481 expt6 = dupe(steepest(anal5, dist = (2:9)/3)) ## Path of steepest ascent from ridge analysis: expt6 ##   run.order std.order      dist     x1     x2    x3 |  flour  sugar butter |.1   yhat rating ## 1         1         3 1.3333333 -0.207 -1.261 0.379 | 1.2293 0.3239 0.2879   | 28.011   35.5 ## 2         2         5 2.0000000 -0.126 -1.939 0.473 | 1.2374 0.2561 0.2973   | 28.358   33.8 ## 3         3         2 1.0000000 -0.235 -0.922 0.307 | 1.2265 0.3578 0.2807   | 27.817   35.0 ## 4         4         1 0.6666667 -0.241 -0.584 0.212 | 1.2259 0.3916 0.2712   | 27.603   34.1 ## 5         5         7 2.6666667 -0.030 -2.615 0.523 | 1.2470 0.1885 0.3023   | 28.664   33.3 ## 6         6         6 2.3333333 -0.079 -2.278 0.502 | 1.2421 0.2222 0.3002   | 28.516   34.2 ## 7         7         4 1.6666667 -0.169 -1.600 0.433 | 1.2331 0.2900 0.2933   | 28.190   34.7 ## 8         8         8 3.0000000  0.020 -2.951 0.536 | 1.2520 0.1549 0.3036   | 28.804   33.4 par(mar=c(4,4,0,0)+.1) plot(rating ~ dist, data = expt6) anal6 = lm(rating ~ poly(dist, 2),  data = expt6) with(expt6, {     ord = order(dist)     lines(dist[ord], predict(anal6)[ord]) })"},{"path":"https://github.com/rvlenth/rsm/articles/illus.html","id":"second-order-design-at-the-new-location","dir":"Articles","previous_headings":"","what":"Second-order design at the new location","title":"Response-surface illustration","text":"now situation already know curvature, might well go straight second-order experiment. less critical assess lack fit, don’t need many center points. Note past experiments 8 runs—practical size one block. things considered, decide run central-composite design cube portion complete \\(2^3\\) design (8 runs center points), star portion including two center points (another block 8 runs). Let’s generate design, magically cooking rating two 8-run experiments: … data collected: turns obtain orthogonal blocks, locating star points \\(\\pm\\alpha=\\pm2\\) correct choice numbers center points; hence nice round values. ’s analysis; ’ll go straight second-order model, , need include block effect model. model fits decently, important second-order terms. exciting news stationary point quite close design center, indeed maximum since three eigenvalues negative. looks like best recipe around \\(1.22\\)c.flour, \\(.28\\)c.sugar, \\(.36\\)c.butter. Let’s look graphically using contour function, slicing fitted surface stationary point.  ’s also helpful know well estimated stationary point. simple bootstrap procedure helps us understand . code , simulate 200 re-fits model, scrambling residuals adding back fitted values; plot stationary points along one estimated anal7. replicate function returns matrix 3 rows 200 columns (one bootstrap replication); need transpose result decode values.  plots show something akin confidence region best recipe. Note follow symmetrical elliptical patterns, multivariate normal; due primarily nonlinearity estimating stationary point.","code":"expt7  =  ccd( ~ x1 + x2 + x3,  n0 = c(0, 2),  alpha = \"orth\",  coding  =  c(             x1 ~ (flour - 1.25)/.1,  x2 ~ (sugar - .3)/.1,  x3 ~ (butter - .3)/.1)) expt7 ##    run.order std.order flour sugar butter Block rating ## 1          1         5  1.15   0.2    0.4     1   26.6 ## 2          2         1  1.15   0.2    0.2     1   25.6 ## 3          3         6  1.35   0.2    0.4     1   26.6 ## 4          4         3  1.15   0.4    0.2     1   26.2 ## 5          5         8  1.35   0.4    0.4     1   24.5 ## 6          6         7  1.15   0.4    0.4     1   27.3 ## 7          7         2  1.35   0.2    0.2     1   23.5 ## 8          8         4  1.35   0.4    0.2     1   24.7 ## 9          1         8  1.25   0.3    0.3     2   27.9 ## 10         2         2  1.45   0.3    0.3     2   22.0 ## 11         3         5  1.25   0.3    0.1     2   25.2 ## 12         4         3  1.25   0.1    0.3     2   26.5 ## 13         5         4  1.25   0.5    0.3     2   25.9 ## 14         6         6  1.25   0.3    0.5     2   27.8 ## 15         7         1  1.05   0.3    0.3     2   26.0 ## 16         8         7  1.25   0.3    0.3     2   29.3 ##  ## Data are stored in coded form using these coding formulas ... ## x1 ~ (flour - 1.25)/0.1 ## x2 ~ (sugar - 0.3)/0.1 ## x3 ~ (butter - 0.3)/0.1 anal7 = rsm(rating ~ Block + SO(x1,x2,x3), data = expt7) summary(anal7) ##  ## Call: ## rsm(formula = rating ~ Block + SO(x1, x2, x3), data = expt7) ##  ##             Estimate Std. Error t value  Pr(>|t|)     ## (Intercept) 27.90000    0.52417 53.2274 4.426e-08 *** ## Block2       0.70000    0.37064  1.8886  0.117568     ## x1          -0.90000    0.18532 -4.8564  0.004648 **  ## x2          -0.05000    0.18532 -0.2698  0.798093     ## x3           0.63750    0.18532  3.4400  0.018436 *   ## x1:x2       -0.27500    0.26208 -1.0493  0.342094     ## x1:x3        0.10000    0.26208  0.3816  0.718466     ## x2:x3       -0.40000    0.26208 -1.5262  0.187476     ## x1^2        -1.15000    0.18532 -6.2055  0.001587 **  ## x2^2        -0.60000    0.18532 -3.2376  0.023010 *   ## x3^2        -0.52500    0.18532 -2.8329  0.036549 *   ## --- ## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 ##  ## Multiple R-squared:  0.9421, Adjusted R-squared:  0.8262  ## F-statistic: 8.131 on 10 and 5 DF,  p-value: 0.01602 ##  ## Analysis of Variance Table ##  ## Response: rating ##                 Df  Sum Sq Mean Sq F value   Pr(>F) ## Block            1  1.9600  1.9600  3.5669 0.117568 ## FO(x1, x2, x3)   3 19.5025  6.5008 11.8305 0.010422 ## TWI(x1, x2, x3)  3  1.9650  0.6550  1.1920 0.401731 ## PQ(x1, x2, x3)   3 21.2550  7.0850 12.8935 0.008653 ## Residuals        5  2.7475  0.5495                  ## Lack of fit      4  1.7675  0.4419  0.4509 0.789337 ## Pure error       1  0.9800  0.9800                  ##  ## Stationary point of response surface: ##         x1         x2         x3  ## -0.3421914 -0.1772769  0.6420873  ##  ## Stationary point in original units: ##     flour     sugar    butter  ## 1.2157809 0.2822723 0.3642087  ##  ## Eigenanalysis: ## eigen() decomposition ## $values ## [1] -0.3390336 -0.7534946 -1.1824718 ##  ## $vectors ##          [,1]       [,2]         [,3] ## x1  0.1562180 -0.1664741  0.973592470 ## x2 -0.6513590  0.7236263  0.228246488 ## x3  0.7425142  0.6698144 -0.004609058 par(cex.lab=1.25, cex.axis=1, cex.sub=1.5, mar=.1+c(4.5,7,0,0)) par(mfrow=c(1,3)) contour(anal7, ~ x1 + x2 + x3, at = xs(anal7), image = TRUE) fits = predict(anal7) resids = resid(anal7) boot.raw = suppressMessages(     replicate(200, xs(update(anal7, fits + sample(resids, replace=TRUE) ~ .)))) boot = code2val(as.data.frame(t(boot.raw)), codings=codings(anal7)) par(mar=.1+c(4,5,0,0), cex.lab=1.5) par(mfrow = c(1,3)) plot(sugar ~ flour, data = boot, col = \"gray\");   points(1.215, .282, col = \"red\", pch = 7) plot(butter ~ flour, data = boot, col = \"gray\");  points(1.215, .364, col = \"red\", pch = 7) plot(butter ~ sugar, data = boot, col = \"gray\");  points(.282, .364, col = \"red\", pch = 7)"},{"path":"https://github.com/rvlenth/rsm/articles/illus.html","id":"summary","dir":"Articles","previous_headings":"","what":"Summary","title":"Response-surface illustration","text":"convenience, tabular summary required 64 experimental runs find optimum. home baker, 64 cakes lot. commercial baker, bad considering much variation response measures fact now better recipe. just kept baking cakes recipe, can’t gain knowledge. varying recipe disciplined ways can improve .","code":""},{"path":"https://github.com/rvlenth/rsm/articles/plots.html","id":"abstract","dir":"Articles","previous_headings":"","what":"Abstract","title":"Surface Plots in the rsm Package","text":"companion main vignette rsm package, providing details use contour, image, persp visualize fitted response surfaces. designed rsm objects mind, methods work lm object thus provide quick way graph fitted surface. Enhancements include coloring, adding contour lines perspective plots, hooks provide additional annotations.","code":""},{"path":"https://github.com/rvlenth/rsm/articles/plots.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Surface Plots in the rsm Package","text":"regression model fitted using two continuous predictors, useful present graphical visualization fitted surface. end, functions contour.lm, persp.lm image.lm developed incorporated rsm package, inasmuch surface visualization especially important using response-surface methods. three functions S3 methods objects class lm, classes (rsm) inherit lm. vignette meant document functions; please refer help pages details. goal illustrate use.","code":""},{"path":"https://github.com/rvlenth/rsm/articles/plots.html","id":"models-with-two-predictors","dir":"Articles","previous_headings":"","what":"Models with two predictors","title":"Surface Plots in the rsm Package","text":"Consider example using ubiquitous swiss dataset standard R. Let us fit model Fertility polynomial function Agriculture Education: following basic calls illustrate default results three functions. Note use formula second argument specify variable goes axis. persp plot uses different viewpoint, distance, tick type default; feel new defaults better viewing response surfaces. Generally, perspective plots best displayed small space. also helps enhance shading, colors, contour lines. following call illustrates create enhanced version perspective plot different point view, shading, different surface color, contour lines added top surface box. also restrict predictor values narrower ranges.","code":"swiss2.lm <- lm(Fertility ~ poly(Agriculture, Education, degree=2), data=swiss) library(rsm) par(mfrow=c(1,3)) image(swiss2.lm, Education ~ Agriculture) contour(swiss2.lm, Education ~ Agriculture) persp(swiss2.lm, Education ~ Agriculture, zlab = \"Fertility\") persp(swiss2.lm, Education ~ Agriculture, col = \"blue\",    bounds = list(Agriculture=c(20,70), Education=c(0,30)),   zlab = \"Predicted Fertility\",    contours = list(z=\"top\", col=\"orange\", shade = 1),    theta = -135, phi = 35)"},{"path":"https://github.com/rvlenth/rsm/articles/plots.html","id":"three-or-more-predictors","dir":"Articles","previous_headings":"","what":"Three or more predictors","title":"Surface Plots in the rsm Package","text":"regression model two continuous predictors, additional issues arise: can use two predictors time image, contour, surface plot. two given predictors, surface plot change depending values predictors. (defaults image, contour, persp use average, can changed.) one surface plot; desirable keep scaling coloring consistent among plots. (happens automatically three functions; way defeat manually plotting retrieved surface data.) illustration, use data paper-helicopter experiment described Box *et al. (2005), page 499, provided rsm package dataset heli. variables coded variables \\(x_1\\)–\\(x_4\\), , respectively, linear functions wing area \\(\\), wing length ratio \\(R\\), body width \\(W\\), body length \\(L\\). experiment run two blocks, response variable ave, average flight time seconds. dataset analyzed detail . second-order response-surface model data obtained using rsm object extension lm object extra response-surface-related information included. obtain contour plots 6 possible pairs variables \\(x_1\\)–\\(x_4\\), simply specify formula ~ x1 + x2 + x3 + x4 call contour: heli dataset extension data.frame contains coding information, information retained heli.rsm. coding present, default, coding formulas used decode axis values \\(x_1,x_2,x_3,x_4\\) original values \\(,R,W,L\\). Also, variables coordinate axes involved, displayed slice response surface, holding variables fixed certain values. default, use averages numeric predictors, first levels factors. information incorporated part \\(x\\)-axis label contour plot. example, probably interested behavior response surface neighborhood stationary point (gradient zero). show little bit discussion next section.","code":"heli.rsm <- rsm(ave ~ block + SO(x1,x2,x3,x4), data = heli) par(mfrow = c(2,3)) contour (heli.rsm, ~ x1 + x2 + x3 + x4)"},{"path":"https://github.com/rvlenth/rsm/articles/plots.html","id":"annotations-and-hooks","dir":"Articles","previous_headings":"","what":"Annotations and hooks","title":"Surface Plots in the rsm Package","text":"Suppose helicopter example, want add annotations plots. Since several plots, don’t want manually. contour method lm objects (well image persp) allow one specify hook argument take care things like . hook list containing function definitions one pre.plot post.plot. Obviously, functions run just , just , plot constructed. function passed one argument, character vector length \\(4\\); elements \\(1\\) ~2 labels horizontal vertical axes; elements \\(3\\) ~\\(4\\) corresponding variable names; element 5 label describing slice plotted. following code, set post.plot hook plot position stationary point graph. coding bit tedious due need match elements xs variable names. gets trickier contour smart enough decode coordinates original units, doesn’t decoding hook functions; left user. create enhanced contour plot, use argument specify want plots sliced stationary point instead origin, image argument enhance plots background color image, use hook incorporate hook function. Centering stationary point gives entirely different view fitted surface seen previous figure.","code":"xs <- canonical(heli.rsm)$xs          # stat.pt. in coded units SP <- code2val(xs, codings(heli.rsm)) # in decoded units myhook <- list() myhook$post.plot <- function(lab) {   idx <- sapply(lab[3:4], grep, names(xs))   points (SP[idx[1]], SP[idx[2]], pch = 2, col = \"red\") } par(mfrow = c(2,3)) contour (heli.rsm, ~ x1 + x2 + x3 + x4, image = TRUE,   at = xs, hook = myhook)"},{"path":"https://github.com/rvlenth/rsm/articles/plots.html","id":"saving-graphs","dir":"Articles","previous_headings":"","what":"Saving graphs","title":"Surface Plots in the rsm Package","text":"Sometimes may want access individual plots multi-panel frame. PS PDF, easy handle. example, consider code: resulting file six pages, one per graph. can import, say, fourth graph pdflatex source file using command like formats, can use hooks create separate files based variable names. example, {r}{eval=FALSE} png.hook <- list() png.hook$pre.plot <- function(lab)      png(file = paste(lab[3], lab[4], `.png`, sep = ``)) png.hook$post.plot = function(lab)     dev.() contour (heli.rsm, ~ x1 + x2 + x3 + x4, image = TRUE, = xs, hook = png.hook)","code":"pdf(file = \"heli-cps.pdf\") contour (heli.rsm, ~ x1 + x2 + x3 + x4, image = TRUE, at = xs, hook = myhook) dev.off() \\includegraphics[width=.75\\linewidth, page=4]{heli-cps.pdf}"},{"path":"https://github.com/rvlenth/rsm/articles/plots.html","id":"more-on-perspective-plots","dir":"Articles","previous_headings":"","what":"More on perspective plots","title":"Surface Plots in the rsm Package","text":"lm method persp handles col argument differently default persp function. single color, determines surface-facet colors based fitted response value (like done image) rather requiring matrix facet colors.","code":""},{"path":"https://github.com/rvlenth/rsm/articles/plots.html","id":"adding-contours","dir":"Articles","previous_headings":"More on perspective plots","what":"Adding contours","title":"Surface Plots in the rsm Package","text":"add contour lines perspective plot, use contours argument. may boolean value, character value, list. contours=TRUE equivalently, , contour lines drawn bottom surface box using default foreground color. contours=\"top\", drawn top. Bottom contours drawn surface drawn (may become partially obscured), top contours drawn afterward. value contours=\"colors\" draw contours bottom, using colors corresponding contour levels surface (illustrated prespective plot). character value contours taken color name contours, e.g., contours=\"green\". control, contours can list containing col (may either \"colors\" valid color), “z” (may \"top\", \"bottom\", numeric \\(z\\) value), \"lwd\" (control width lines). \\begin{figure}","code":"persp (heli.rsm, x2 ~ x1, at = xs, col = rainbow(50), contours = \"colors\") persp (heli.rsm, x4 ~ x1, at = xs, col = rainbow(50), contours = \"colors\")"},{"path":"https://github.com/rvlenth/rsm/articles/plots.html","id":"doing-it-your-own-way","dir":"Articles","previous_headings":"","what":"Doing it your own way","title":"Surface Plots in the rsm Package","text":"functions produce exactly plot want, may still able save lot work calling contour desired object formula(s), plot.=FALSE. returned object list data plot—\\(x\\) \\(y\\) values, \\(z\\) matrix, range \\(z\\) across plots, axis labels.","code":""},{"path":"https://github.com/rvlenth/rsm/articles/plots.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Surface Plots in the rsm Package","text":"Box GEP, Hunter WG, Hunter JS (2005). Statistics Experimenters: Introduction Design, Data Analysis, Model Building. 2nd edition. John Wiley & Sons, New York.","code":""},{"path":"https://github.com/rvlenth/rsm/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Russell Lenth. Author, maintainer.","code":""},{"path":"https://github.com/rvlenth/rsm/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Russell V. Lenth (2009). Response-Surface Methods R, Using rsm. Journal Statistical Software, 32(7), 1-17. DOI: 10.18637/jss.v032.i07","code":"@Article{,   title = {Response-Surface Methods in {R}, Using {rsm}},   author = {Russell Lenth},   journal = {Journal of Statistical Software},   year = {2009},   volume = {32},   number = {7},   pages = {1--17},   doi = {10.18637/jss.v032.i07}, }"},{"path":[]},{"path":"https://github.com/rvlenth/rsm/index.html","id":"features","dir":"","previous_headings":"","what":"Features","title":"Response-Surface Analysis","text":"Response-surface methods conducting series small experiments find optimum operating conditions process. rsm package provides tools designing response-surface experiments, analyzing results, finding promising new settings future experiments, visualization fitted response surfaces. package three vignettes help orient first-time user. Calling vignette(\"article\", package = \"rsm\") brings updated rendering original JSS article describes functionality. tutorial available via vignette(\"illus\", package = \"rsm\") – gives illustration package can used. one rsm’s plotting capabilities available via vignette(\"plots\", package = \"rsm\"); shows details contour, image, perspective plots. Includes support coded-data structure, important expressing design layout relative central location. Standard first- second-order designs may generated appropriately randomized. Facilities provided augmenting design – example, adding foldover block set axis points. rsm function special extension lm facilitates fitting evaluating first- second-order models. Special functions FO(), (), PQ(), TWI() used generate first-order, second-order, pure quadratic, two-way-interaction predictors model. Functions steepest() allow finding follow-experiments terms coded decoded predictors. Graphical tools provided creating contour plots – just rsm objects, abut lm object continuous predictors.","code":""},{"path":"https://github.com/rvlenth/rsm/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Response-Surface Analysis","text":"install latest version CRAN, run Release notes latest CRAN version found http://cran.r-project.org/web/packages/rsm/NEWS – news(package = \"rsm\") notes version installed. install latest development version Github, newest devtools package installed, run latest release notes development version, see NEWS file","code":"install.packages(\"rsm\") devtools::install_github(\"rvlenth/rsm\", dependencies = TRUE)"},{"path":"https://github.com/rvlenth/rsm/reference/ChemReact.html","id":null,"dir":"Reference","previous_headings":"","what":"Chemical Reaction Data — ChemReact","title":"Chemical Reaction Data — ChemReact","text":"data central composite design 2 factors 2 blocks.   design variables actual, coded, form.","code":""},{"path":"https://github.com/rvlenth/rsm/reference/ChemReact.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Chemical Reaction Data — ChemReact","text":"","code":"ChemReact ChemReact1 ChemReact2"},{"path":"https://github.com/rvlenth/rsm/reference/ChemReact.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Chemical Reaction Data — ChemReact","text":"data frame 14 observations following 4 variables. Time numeric vector; design variable settings 80, 85, 90. Temp numeric vector; design variable settings 170, 175, 180. Block factor levels B1 B2.     Block B1 first-order design 3 center points.       Block B2 consists axis points 3 center points. Yield numeric vector; response variable: yield chemical process. ChemReact1 ChemReact2 separate blocks.      7 runs three variables (Block excluded ).","code":""},{"path":"https://github.com/rvlenth/rsm/reference/ChemReact.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Chemical Reaction Data — ChemReact","text":"Table 7.6 Myers, RH, Montgomery, DC, Anderson-Cook, CM (2009),  Response Surface Methodology (3rd ed.), Wiley.","code":""},{"path":"https://github.com/rvlenth/rsm/reference/FO.html","id":null,"dir":"Reference","previous_headings":"","what":"Response-surface model components — FO","title":"Response-surface model components — FO","text":"Use one functions model specify portion model   regarded response-surface component.","code":""},{"path":"https://github.com/rvlenth/rsm/reference/FO.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Response-surface model components — FO","text":"","code":"FO (...) TWI (..., formula) PQ (...) SO (...) PE (...)"},{"path":"https://github.com/rvlenth/rsm/reference/FO.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Response-surface model components — FO","text":"... numerical predictors response surface,    separated commas. formula Alternative way specify two-way interactions. Use formula ..., never .","code":""},{"path":"https://github.com/rvlenth/rsm/reference/FO.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Response-surface model components — FO","text":"Use FO() model formula rsm   specify first-order response surface (.e., linear function)    arguments.  Use TWI() generate two-way interactions, PQ() generate   pure quadratic terms (squares FO() terms).  call   () creates terms FO(), TWI(), PQ() (order)   variables.  However, specifying () model formula rsm replaced    explicit sum model terms, anova table shows separate sums squares.   variables (blocks factors) may included model   never included arguments FO . PE used fitting pure-error models.  used   response-surface models.  function exists primarily use   loftest, useful linear-model   contexts fitting model interpolates means distinct   combination argument values. formula argument TWI can simplify specifying models certain interactions included. example, TWI(formula = ~x1:(x2+x3)) equivalent TWI(x1,x2) + TWI(x1,x3). formula expanded using terms, second-order terms retained. results one term, error condition raised. necessary prevent rsm getting confused identifying second-order terms.","code":""},{"path":"https://github.com/rvlenth/rsm/reference/FO.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Response-surface model components — FO","text":"functions FO, TWI, PQ, return matrix whose   columns required predictors.  PE returns factor whose levels distinct combinations   arguments provided function.","code":""},{"path":"https://github.com/rvlenth/rsm/reference/FO.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Response-surface model components — FO","text":"Lenth RV (2009) ``Response-Surface Methods R, Using rsm'',    Journal Statistical Software, 32(7), 1--17.    doi:10.18637/jss.v032.i07","code":""},{"path":"https://github.com/rvlenth/rsm/reference/FO.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Response-surface model components — FO","text":"Russell V. Lenth","code":""},{"path":[]},{"path":"https://github.com/rvlenth/rsm/reference/FO.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Response-surface model components — FO","text":"","code":"### See 'rsm' help for examples of FO, TWI, etc      library(rsm)   ### Test LOF for a regression model   ChemReact.lm <- lm(Yield ~ Time*Temp, data = ChemReact1)   PureError.lm <- update (ChemReact.lm, . ~ PE(Time,Temp))   anova (ChemReact.lm, PureError.lm) #> Analysis of Variance Table #>  #> Model 1: Yield ~ Time * Temp #> Model 2: Yield ~ PE(Time, Temp) #>   Res.Df    RSS Df Sum of Sq      F   Pr(>F)    #> 1      3 8.3211                                 #> 2      2 0.0867  1    8.2344 190.02 0.005221 ** #> --- #> Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1"},{"path":"https://github.com/rvlenth/rsm/reference/bbd.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate a Box-Behnken design — bbd","title":"Generate a Box-Behnken design — bbd","text":"function can generate Box-Behnken design 3 7 factors, optionally block orthogonally 4 5 factors.  can also randomize design.","code":""},{"path":"https://github.com/rvlenth/rsm/reference/bbd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate a Box-Behnken design — bbd","text":"","code":"bbd(k, n0 = 4, block = (k == 4 | k == 5), randomize = TRUE, coding)"},{"path":"https://github.com/rvlenth/rsm/reference/bbd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate a Box-Behnken design — bbd","text":"k formula, integer giving number variables.  formula left-hand side, variables named appended design initialized NA. n0 Number center points block. block Logical value specifying whether block design; character string (taken TRUE) giving desired name blocking factor.   BBDs 4 5 factors can blocked.  4-factor BBD three orthogonal blocks, 5-factor BBD two. randomize Logical value determining whether randomize design.  block TRUE, block randomized separately. coding Optional list formulas.  provided, overrides default coding formulas.","code":""},{"path":"https://github.com/rvlenth/rsm/reference/bbd.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate a Box-Behnken design — bbd","text":"Box-Behnken designs (BBDs) useful designs fitting second-order response-surface models.  use three levels factor (compared 5 central-composite designs) sometimes fewer runs required CCD. function uses internal table BBDs; works 3 7 factors. k specified formula, names formula determine names factors generated design.  Otherwise, names x1, x2, .... coding specified, default codings created form x ~ x...","code":""},{"path":"https://github.com/rvlenth/rsm/reference/bbd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate a Box-Behnken design — bbd","text":"coded.data object generated design additional valiables run.order std.order.  blocking variable, present, factor; variables numeric.","code":""},{"path":"https://github.com/rvlenth/rsm/reference/bbd.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Generate a Box-Behnken design — bbd","text":"avoid aliasing pure-quadratic terms, must use positive value n0. non-exported function rsm:::.bbd.1.41 provided case needed packages compatibility old versions rsm (version 1.41 earlier). Given seed, also reproduce randomization previously generated design old version.","code":""},{"path":"https://github.com/rvlenth/rsm/reference/bbd.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Generate a Box-Behnken design — bbd","text":"Lenth RV (2009) ``Response-Surface Methods R, Using rsm'',    Journal Statistical Software, 32(7), 1--17.    doi:10.18637/jss.v032.i07 Myers, RH, Montgomery, DC, Anderson-Cook, CM (2009)  Response Surface Methodology (3rd ed.), Wiley.","code":""},{"path":"https://github.com/rvlenth/rsm/reference/bbd.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Generate a Box-Behnken design — bbd","text":"Russell V. Lenth","code":""},{"path":[]},{"path":"https://github.com/rvlenth/rsm/reference/bbd.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate a Box-Behnken design — bbd","text":"","code":"library(rsm)  ### Simple 3-factor case, not randomized so structure is evident bbd(3, randomize=FALSE) #>    run.order std.order x1.as.is x2.as.is x3.as.is #> 1          1         1       -1       -1        0 #> 2          2         2        1       -1        0 #> 3          3         3       -1        1        0 #> 4          4         4        1        1        0 #> 5          5         5       -1        0       -1 #> 6          6         6        1        0       -1 #> 7          7         7       -1        0        1 #> 8          8         8        1        0        1 #> 9          9         9        0       -1       -1 #> 10        10        10        0        1       -1 #> 11        11        11        0       -1        1 #> 12        12        12        0        1        1 #> 13        13        13        0        0        0 #> 14        14        14        0        0        0 #> 15        15        15        0        0        0 #> 16        16        16        0        0        0 #>  #> Data are stored in coded form using these coding formulas ... #> x1 ~ x1.as.is #> x2 ~ x2.as.is #> x3 ~ x3.as.is  ### 5-factor BBD, divided between two plants bbd(y1 + y2 ~ A + B + C + D + E,  n0 = 5,  block = \"Plant\") #>    run.order std.order Plant A.as.is B.as.is C.as.is D.as.is E.as.is y1 y2 #> 1          1        24     1       0       0       0       0       0 NA NA #> 2          2        14     1       0       0       0       1      -1 NA NA #> 3          3        25     1       0       0       0       0       0 NA NA #> 4          4         8     1       1       0       1       0       0 NA NA #> 5          5         4     1       1       1       0       0       0 NA NA #> 6          6         5     1      -1       0      -1       0       0 NA NA #> 7          7        15     1       0       0       0      -1       1 NA NA #> 8          8        13     1       0       0       0      -1      -1 NA NA #> 9          9        10     1       0       0       1      -1       0 NA NA #> 10        10        17     1       0      -1       0       0      -1 NA NA #> 11        11        22     1       0       0       0       0       0 NA NA #> 12        12         3     1      -1       1       0       0       0 NA NA #> 13        13         1     1      -1      -1       0       0       0 NA NA #> 14        14        16     1       0       0       0       1       1 NA NA #> 15        15         6     1       1       0      -1       0       0 NA NA #> 16        16        19     1       0      -1       0       0       1 NA NA #> 17        17        23     1       0       0       0       0       0 NA NA #> 18        18        18     1       0       1       0       0      -1 NA NA #> 19        19        12     1       0       0       1       1       0 NA NA #> 20        20         7     1      -1       0       1       0       0 NA NA #> 21        21         9     1       0       0      -1      -1       0 NA NA #> 22        22        11     1       0       0      -1       1       0 NA NA #> 23        23         2     1       1      -1       0       0       0 NA NA #> 24        24        20     1       0       1       0       0       1 NA NA #> 25        25        21     1       0       0       0       0       0 NA NA #> 26         1        38     2       0      -1       0      -1       0 NA NA #> 27         2        33     2       1       0       0       0       1 NA NA #> 28         3        41     2       0       1       0       1       0 NA NA #> 29         4        35     2       0       1      -1       0       0 NA NA #> 30         5        46     2       0       0       0       0       0 NA NA #> 31         6        30     2      -1       0       0       0      -1 NA NA #> 32         7        28     2      -1       0       0       1       0 NA NA #> 33         8        36     2       0      -1       1       0       0 NA NA #> 34         9        31     2       1       0       0       0      -1 NA NA #> 35        10        32     2      -1       0       0       0       1 NA NA #> 36        11        27     2       1       0       0      -1       0 NA NA #> 37        12        49     2       0       0       0       0       0 NA NA #> 38        13        42     2       0       0      -1       0      -1 NA NA #> 39        14        39     2       0       1       0      -1       0 NA NA #> 40        15        48     2       0       0       0       0       0 NA NA #> 41        16        47     2       0       0       0       0       0 NA NA #> 42        17        34     2       0      -1      -1       0       0 NA NA #> 43        18        40     2       0      -1       0       1       0 NA NA #> 44        19        50     2       0       0       0       0       0 NA NA #> 45        20        43     2       0       0       1       0      -1 NA NA #> 46        21        29     2       1       0       0       1       0 NA NA #> 47        22        26     2      -1       0       0      -1       0 NA NA #> 48        23        44     2       0       0      -1       0       1 NA NA #> 49        24        45     2       0       0       1       0       1 NA NA #> 50        25        37     2       0       1       1       0       0 NA NA #>  #> Data are stored in coded form using these coding formulas ... #> A ~ A.as.is #> B ~ B.as.is #> C ~ C.as.is #> D ~ D.as.is #> E ~ E.as.is"},{"path":"https://github.com/rvlenth/rsm/reference/ccd.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate central-composite designs and associated building blocks — ccd","title":"Generate central-composite designs and associated building blocks — ccd","text":"functions generate central-composite designs, building blocks thereof. allow flexible choices replications, aliasing predictors fractional blocks, choices axis ‘star’ points.","code":""},{"path":"https://github.com/rvlenth/rsm/reference/ccd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate central-composite designs and associated building blocks — ccd","text":"","code":"cube(basis, generators, n0 = 4, reps = 1, coding, randomize = TRUE,      blockgen, bid = 1, inscribed = FALSE) star(basis, n0 = 4, alpha = \"orthogonal\", reps = 1, randomize = TRUE) dupe(design, randomize = TRUE, coding) foldover(basis, variables, bid, randomize = TRUE) ccd(basis, generators, blocks = \"Block\", n0 = 4, alpha = \"orthogonal\",      wbreps = 1, bbreps = 1, randomize = TRUE, inscribed = FALSE,      coding, oneblock = FALSE)"},{"path":"https://github.com/rvlenth/rsm/reference/ccd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate central-composite designs and associated building blocks — ccd","text":"basis cube ccd, formula, integer giving number variables.  formula left-hand side, variables named appended design initialized NA.  star, dupe, foldover, basis coded.data object use reference. generators Optional formula list formulas generate aliased variables n0 Integer giving number center points. ccd, can vector        two numbers numbers center points cube blocks star blocks,    respectively. reps Integer number replications cube star. (create replicate blocks; use djoin .) coding List coding formulas design variables (basis generators).  dupe, coding may used change coding formulas, e.g. situation want use design center elsewhere. randomize Logical value determining whether randomize design.  ccd, block randomized separately. blockgen formula, string, list thereof. element evaluated, distinct combinations define fractional blocks design. Unlike ccd, cube returns one blocks. bid (block ID.) integer index (1 number blocks) fractional block return. indexes defined standard ordering block generators; e.g. blockgen length 2, bid values (1, 2, 3, 4) correspond generated levels (--, +-, -+, ++) respectively. inscribed Logical value; FALSE, cube points +/- 1 variable.  TRUE, entire desgn scaled axis points +/- 1 cube points interior positions.  cube , inscribed may given numeric value: use value alpha anticipated axis points added; use inscribed = TRUE scale anticipation alpha = \"spherical\". alpha numeric, position ‘star’ points.  May also character string matches partially matches one : \"orthogonal\" star points positioned block design orthogonally \"rotatable\" star points chosen make design rotatable \"spherical\" star points distance corners design cube (alpha square root number design factors) \"faces\" star points face-centered (alpha = 1) user may specify vector value alpha desired vary different axes. values rotated cyclically needed. design coded.data object duplicated. blocks string formula.  character string, name blocking factor; formula, left-hand side used name blocking factor. formula(s) right-hand side used generate separate fractional blocks. variables Character vector names variables fold . wbreps Number(s) within-block replications.  vector length 2, separate numbers used ‘cube’ ‘star’ blocks respectively. bbreps Number(s) -block replications (.e., number repeats block).  vector length 2, separate numbers used ‘cube’ ‘star’ blocks respectively. oneblock Logical. TRUE, blocking factor removed whole design randomized single block. Note default number center points may larger anticipated combined.","code":""},{"path":"https://github.com/rvlenth/rsm/reference/ccd.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate central-composite designs and associated building blocks — ccd","text":"Central-composite designs (CCDs) popular designs use response-surface exploration.  blocked designs consisting least one ‘cube’ block (two-level factorial fractional factorial, plus center points), least one ‘star’ block (points along axis positions -alpha +alpha), plus center points.  Everything put coded scale, cube portion design values -1 1 variable, center points 0. ccd function creates entire CCD design; however, practice, often start just cube portion build . Therefore, functions cube, star, dupe, foldover provided, one may use djoin combine . cube ccd, basis argument determines basic design used create cube blocks.   example, cube(basis = ~ + B + C) generate basic design 8 factorial points plus center points.  Use generators want additional variables fractional design; example, generators = c(D ~ -*B, E ~ B*C) added generate 5-factor design defining relation = -ABD = BCE = -ACDE.  convenience, basis may integer instead formula, case default variable names x1, x2, ... used; example, cube(3, ~ -x1*x2*x3) generates 1/2 fraction design added center points. want cube points divided fractional blocks, give formula(s) blockgen argument cube, blocks argument ccd.  instance, suppose call cube(basis = +B+C+D+E, generators = F~-*C*D). design 32 runs; adding argument blockgen = c(\"*B*C\",\"C*D*E\") create fractional block 32/4 = 8 runs. (cube flexible; used formula instead, either blockgen = ~ c(*B*C, C*D*E)  blockgen = c(~*B*C, ~C*D*E).) Center points added block specified.  call ccd basis generators, adding  blocks = Day ~ c(*B*C, C*D*E) thing, 4 blocks included, factor named Day distinguishes blocks. functions star, dupe, foldover provide creating new design blocks based existing design.  also provide delayed evaluation: basis argument missing, functions simply return call, djoin fill-basis = design1 evaluate . dupe simply makes copy design, re-randomizes . Therefore also convenient way re-randomize design. coding provided, coding formulas replaced well -- example, re-center design. Use star generate star (axis) points, consist center points plus points +/- alpha coordinate axis.  may specify alpha want, character argument specify certain criterion met.  example, using delayed evaluation, ccd1 = djoin(cube1, star(alpha=\"sph\")) return CCD cube1 cube block, axis points distance corners cube. Conditions criteria alpha described detail references Myers et al. (2009). star, determinations orthogonality rotatability based computed design moments basis, rather assumptions structure design augmented. Thus, may possible augment unusual design obtain rotatable design. Also, orthogonal star block requested, value alpha may vary axis axis required satisfy condition. foldover reverses levels one  design variables (.e., coded). default, reverses . However, bid argument supplied, instead returns bidth fractional block cube generated. , foldover(des, bid=3) equivalent cube(<arguments created des>, bid=3) -- much efficiently folding appropriate factors. cases constraints region operability, may want specify inscribed = TRUE.  scale-design coded value exceeds 1. using building-block approach starting first-order design cube, call cube  inscribed set anticipated value alpha, use inscribed = TRUE, use alpha = \"spherical\" subsequent call star. ccd generates entire CCD. practice, building-block approach cube, star, etc. usually preferable, ccd exists convenience backward compatibility pre-2.00 versions rsm. Many arguments cube; however, n0, wbreps, bbreps may single values vectors; vectors, first element cube portions second element star portions. ccd, specifying wbreps equivalent specifying reps call cube star. bbreps refers replicate blocks experiment, bbreps = c(2,3) specifies join two cube blocks three blocks star points. coding specified new design, default identity codings created, e.g. x1 ~ x1...","code":""},{"path":"https://github.com/rvlenth/rsm/reference/ccd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate central-composite designs and associated building blocks — ccd","text":"coded.data object generated design, additional variables run.order std.order. multi-block design, generated blocking variable factor; variables numeric. designs sorted blocks run.order within blocks; (unlike pre-1.41 versions rsm) row.names integers corresponding ordering. user may sort block std.order within block display designs pre-randomized order.","code":""},{"path":"https://github.com/rvlenth/rsm/reference/ccd.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Generate central-composite designs and associated building blocks — ccd","text":"Lenth RV (2009) ``Response-Surface Methods R, Using rsm'',    Journal Statistical Software, 32(7), 1--17.    doi:10.18637/jss.v032.i07 Myers, RH, Montgomery, DC, Anderson-Cook, CM (2009)  Response Surface Methodology (3rd ed.), Wiley.","code":""},{"path":"https://github.com/rvlenth/rsm/reference/ccd.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Generate central-composite designs and associated building blocks — ccd","text":"Russell V. Lenth","code":""},{"path":"https://github.com/rvlenth/rsm/reference/ccd.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Generate central-composite designs and associated building blocks — ccd","text":"Poor choices generators /blocks can alias partially alias effects needed estimate second-order response surface.  good idea run varfcn collecting data examine prediction capabilities design ensure desired model can fitted. function ccd.pick available help determine good choices arguments cube, star, ccd. alternative CCD want go straight second-order modeling Box-Behnken design, generated bbd.  designs various flexible CCDs, can require fewer runs. non-exported function rsm:::.ccd.1.41 provided case needed packages compatibility old versions rsm (version 1.41 earlier). Given seed, also reproduce randomization previously generated design old version.","code":""},{"path":[]},{"path":"https://github.com/rvlenth/rsm/reference/ccd.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate central-composite designs and associated building blocks — ccd","text":"","code":"library(rsm)  ### Generate a standard 3-variable first-order design with 8 corner points and 4 center points ( FOdes <- cube (3, n0 = 4, coding = list (                 x1 ~ (Temp - 150)/10, x2 ~ (Pres - 50)/5, x3 ~ Feedrate - 4)) ) #>    run.order std.order Temp Pres Feedrate #> 1          1        11  150   50        4 #> 2          2         5  140   45        5 #> 3          3         1  140   45        3 #> 4          4        10  150   50        4 #> 5          5        12  150   50        4 #> 6          6         9  150   50        4 #> 7          7         6  160   45        5 #> 8          8         7  140   55        5 #> 9          9         8  160   55        5 #> 10        10         3  140   55        3 #> 11        11         2  160   45        3 #> 12        12         4  160   55        3 #>  #> Data are stored in coded form using these coding formulas ... #> x1 ~ (Temp - 150)/10 #> x2 ~ (Pres - 50)/5 #> x3 ~ Feedrate - 4                                      ### Add an orthodonal star block with 12 runs to create a second-order CCD ( SOdes <- djoin(FOdes, star(n0=6)) ) #>    run.order std.order Temp Pres Feedrate Block #> 1          1        11  150   50        4     1 #> 2          2         5  140   45        5     1 #> 3          3         1  140   45        3     1 #> 4          4        10  150   50        4     1 #> 5          5        12  150   50        4     1 #> 6          6         9  150   50        4     1 #> 7          7         6  160   45        5     1 #> 8          8         7  140   55        5     1 #> 9          9         8  160   55        5     1 #> 10        10         3  140   55        3     1 #> 11        11         2  160   45        3     1 #> 12        12         4  160   55        3     1 #> 13         1         6  150   50        6     2 #> 14         2         5  150   50        2     2 #> 15         3         3  150   40        4     2 #> 16         4         7  150   50        4     2 #> 17         5        11  150   50        4     2 #> 18         6         1  130   50        4     2 #> 19         7         8  150   50        4     2 #> 20         8        10  150   50        4     2 #> 21         9         4  150   60        4     2 #> 22        10         9  150   50        4     2 #> 23        11        12  150   50        4     2 #> 24        12         2  170   50        4     2 #>  #> Data are stored in coded form using these coding formulas ... #> x1 ~ (Temp - 150)/10 #> x2 ~ (Pres - 50)/5 #> x3 ~ Feedrate - 4  ### Same as above, except make the whole CCD at once; and make it rotatable ### and inscribed so that no coded value exceeds 1 SOdes2 <- ccd (3, n0 = c(4,6), alpha = \"rotatable\", inscribed = TRUE, coding = list (                 x1 ~ (Temp - 150)/10, x2 ~ (Pres - 50)/5, x3 ~ Feedrate - 4))  ### Make two replicate blocks of FOdes (2nd one randomized differently) djoin(FOdes, dupe(FOdes)) #>    run.order std.order Temp Pres Feedrate Block #> 1          1        11  150   50        4     1 #> 2          2         5  140   45        5     1 #> 3          3         1  140   45        3     1 #> 4          4        10  150   50        4     1 #> 5          5        12  150   50        4     1 #> 6          6         9  150   50        4     1 #> 7          7         6  160   45        5     1 #> 8          8         7  140   55        5     1 #> 9          9         8  160   55        5     1 #> 10        10         3  140   55        3     1 #> 11        11         2  160   45        3     1 #> 12        12         4  160   55        3     1 #> 13         1         9  150   50        4     2 #> 14         2        11  150   50        4     2 #> 15         3         7  140   55        5     2 #> 16         4         1  140   45        3     2 #> 17         5         3  140   55        3     2 #> 18         6         2  160   45        3     2 #> 19         7         5  140   45        5     2 #> 20         8         6  160   45        5     2 #> 21         9         8  160   55        5     2 #> 22        10        10  150   50        4     2 #> 23        11         4  160   55        3     2 #> 24        12        12  150   50        4     2 #>  #> Data are stored in coded form using these coding formulas ... #> x1 ~ (Temp - 150)/10 #> x2 ~ (Pres - 50)/5 #> x3 ~ Feedrate - 4  ### Fractional blocking illustration (with no center points) # Basic design (bid = 1 ---> block generators b1 = -1, b2 = -1) block1 <- cube (~ x1 + x2 + x3 + x4,  generators = x5 ~ x1 * x2 * x3 * x4,                 n0 = 0, blockgen = ~ c(x1 * x2, x1 * x3), bid = 1) block1                 #>   run.order std.order x1.as.is x2.as.is x3.as.is x4.as.is x5.as.is #> 1         1         2       -1        1        1       -1        1 #> 2         2         1        1       -1       -1       -1       -1 #> 3         3         4       -1        1        1        1       -1 #> 4         4         3        1       -1       -1        1        1 #>  #> Data are stored in coded form using these coding formulas ... #> x1 ~ x1.as.is #> x2 ~ x2.as.is #> x3 ~ x3.as.is #> x4 ~ x4.as.is #> x5 ~ x5.as.is  # The foldover (on all variables) of block1, in the same order foldover(block1, randomize=FALSE) #>   run.order std.order x1.as.is x2.as.is x3.as.is x4.as.is x5.as.is #> 1         1         2        1       -1       -1        1       -1 #> 2         2         1       -1        1        1        1        1 #> 3         3         4        1       -1       -1       -1        1 #> 4         4         3       -1        1        1       -1       -1 #>  #> Data are stored in coded form using these coding formulas ... #> x1 ~ x1.as.is #> x2 ~ x2.as.is #> x3 ~ x3.as.is #> x4 ~ x4.as.is #> x5 ~ x5.as.is  # The 4th fractional block: ( block4 <- foldover(block1, bid = 4) ) #>   run.order std.order x1.as.is x2.as.is x3.as.is x4.as.is x5.as.is #> 1         1         2        1        1        1       -1       -1 #> 2         2         3       -1       -1       -1        1       -1 #> 3         3         4        1        1        1        1        1 #> 4         4         1       -1       -1       -1       -1        1 #>  #> Data are stored in coded form using these coding formulas ... #> x1 ~ x1.as.is #> x2 ~ x2.as.is #> x3 ~ x3.as.is #> x4 ~ x4.as.is #> x5 ~ x5.as.is"},{"path":"https://github.com/rvlenth/rsm/reference/ccd.pick.html","id":null,"dir":"Reference","previous_headings":"","what":"Find a good central-composite design — ccd.pick","title":"Find a good central-composite design — ccd.pick","text":"function looks combinations specified design parameters central-composite designs, calculates quantities alpha values rotatability orthogonal blocking, imposes  specified restrictions, outputs best combinations specified order. serves aid identifying good designs.  design can  generated using ccd, pieces using cube, star, etc.","code":""},{"path":"https://github.com/rvlenth/rsm/reference/ccd.pick.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find a good central-composite design — ccd.pick","text":"","code":"ccd.pick(k, n.c = 2^k, n0.c = 1:10, blks.c = 1, n0.s = 1:10, bbr.c = 1,           wbr.s = 1, bbr.s = 1, best = 10, sortby = c(\"agreement\", \"N\"),           restrict)"},{"path":"https://github.com/rvlenth/rsm/reference/ccd.pick.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find a good central-composite design — ccd.pick","text":"k Number factors design n.c Number(s) factorial points cube block n0.c Numbers(s) center points cube block blks.c Number(s) cube blocks together comprise one rep cube portion n0.s Numbers(s) center points star (axis-point) block bbr.c Number(s) copies cube block wbr.s Number(s) replications star poit within block bbr.s Number(s) copies star block best many designs list.  Use best=NULL list sortby String(s) containing numeric expressions evaluated used sorting key(s).     Specify sortby=NULL sorting desired. restrict Optional string(s) containing Boolean expressions evaluated.  combinations   expressions TRUE retained.","code":""},{"path":"https://github.com/rvlenth/rsm/reference/ccd.pick.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Find a good central-composite design — ccd.pick","text":"grid created combinations n.c, n0.c, ..., bbr.s.   row grid, several additional variables    computed: n.s total number axis points star block N total number observations design alpha.rot position axis points make design rotatable.     Rotatability achieved design moment [iiii] = 3[iijj] j unequal. alpha.orth position axis points make blocks mutually orthogonal.     achieved design moments [ii] within block proprtional     number observations within block. agreement absolute value log ratio      alpha.rot alpha.orth.  measures agreement      two alphas. restrict provided, cases expressions TRUE kept.     (Regardless restrict, rows eliminated    insufficient degrees freedom estimate needed effects    second-order model.)   rows    sorted according expressions sortby; default sort   agreement N, suitable finding designs   rotatable orthogonally blocked.","code":""},{"path":"https://github.com/rvlenth/rsm/reference/ccd.pick.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find a good central-composite design — ccd.pick","text":"data.frame containing best fewer rows, variables  n.c, n0.c, blks.c, n.s, n0.s, bbr.c,  wbr.s, bbr.s,  N, alpha.rot, alpha.orth,   described .","code":""},{"path":"https://github.com/rvlenth/rsm/reference/ccd.pick.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Find a good central-composite design — ccd.pick","text":"Lenth RV (2009) ``Response-Surface Methods R, Using rsm'',    Journal Statistical Software, 32(7), 1--17.    doi:10.18637/jss.v032.i07 Myers, RH, Montgomery, DC, Anderson-Cook, CM (2009) Response Surface Methodology (3rd ed.), Wiley.","code":""},{"path":"https://github.com/rvlenth/rsm/reference/ccd.pick.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Find a good central-composite design — ccd.pick","text":"Russell V. Lenth","code":""},{"path":[]},{"path":"https://github.com/rvlenth/rsm/reference/ccd.pick.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Find a good central-composite design — ccd.pick","text":"","code":"library(rsm)  ### List CCDs in 3 factors with between 10 and 14 runs per block ccd.pick(3, n0.c=2:6, n0.s=2:8) #>    n.c n0.c blks.c n.s n0.s bbr.c wbr.s bbr.s  N alpha.rot alpha.orth #> 1    8    6      1   6    4     1     1     1 24  1.681793   1.690309 #> 2    8    5      1   6    3     1     1     1 22  1.681793   1.664101 #> 3    8    3      1   6    2     1     1     1 19  1.681793   1.705606 #> 4    8    4      1   6    2     1     1     1 20  1.681793   1.632993 #> 5    8    4      1   6    3     1     1     1 21  1.681793   1.732051 #> 6    8    5      1   6    4     1     1     1 23  1.681793   1.754116 #> 7    8    6      1   6    3     1     1     1 23  1.681793   1.603567 #> 8    8    6      1   6    5     1     1     1 25  1.681793   1.772811 #> 9    8    2      1   6    2     1     1     1 18  1.681793   1.788854 #> 10   8    5      1   6    2     1     1     1 21  1.681793   1.568929 # (Generate the design that is listed first:)  # ccd(3, n0=c(6,4))  ### Find designs in 5 factors containing 1, 2, or 4 cube blocks ### of 8 or 16 runs, 1 or 2 reps of each axis point, ### and no more than 70 runs altogether ccd.pick(5, n.c=c(8,16), blks.c=c(1,2,4), wbr.s=1:2, restrict=\"N<=70\") #>    n.c n0.c blks.c n.s n0.s bbr.c wbr.s bbr.s  N alpha.rot alpha.orth #> 1   16    6      1  10    1     1     1     1 33  2.000000   2.000000 #> 2   16    8      1  10    2     1     1     1 36  2.000000   2.000000 #> 3   16   10      1  10    3     1     1     1 39  2.000000   2.000000 #> 4   16    5      2  20    1     1     2     1 63  2.000000   2.000000 #> 5   16    6      2  20    2     1     2     1 66  2.000000   2.000000 #> 6    8    3      4  20    2     1     2     1 66  2.000000   2.000000 #> 7   16    7      2  20    3     1     2     1 69  2.000000   2.000000 #> 8   16    8      2  10    7     1     1     1 65  2.378414   2.380476 #> 9    8    4      4  10    7     1     1     1 65  2.378414   2.380476 #> 10  16    1      2  10    2     1     1     1 46  2.378414   2.376354"},{"path":"https://github.com/rvlenth/rsm/reference/codata.html","id":null,"dir":"Reference","previous_headings":"","what":"Automobile emissions data — codata","title":"Automobile emissions data — codata","text":" replicated 3^2 experiment reported Box, Hunter, Hunter (2005), Table 10.17.","code":""},{"path":"https://github.com/rvlenth/rsm/reference/codata.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Automobile emissions data — codata","text":"","code":"codata"},{"path":"https://github.com/rvlenth/rsm/reference/codata.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Automobile emissions data — codata","text":"data frame 18 observations following 3 variables. x1 numeric vector, coded design variable ethanol concentration x2 numeric vector, coded design variable air--fuel ratio y numeric vector, response (CO concentration, micrograms per cubic meter)","code":""},{"path":"https://github.com/rvlenth/rsm/reference/codata.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Automobile emissions data — codata","text":"example, fitted second-order response surface, example rising ridge. dataset duscussed one chapter later source text; Figure 11.17 BH^2 suggests coding formulas used example .","code":""},{"path":"https://github.com/rvlenth/rsm/reference/codata.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Automobile emissions data — codata","text":"Box, GEP, Hunter, JS, Hunter, WG (2005) Statistics Experimenters (2nd ed), Wiley.","code":""},{"path":"https://github.com/rvlenth/rsm/reference/codata.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Automobile emissions data — codata","text":"","code":"# Create a coded dataset based on info in BH^2 Fig 11.17 CO <- as.coded.data(codata,  x1 ~ (Ethanol - 0.2)/0.1,  x2 ~ A.F.ratio - 15) names(CO)[3] <- \"CO.conc\""},{"path":"https://github.com/rvlenth/rsm/reference/coded.data.html","id":null,"dir":"Reference","previous_headings":"","what":"Functions for coded data — coded.data","title":"Functions for coded data — coded.data","text":"functions facilitate use coded data response-surface analysis.","code":""},{"path":"https://github.com/rvlenth/rsm/reference/coded.data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Functions for coded data — coded.data","text":"","code":"coded.data(data, ..., formulas = list(...), block = \"block\") as.coded.data(data, ..., formulas = list(...), block = \"block\") decode.data(data) recode.data(data, ..., formulas = list(...))  val2code(X, codings) code2val(X, codings)  # S3 method for coded.data print(x, ..., decode = TRUE)  ### --- Methods for managing coded data --- is.coded.data(x)  # S3 method for coded.data [(x, ...)  codings(object) # S3 method for coded.data codings(object) codings(object) <- value  # S3 method for coded.data names(x) <- value  ## Generic method for true variable names (i.e. decoded names) truenames(x) # S3 method for coded.data truenames(x) ## Generic replacement method for truenames truenames(x) <- value # S3 method for coded.data truenames(x) <- value"},{"path":"https://github.com/rvlenth/rsm/reference/coded.data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Functions for coded data — coded.data","text":"data data.frame formulas List coding formulas; see details block Name(s) blocking variable(s). pmatched (case insensitively) names data identify blocking factorss X vector, matrix, data.frame coded decoded. codings list formulas; see Details decode Logical. TRUE, decoded values displayed; FALSE, codings displayed. object coded.data object x coded.data object value Replacement value <- methods ... coded.data, .coded.data, recode.data, ... allows specifying formulas arguments rather list. functions, ... passed parent methods.","code":""},{"path":"https://github.com/rvlenth/rsm/reference/coded.data.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Functions for coded data — coded.data","text":"Typically, coding formulas form x ~ (var - center) / halfwd    x var variable names, center    halfwd numbers.     left-hand side gives name coded variable, right-hand side    linear expression uncoded variable (linearity explicitly    checked, nonlinear expressions decode correctly.) coded.data called without formulas, automatic codings created (along warning message). Automatic codings based transforming non-block variables five fewer unique values interval [-1,1]. formulas provided .coded.data, default coding formulas like cube created numeric variables mean zero -- warning message. S3 print method provided coded.data class;    displays data.frame either coded    decoded form, along coding formulas. users may prefer print.data.frame    .data.frame lieu print decode=FALSE; produce    output without displaying coding formulas. Use coded.data convert data.frame variables   original scales.  variables named formulas    coded replaced coded versions (also renamed). contrast, .coded.data modify data; assumes variables   already coded, coding information simply added. addition, data    already coded.data object pre-1.41 version rsm,    converted    compatible new capabilities djoin (formulas argument    needed case). blocking factors specified blocks    argument. decode.data converts dataset class coded.data    returns data.frame containing original variables. recode.data used convert coded.data object new codings.    Important: changes coded values match new coding formulas. want keep coded values , change levels represent, use codings(object) <- \\dots dupe. code2val converts coded values original scale using codings provided,    returns object class X.     val2code converts direction.  using functions,    essential names (column names case matrices) match    corresponding coded uncoded variables. codings generic function accessing codings.    returns list coding formulas coded.data object.  One may use    expression like codings(object) <- list(\\dots) change codings (without changing    coded values ).   See also codings.rsm. .coded.data(x) returns TRUE x inherits coded.data, FALSE otherwise. extraction function x[...] naming functions names<-,    truenames, truenames<- provided preserve integrity    codings. example, x[, 1:3] excludes coded columns, coding formulas    also excluded. coded columns excluded, return value unclassed    coded.data. variable names changed using names(x) <- ..., coding    formulas updated accordingly. truenames function returns names    variables decoded dataset. can change decoded names using    truenames(x) <- ..., coding formulas updated. Note truenames   truenames<- work names names<-    unencoded variables object. Another convenient way copy change coding formulas coded dataset (optionally re-randomize ) use dupe function coding argument. design created another package, variables may factors, case converted using .numeric (values 1, 2, ...). levels may regarded yet different coding variables, may take two steps get desired form: one convert supplied levels desired range (often -1 1), replace coding formulas correspond real values variables used. See examples.","code":""},{"path":"https://github.com/rvlenth/rsm/reference/coded.data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Functions for coded data — coded.data","text":"coded.data, .coded.data, recode.data return object class  coded.data,  inherits data.frame. coded.data object stored coded form, names attribute contains coded names,    apply. Thus, fitting models rsm lm    coded data data argument, model formula given terms    coded variables.","code":""},{"path":"https://github.com/rvlenth/rsm/reference/coded.data.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Functions for coded data — coded.data","text":"Starting rsm version 2.00, coded.data class involves additional attributes serve broader needs design-generation. , old coded.data objects may need updated using .coded.data used newer functions djoin.","code":""},{"path":[]},{"path":"https://github.com/rvlenth/rsm/reference/coded.data.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Functions for coded data — coded.data","text":"Lenth RV (2009). ``Response-Surface Methods R, Using rsm'',    Journal Statistical Software, 32(7), 1--17.    doi:10.18637/jss.v032.i07","code":""},{"path":"https://github.com/rvlenth/rsm/reference/coded.data.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Functions for coded data — coded.data","text":"Russell V. Lenth","code":""},{"path":"https://github.com/rvlenth/rsm/reference/coded.data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Functions for coded data — coded.data","text":"","code":"library(rsm)  ### Existing dataset with variables on actual scale CR <- coded.data (ChemReact, x1 ~ (Time - 85)/5, x2 ~ (Temp - 175)/5) CR                            # same as print(CR, decode = TRUE) #>     Time   Temp Block Yield #> 1  80.00 170.00    B1  80.5 #> 2  80.00 180.00    B1  81.5 #> 3  90.00 170.00    B1  82.0 #> 4  90.00 180.00    B1  83.5 #> 5  85.00 175.00    B1  83.9 #> 6  85.00 175.00    B1  84.3 #> 7  85.00 175.00    B1  84.0 #> 8  85.00 175.00    B2  79.7 #> 9  85.00 175.00    B2  79.8 #> 10 85.00 175.00    B2  79.5 #> 11 92.07 175.00    B2  78.4 #> 12 77.93 175.00    B2  75.6 #> 13 85.00 182.07    B2  78.5 #> 14 85.00 167.93    B2  77.0 #>  #> Data are stored in coded form using these coding formulas ... #> x1 ~ (Time - 85)/5 #> x2 ~ (Temp - 175)/5 print(CR, decode = FALSE)     # similar to as.data.frame(CR) #>        x1     x2 Block Yield #> 1  -1.000 -1.000    B1  80.5 #> 2  -1.000  1.000    B1  81.5 #> 3   1.000 -1.000    B1  82.0 #> 4   1.000  1.000    B1  83.5 #> 5   0.000  0.000    B1  83.9 #> 6   0.000  0.000    B1  84.3 #> 7   0.000  0.000    B1  84.0 #> 8   0.000  0.000    B2  79.7 #> 9   0.000  0.000    B2  79.8 #> 10  0.000  0.000    B2  79.5 #> 11  1.414  0.000    B2  78.4 #> 12 -1.414  0.000    B2  75.6 #> 13  0.000  1.414    B2  78.5 #> 14  0.000 -1.414    B2  77.0 #>  #> Variable codings ... #> x1 ~ (Time - 85)/5 #> x2 ~ (Temp - 175)/5 code2val (c(x1=.5, x2=-1), codings = codings(CR)) #>  Time  Temp  #>  87.5 170.0   ### Existing dataset, already in coded form CO <- as.coded.data(codata, x1 ~ (Ethanol - 0.2)/0.1, x2 ~ A.F.ratio - 15) truenames(CO) #> [1] \"Ethanol\"   \"A.F.ratio\" \"y\"         names(CO) #> [1] \"x1\" \"x2\" \"y\"   # revert x2 to an uncoded variable codings(CO)[2] <- NULL truenames(CO) #> [1] \"Ethanol\" \"x2\"      \"y\"        ### Import a design that is coded in a different way  if (require(conf.design)) { # ----- This example requires conf.design -----  # First, generate a 3^3 in blocks and import it via coded.data     des3 <- coded.data(conf.design(p=3, G=c(1,1,2)))     # NOTE: This returns a warning message but does the right thing --     # It generates these names and coding formulas automatically:     #   x1 ~ (T1 - 2)/1     #   x2 ~ (T2 - 2)/1     #   x3 ~ (T3 - 2)/1 # Now randomize and change the codings and variable names for the real situation:     mydes <- dupe(des3, coding = c(x1 ~ (Dose - 20)/5,  x2 ~ (Conc - 40)/10,                                   x3 ~ (Time - 60)/15))                                  } # ----- end of example requiring package conf.design ----- #> Loading required package: conf.design #> Warning: Automatic codings created -- may not be what you want"},{"path":"https://github.com/rvlenth/rsm/reference/contour.lm.html","id":null,"dir":"Reference","previous_headings":"","what":"Surface plot(s) of a fitted linear model — contour.lm","title":"Surface plot(s) of a fitted linear model — contour.lm","text":"contour, image, persp methods display fitted surface lm object    involving two numerical predictors.","code":""},{"path":"https://github.com/rvlenth/rsm/reference/contour.lm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Surface plot(s) of a fitted linear model — contour.lm","text":"","code":"# S3 method for lm contour(x, form, at, bounds, zlim, xlabs, hook,      plot.it = TRUE, atpos = 1, decode = TRUE, image = FALSE,      img.col = terrain.colors(50), ...)  # S3 method for lm image(x, form, at, bounds, zlim, xlabs, hook,      atpos = 1, decode = TRUE, ...)  # S3 method for lm persp(x, form, at, bounds, zlim, zlab, xlabs,      col = \"white\", contours = NULL, hook, atpos = 3, decode = TRUE,      theta = -25, phi = 20, r = 4, border = NULL, box = TRUE,      ticktype = \"detailed\", ...)"},{"path":"https://github.com/rvlenth/rsm/reference/contour.lm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Surface plot(s) of a fitted linear model — contour.lm","text":"x lm object. form formula, list formulas. Optional named list fixed values use surface slices.     example, predictor variables x1, x2, x3, contour plot x2 versus x1     based fitted surface sliced x3 value specified ; contour plot x3 versus x1 sliced value x2; etc.     provided, defaults mean value numeric variable. bounds Optional named list bounds grid values use     variables names.  See details. zlim zlim setting passed parent methods contour, image, persp. zlim used plots several produced.     provided, range values across plotted surfaces used. zlab Optional label vertical axis. xlabs Alternate labels predictor axes (see Details). hook Optional list can contain functions pre.plot post.plot.       May used add annotations re-route graphs separate files (see Details). atpos Determines values displayed.  value 1 (2) displays part x (y) axis label.     value 3 displays subtitle plot.  value 0 suppresses .     nonzero value cause label generated displayed; can accessed via hook function. decode effect x rsm object model object supports coded.data. cases, decode TRUE, coordinate axes transformed decoded values. image Set TRUE want image plot overlaid contours. img.col Color map use image=TRUE. plot.TRUE, plot produced, just return value. col Color colors used facets perspective plot (see details). contours non-NULL, specifications added contour lines perspective plot. theta, phi Viewing angles passed persp (different defaults). r Viewing distance passed persp (different default). border, box Options passed persp. ticktype Option passed persp (different default). ... Additional arguments passed contour, image, persp. Note, however, ylab ignored, message Use xlabs instead.","code":""},{"path":"https://github.com/rvlenth/rsm/reference/contour.lm.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Surface plot(s) of a fitted linear model — contour.lm","text":"form may single formula list formulas.  simple formula like   x2 ~ x1 produce contour plot fitted regression surface   combinations x2 (vertical axis) x1 (horizontal axis).   list several simple formulas produce contour plot formula.   two-sided formula produces contour plots left-hand variable versus   right-hand variable (except ); example,    x1+x3 ~ x2+x3 equivalent    list(x1~x2, x3~x2, x1~x3).     one-sided formula produces contour plots pair variables.  example,   ~ x1+x2+x3 equivalent    list(x2~x1, x3~x1, x3~x2). variables bounds argument, grid 26 equally-spaced    values observed range variable used.  specify vector    length 2, interpreted desired range variable grid 26   equally-spaced points generated.  vector length 3, first two elements used   range, third number grid points.   vector length 4 ,   values used directly grid values. results based predicted values linear model specified grid. factors among predictors, predictions made levels (combinations levels) factors, averaged together. (However, user may include factors restrict behavior.) default, predictor axes labeled using variable names form,   unless x rsm object supports coded.data, case either decoded variable names variable-coding formulas used generate axis labels, depending whether decode TRUE FALSE.   axis labels replaced entries xlabs provided.  One must careful using   make sure names mapped correctly.  entries xlabs   match respective unique variable names form, sorting    (case-insensitive) alphabetical order (necessarily order appearance).  Note form changed, may also   necessary change xlabs. Please note models fitted coded data, coded values used bounds, regardless whether decode TRUE FALSE. However, elements added afterward via points, lines, etc., must specified terms whatever coordinate system present plots. persp, contour lines may added via contours argument.  may boolean character value, list.   boolean TRUE, default black contour lines added bottom surface box.  Character values \"top\", \"bottom\"   add black contour lines specified surface box.  contours = \"colors\" puts contour lines bottom using colors    height surface.  character values contours taken desired color contour lines, plotted bottom.   contours named list, elements (optional) used follows: z Height contour lines plotted.  May \"bottom\" (default), \"top\", numeric value. col Color lines.  specified, black.         May integer color values, color names, \"colors\" match surface colors. lwd Line width; default 1. Since functions often produce several plots, hook argument provided special setups annotations needed plot.    list defines one functions pre.plot post.plot.  functions one argument, character    vector labs plot (see Value documentation). Additional examples discussion plotting functions available via vignette(\"rsm-plots\").","code":""},{"path":"https://github.com/rvlenth/rsm/reference/contour.lm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Surface plot(s) of a fitted linear model — contour.lm","text":"list containing information plotted.     list item list following components: x, y values used x y axes z matrix fitted response values labs Character vector length 5: Elements 1 2 x y axis labels,      elements 3 4 original variable names,     element 5 slice label (empty atpos 0) zlim computed provided zlim values transf (persp ) 3D transformation trans3d","code":""},{"path":"https://github.com/rvlenth/rsm/reference/contour.lm.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Surface plot(s) of a fitted linear model — contour.lm","text":"Lenth RV (2009) ``Response-Surface Methods R, Using rsm'',    Journal Statistical Software, 32(7), 1--17.    doi:10.18637/jss.v032.i07","code":""},{"path":"https://github.com/rvlenth/rsm/reference/contour.lm.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Surface plot(s) of a fitted linear model — contour.lm","text":"Russell V. Lenth","code":""},{"path":[]},{"path":"https://github.com/rvlenth/rsm/reference/contour.lm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Surface plot(s) of a fitted linear model — contour.lm","text":"","code":"### Basic example with a linear model: mpg.lm <- lm(mpg ~ poly(hp, disp, degree = 3), data = mtcars) contour(mpg.lm, hp ~ disp, image = TRUE)   ### Extended example with an rsm model... heli.rsm <- rsm (ave ~ block + SO(x1, x2, x3, x4), data = heli)  # Plain contour plots par (mfrow = c(2,3)) contour (heli.rsm, ~x1+x2+x3+x4, at = xs(heli.rsm))   # Same but with image overlay, slices at origin and block 2, # and no slice labeling contour (heli.rsm, ~x1+x2+x3+x4, at = list(block=\"2\"),      atpos = 0, image = TRUE)   # Default perspective views persp (heli.rsm, ~x1+x2+x3+x4, at = xs(heli.rsm))   # Same plots, souped-up with facet coloring and axis labeling persp (heli.rsm, ~x1+x2+x3+x4, at = xs(heli.rsm),     contours = \"col\", col = rainbow(40), zlab = \"Flight time\",   xlabs = c(\"Wing area\", \"Wing length\", \"Body width\", \"Body length\"))     if (FALSE) { ### Hints for creating graphics files for use in publications...  # Save perspective plots in one PDF file (will be six pages long) pdf(file = \"heli-plots.pdf\") persp (heli.rsm, ~x1+x2+x3+x4, at = xs(heli.rsm)) dev.off()  # Save perspective plots in six separate PNG files png.hook = list(     pre.plot = function(lab)          png(file = paste(lab[3], lab[4], \".png\", sep = \"\")),     post.plot = function(lab)         dev.off()) persp (heli.rsm, ~x1+x2+x3+x4, at = xs(heli.rsm), hook = png.hook) }"},{"path":"https://github.com/rvlenth/rsm/reference/djoin.html","id":null,"dir":"Reference","previous_headings":"","what":"Join designs together into a blocked design — djoin","title":"Join designs together into a blocked design — djoin","text":"implements rsm package's building-block provisions handling sequences experiments. often want join two designs one blocked design purposes analysis.","code":""},{"path":"https://github.com/rvlenth/rsm/reference/djoin.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Join designs together into a blocked design — djoin","text":"","code":"djoin(design1, design2, ..., blkname = \"Block\", blocklev) stdorder(design)"},{"path":"https://github.com/rvlenth/rsm/reference/djoin.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Join designs together into a blocked design — djoin","text":"design1 coded.data object (must created rsm 2.00 higher). design2 data.frame (coded.data) appended;      call function create design ... Additional designs appended blkname Name give blocking variable distinguishes designs joined blocklev Label use blocking variable added design design coded.data object displayed.","code":""},{"path":"https://github.com/rvlenth/rsm/reference/djoin.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Join designs together into a blocked design — djoin","text":"djoin may used augment design manner designs, including regular designs generated cube relatives, data.frames, coded.data objects. underlying paradigm design joined separate block, order joined matter. tries smart way: first design, design1, required coded.data object. design2 data.frame, variables coded names present, automatically coded according design1's coding formulas. design2 coded.data object, coding formulas differ design1, design1 recoded design2's codings designs joined. cases, variables design2 matched design1 excluded, design1 variables absent design2 added values NA.","code":""},{"path":"https://github.com/rvlenth/rsm/reference/djoin.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Join designs together into a blocked design — djoin","text":"djoin returns coded.data object combined designs, coding formulas last coded.data object added. generated blocking variable factor. designs sorted blocks run.order within blocks; row.names integers corresponding ordering. function stdorder sorts data block std.order within block display designs pre-randomized order.","code":""},{"path":"https://github.com/rvlenth/rsm/reference/djoin.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Join designs together into a blocked design — djoin","text":"Russell V. Lenth","code":""},{"path":[]},{"path":"https://github.com/rvlenth/rsm/reference/djoin.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Join designs together into a blocked design — djoin","text":"","code":"# Some existing data CR1 <- coded.data(ChemReact1, x1 ~ (Time - 85)/5, x2 ~ (Temp - 175)/5) # add the second part of the experiment; it gets coded automagically djoin(CR1, ChemReact2) #>     Time   Temp Yield Block #> 1  80.00 170.00  80.5     1 #> 2  80.00 180.00  81.5     1 #> 3  90.00 170.00  82.0     1 #> 4  90.00 180.00  83.5     1 #> 5  85.00 175.00  83.9     1 #> 6  85.00 175.00  84.3     1 #> 7  85.00 175.00  84.0     1 #> 8  85.00 175.00  79.7     2 #> 9  85.00 175.00  79.8     2 #> 10 85.00 175.00  79.5     2 #> 11 92.07 175.00  78.4     2 #> 12 77.93 175.00  75.6     2 #> 13 85.00 182.07  78.5     2 #> 14 85.00 167.93  77.0     2 #>  #> Data are stored in coded form using these coding formulas ... #> x1 ~ (Time - 85)/5 #> x2 ~ (Temp - 175)/5  # A new experiment in a different part of the design space newdes <- cube(Yield ~ x1 + x2,  n0 = 3,      coding = c(x1 ~ (Time - 70)/10, x2 ~ (Temp - 180)/5)) # Time passes ... we do the experiment and plug-in the observed Yield values newdes$Yield <- rnorm(7, 75, 3) # these are our pretend results combined <- djoin(CR1, newdes) # Observe that the combined dataset is recoded to the new formulas print(combined, decode = FALSE) #>      x1 x2    Yield Block #> 1   1.0 -2 80.50000     1 #> 2   1.0  0 81.50000     1 #> 3   2.0 -2 82.00000     1 #> 4   2.0  0 83.50000     1 #> 5   1.5 -1 83.90000     1 #> 6   1.5 -1 84.30000     1 #> 7   1.5 -1 84.00000     1 #> 11  0.0  0 78.16627     2 #> 21  1.0 -1 72.58397     2 #> 31  0.0  0 79.78852     2 #> 41 -1.0  1 77.32797     2 #> 51 -1.0 -1 78.45627     2 #> 61  0.0  0 81.39811     2 #> 71  1.0  1 77.11079     2 #>  #> Variable codings ... #> x1 ~ (Time - 70)/10 #> x2 ~ (Temp - 180)/5  # List the new design in standard order stdorder(newdes) #>   run.order std.order Time Temp    Yield #> 5         5         1   60  175 78.45627 #> 2         2         2   80  175 72.58397 #> 4         4         3   60  185 77.32797 #> 7         7         4   80  185 77.11079 #> 3         3         5   70  180 79.78852 #> 6         6         6   70  180 81.39811 #> 1         1         7   70  180 78.16627 #>  #> Data are stored in coded form using these coding formulas ... #> x1 ~ (Time - 70)/10 #> x2 ~ (Temp - 180)/5"},{"path":"https://github.com/rvlenth/rsm/reference/heli.html","id":null,"dir":"Reference","previous_headings":"","what":"Paper Helicopter Data — heli","title":"Paper Helicopter Data — heli","text":"central composite design 4 factors 2 blocks.  data   comprise coded.data object.","code":""},{"path":"https://github.com/rvlenth/rsm/reference/heli.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Paper Helicopter Data — heli","text":"","code":"heli"},{"path":"https://github.com/rvlenth/rsm/reference/heli.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Paper Helicopter Data — heli","text":"data frame 30 observations following 7 variables.   observation reflects results 10 replicated flights    experimental conditions. block factor levels 1 2.     Block 1 consists 18 observations (full factorial plus two center points).     Block 2 consists 12 observations -- 8 axis points 4 center points. x1 numeric vector.  Coded wing area, x1 ~ (- 12.4)/.6 x2 numeric vector.  Coded length ratio, x2 ~ (R - 2.52)/.26 x3 numeric vector.  Coded body width, x3 ~ (W - 1.25)/.25 x4 numeric vector.  Coded body length, x4 ~ (L - 2)/.5 ave numeric vector.  Average flight time, csec. logSD numeric vector.  100*log(SD times).","code":""},{"path":"https://github.com/rvlenth/rsm/reference/heli.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Paper Helicopter Data — heli","text":"Table 12.5 Box, GEP, Hunter, JS, Hunter, WG (2005)   Statistics Experimenters (2nd ed.), Wiley.","code":""},{"path":"https://github.com/rvlenth/rsm/reference/model.data.html","id":null,"dir":"Reference","previous_headings":"","what":"Reconstruct data from a linear model — model.data","title":"Reconstruct data from a linear model — model.data","text":"Create data frame just variables formula    lm object.     comparable model.matrix model.frame except factors,   polynomials, transformations, etc. expanded.","code":""},{"path":"https://github.com/rvlenth/rsm/reference/model.data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Reconstruct data from a linear model — model.data","text":"","code":"model.data(lmobj, lhs = FALSE)"},{"path":"https://github.com/rvlenth/rsm/reference/model.data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Reconstruct data from a linear model — model.data","text":"lmobj object returned lm one relatives. lhs Boolean indicator whether include variable(s)    left-hand side model formula.","code":""},{"path":"https://github.com/rvlenth/rsm/reference/model.data.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Reconstruct data from a linear model — model.data","text":"easy--use substitute get_all_vars.   formula, data, subset arguments, present   lmobj's call, affect result appropriately.","code":""},{"path":"https://github.com/rvlenth/rsm/reference/model.data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Reconstruct data from a linear model — model.data","text":"data frame containing variables referenced model formula.","code":""},{"path":"https://github.com/rvlenth/rsm/reference/model.data.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Reconstruct data from a linear model — model.data","text":"Lenth RV (2009) ``Response-Surface Methods R, Using rsm'',    Journal Statistical Software, 32(7), 1--17.    doi:10.18637/jss.v032.i07","code":""},{"path":"https://github.com/rvlenth/rsm/reference/model.data.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Reconstruct data from a linear model — model.data","text":"Russell V. Lenth","code":""},{"path":[]},{"path":"https://github.com/rvlenth/rsm/reference/model.data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Reconstruct data from a linear model — model.data","text":"","code":"library(rsm) trees.lm <- lm(log(Volume) ~ poly(log(Girth),3), data = trees, subset = 1:20) model.frame(trees.lm) #>    log(Volume) poly(log(Girth), 3).1 poly(log(Girth), 3).2 #> 1     2.332144         -0.3446832763          0.4567447866 #> 2     2.332144         -0.3169363383          0.3641302873 #> 3     2.322388         -0.2989710263          0.3081915142 #> 4     2.797281         -0.1609473887         -0.0160161673 #> 5     2.933857         -0.1462024861         -0.0396070722 #> 6     2.980619         -0.1389330694         -0.0504530758 #> 7     2.747271         -0.1245940129         -0.0703279088 #> 8     2.901422         -0.1245940129         -0.0703279088 #> 9     3.117950         -0.1175219586         -0.0793878367 #> 10    2.990720         -0.1105133318         -0.0878826704 #> 11    3.186353         -0.1035670047         -0.0958267381 #> 12    3.044522         -0.0966818795         -0.1032339139 #> 13    3.063391         -0.0966818795         -0.1032339139 #> 14    3.058707         -0.0763831627         -0.1223663929 #> 15    2.949688         -0.0565983932         -0.1371263302 #> 16    3.100092         -0.0000829308         -0.1581467511 #> 17    3.520461         -0.0000829308         -0.1581467511 #> 18    3.310543          0.0237801953         -0.1576184585 #> 19    3.246491          0.0469361608         -0.1517677963 #> 20    3.214868          0.0526195070         -0.1495282372 #>    poly(log(Girth), 3).3 #> 1          -0.3406927197 #> 2          -0.1758692323 #> 3          -0.0884195074 #> 4           0.1775782804 #> 5           0.1731860686 #> 6           0.1693326943 #> 7           0.1587464400 #> 8           0.1587464400 #> 9           0.1521753308 #> 10          0.1448537501 #> 11          0.1368533675 #> 12          0.1282424881 #> 13          0.1282424881 #> 14          0.0993828259 #> 15          0.0671973637 #> 16         -0.0363417204 #> 17         -0.0363417204 #> 18         -0.0803976631 #> 19         -0.1205100002 #> 20         -0.1297411118 model.data(trees.lm) #>    Girth #> 1    8.3 #> 2    8.6 #> 3    8.8 #> 4   10.5 #> 5   10.7 #> 6   10.8 #> 7   11.0 #> 8   11.0 #> 9   11.1 #> 10  11.2 #> 11  11.3 #> 12  11.4 #> 13  11.4 #> 14  11.7 #> 15  12.0 #> 16  12.9 #> 17  12.9 #> 18  13.3 #> 19  13.7 #> 20  13.8"},{"path":"https://github.com/rvlenth/rsm/reference/rsm-package.html","id":null,"dir":"Reference","previous_headings":"","what":"Response-surface analysis — rsm-package","title":"Response-surface analysis — rsm-package","text":"rsm package provides functions useful designing analyzing experiments done sequentially hopes optimizing response surface. function ccd can generate (randomize) central-composite  design; allows user specify aliasing fractional blocking structure. function bbd generates randomizes Box-Behnken design.   function ccd.pick useful identifying good parameter choices central-composite designs. Functions cube, star, foldover, dupe, djoin also provided build-designs individual blocks. function varfcn allows experimenter examine predictive capabilities design collecting data. function rsm enhancement lm provides  additional analyses peculiar response surfaces.  requires model formula  contains call FO specify first-  second-order model.  model fitted, steepest  function may used obtain direction steepest ascent (descent).   canonical.path alternative steepest second-order  response surfaces. RSM methods, appropriate coding data important numerical stability, proper scaling results; function coded.data relatives facilitate coding requirement. Finally, functions provided may useful beyond response-surface applications.   contour.lm, persp.lm, image.lm aids visualizing response surface,  lm object surface fitted.  model.data recovers data used lm call, unlike model.frame, polynomials, factors, etc. expanded. information examples, use vignette(\"rsm\") vignette(\"rs-illus\").   Additionally, vignette(\"rsm-plots\") provides illustrations  graphics functions.","code":""},{"path":"https://github.com/rvlenth/rsm/reference/rsm-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Response-surface analysis — rsm-package","text":"Russell V. Lenth Maintainer: Russell V. Lenth <russell-lenth@uiowa.edu>","code":""},{"path":"https://github.com/rvlenth/rsm/reference/rsm-package.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Response-surface analysis — rsm-package","text":"Box, GEP, Hunter, JS, Hunter, WG (2005)  Statistics Experimenters (2nd ed.), Wiley-Interscience. Lenth RV (2009) ``Response-Surface Methods R, Using rsm'',    Journal Statistical Software, 32(7), 1--17.    doi:10.18637/jss.v032.i07 Myers, RH, Montgomery, DC, Anderson-Cook, CM (2009),  Response Surface Methodology (3rd ed.), Wiley.","code":""},{"path":"https://github.com/rvlenth/rsm/reference/rsm.html","id":null,"dir":"Reference","previous_headings":"","what":"Response-surface regression — rsm","title":"Response-surface regression — rsm","text":"Fit linear model response-surface component,   produce appropriate analyses summaries.","code":""},{"path":"https://github.com/rvlenth/rsm/reference/rsm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Response-surface regression — rsm","text":"","code":"rsm (formula, data, ...)  # S3 method for rsm summary(object, adjust = rev(p.adjust.methods), ...) # S3 method for summary.rsm print(x, ...)  # S3 method for rsm codings(object)  loftest (object)  canonical (object, threshold = 0.1*max.eigen) xs (object, ...)"},{"path":"https://github.com/rvlenth/rsm/reference/rsm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Response-surface regression — rsm","text":"formula Formula pass lm.    model must include least one FO(), (), TWI(), PQ() term   define response-surface portion model. data data argument pass lm. ... rsm, arguments passed lm,      summary.lm, canonical, appropriate.   summary, print, additional arguments    passed generic methods. object object class rsm adjust Adjustment apply P values coefficient matrix, chosen among available p.adjust methods stats package. default \"none\". threshold Threshold canonical analysis -- see \"Canonical analysis\" . x object produced summary","code":""},{"path":"https://github.com/rvlenth/rsm/reference/rsm.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Response-surface regression — rsm","text":"rsm, model formula must contain least FO term; optionally, can add   one TWI() terms /PQ() term. variables appear   TWI PQ must included FO.   convenience, specifying () including FO(), TWI(), PQ(),   safe, preferred way specifying full second-order model. variables FO comprise variables consider response-surface methods. need appear TWI PQ terms; one TWI term allowed. example, following two model formulas equivalent: first version, however, creates duplicate x2:x3 terms -- rsm can handle may warning messages subsequently used predictions plotted contour.lm. summary.rsm, ... arguments passed summary.lm, except threshold, passed canonical.","code":"resp ~ Oper + FO(x1,x2,x3,x4) + TWI(x1,x2,x3) + TWI(x2,x3,x4) + PQ(x1,x3,x4) resp ~ Oper + FO(x1,x2,x3,x4) + TWI(formula = ~x1*x2*x3 + x2*x3*x4) + PQ(x1,x3,x4)"},{"path":"https://github.com/rvlenth/rsm/reference/rsm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Response-surface regression — rsm","text":"rsm returns rsm object, lm object    additional members follows: order order model: 1 first-order, 1.5 first-order plus interactions,       2 model contains square terms. b first-order response-surface coefficients. B matrix second-order response-surface coefficients, present. labels Labels response-surface terms.  make summary much readable. coding Coding formulas, provided codings argument       data argument passed lm coded.data object.","code":""},{"path":"https://github.com/rvlenth/rsm/reference/rsm.html","id":"summary-and-print-methods","dir":"Reference","previous_headings":"","what":"Summary and print methods","title":"Response-surface regression — rsm","text":"print method rsm objects just shows call regression   coefficints. summarymethod rsm objects returns object class   summary.rsm, extension summary.lm   class additional list elements: sa Unit-length vector path steepest ascent       (first-order models ). canonical Canonical analysis (second-order models ) canonical lof ANOVA table including lack--fit test. coding Coding formulas parent rsm object.","code":""},{"path":"https://github.com/rvlenth/rsm/reference/rsm.html","id":"canonical-analysis-and-stationary-point","dir":"Reference","previous_headings":"","what":"Canonical analysis and stationary point","title":"Response-surface regression — rsm","text":"canonical returns list elements xs, stationary point, eigen, eigenanalysis matrix B second-order coefficients. eigenvalues less threshold taken zero, message displayed. happens, stationary point determined using surviving eigenvectors, stationary ridges valleys assumed exist  corresponding canonical directions. default threshold one tenth maximum eigenvalue, internally named max.eigen. Setting small threshold may move stationary point much farther origin. uncoded data used, canonical analysis stationary point meaningful results probably ignored. See vignette(\"rsm\") details. function xs returns just stationary point.","code":""},{"path":"https://github.com/rvlenth/rsm/reference/rsm.html","id":"other-functions","dir":"Reference","previous_headings":"","what":"Other functions","title":"Response-surface regression — rsm","text":"loftest returns anova object tests fitted model model    interpolates means response-surface-variable combinations. codings returns list coding formulas model fitted    coded.data, NULL otherwise.","code":""},{"path":"https://github.com/rvlenth/rsm/reference/rsm.html","id":"emmeans-support","dir":"Reference","previous_headings":"","what":"emmeans support","title":"Response-surface regression — rsm","text":"Support provided emmeans package: emmeans related functions work special provisions models fitted coded data. optional mode argument can values \"asis\" (default), \"coded\", \"decoded\". first two equivalent simply return LS means based original model formula variables therein (raw coded), without conversion. coded data used user specifies mode = \"decoded\", user must specify results terms decoded variables rather coded ones. See illustration Examples section.","code":""},{"path":"https://github.com/rvlenth/rsm/reference/rsm.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Response-surface regression — rsm","text":"Lenth RV (2009) ``Response-Surface Methods R, Using rsm'',    Journal Statistical Software, 32(7), 1--17.    doi:10.18637/jss.v032.i07","code":""},{"path":"https://github.com/rvlenth/rsm/reference/rsm.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Response-surface regression — rsm","text":"Russell V. Lenth","code":""},{"path":[]},{"path":"https://github.com/rvlenth/rsm/reference/rsm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Response-surface regression — rsm","text":"","code":"library(rsm) CR <- coded.data (ChemReact, x1~(Time-85)/5, x2~(Temp-175)/5)  ### 1st-order model, using only the first block CR.rs1 <- rsm (Yield ~ FO(x1,x2), data=CR, subset=1:7)  summary(CR.rs1) #>  #> Call: #> rsm(formula = Yield ~ FO(x1, x2), data = CR, subset = 1:7) #>  #>             Estimate Std. Error  t value  Pr(>|t|)     #> (Intercept) 82.81429    0.54719 151.3456 1.143e-08 *** #> x1           0.87500    0.72386   1.2088    0.2933     #> x2           0.62500    0.72386   0.8634    0.4366     #> --- #> Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 #>  #> Multiple R-squared:  0.3555,\tAdjusted R-squared:  0.0333  #> F-statistic: 1.103 on 2 and 4 DF,  p-value: 0.4153 #>  #> Analysis of Variance Table #>  #> Response: Yield #>             Df Sum Sq Mean Sq F value  Pr(>F) #> FO(x1, x2)   2 4.6250  2.3125  1.1033 0.41534 #> Residuals    4 8.3836  2.0959                 #> Lack of fit  2 8.2969  4.1485 95.7335 0.01034 #> Pure error   2 0.0867  0.0433                 #>  #> Direction of steepest ascent (at radius 1): #>        x1        x2  #> 0.8137335 0.5812382  #>  #> Corresponding increment in original units: #>     Time     Temp  #> 4.068667 2.906191  #>   ### 2nd-order model, using both blocks CR.rs2 <- rsm (Yield ~ Block + SO(x1,x2), data=CR)  summary(CR.rs2) #>  #> Call: #> rsm(formula = Yield ~ Block + SO(x1, x2), data = CR) #>  #>              Estimate Std. Error  t value  Pr(>|t|)     #> (Intercept) 84.095427   0.079631 1056.067 < 2.2e-16 *** #> BlockB2     -4.457530   0.087226  -51.103 2.877e-10 *** #> x1           0.932541   0.057699   16.162 8.444e-07 *** #> x2           0.577712   0.057699   10.012 2.122e-05 *** #> x1:x2        0.125000   0.081592    1.532    0.1694     #> x1^2        -1.308555   0.060064  -21.786 1.083e-07 *** #> x2^2        -0.933442   0.060064  -15.541 1.104e-06 *** #> --- #> Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 #>  #> Multiple R-squared:  0.9981,\tAdjusted R-squared:  0.9964  #> F-statistic: 607.2 on 6 and 7 DF,  p-value: 3.811e-09 #>  #> Analysis of Variance Table #>  #> Response: Yield #>             Df Sum Sq Mean Sq   F value    Pr(>F) #> Block        1 69.531  69.531 2611.0950 2.879e-10 #> FO(x1, x2)   2  9.626   4.813  180.7341 9.450e-07 #> TWI(x1, x2)  1  0.063   0.063    2.3470    0.1694 #> PQ(x1, x2)   2 17.791   8.896  334.0539 1.135e-07 #> Residuals    7  0.186   0.027                     #> Lack of fit  3  0.053   0.018    0.5307    0.6851 #> Pure error   4  0.133   0.033                     #>  #> Stationary point of response surface: #>        x1        x2  #> 0.3722954 0.3343802  #>  #> Stationary point in original units: #>      Time      Temp  #>  86.86148 176.67190  #>  #> Eigenanalysis: #> eigen() decomposition #> $values #> [1] -0.9233027 -1.3186949 #>  #> $vectors #>          [,1]       [,2] #> x1 -0.1601375 -0.9870947 #> x2 -0.9870947  0.1601375 #>  #>   ### Example of a rising-ridge situation from Montgomery et al, Table 6.2 RRex <- ccd(Response ~ A + B, n0 = c(0, 3), alpha = \"face\",              randomize = FALSE, oneblock = TRUE) RRex$Response <- c(52.3, 5.3, 46.7, 44.2, 58.5, 33.5, 32.8, 49.2, 49.3, 50.2, 51.6) RRex.rsm <- rsm(Response ~ SO(A,B), data = RRex) canonical(RRex.rsm)  # rising ridge is detected #> Near-stationary-ridge situation detected -- stationary point altered #>  Change 'threshold' if this is not what you intend #> $xs #>          A          B  #> -0.2928046  0.4526154  #>  #> $eigen #> eigen() decomposition #> $values #> [1]   0.00000 -12.70637 #>  #> $vectors #>         [,1]       [,2] #> A -0.8396245 -0.5431673 #> B -0.5431673  0.8396245 #>  #>  canonical(RRex.rsm, threshold = 0)  # xs is far outside of the experimental region #> $xs #>         A         B  #> -5.176505 -2.706733  #>  #> $eigen #> eigen() decomposition #> $values #> [1]  -0.509419 -12.706370 #>  #> $vectors #>         [,1]       [,2] #> A -0.8396245 -0.5431673 #> B -0.5431673  0.8396245 #>  #>   if (FALSE) { # Illustration of emmeans support emmeans::emmeans(CR.rs2, ~ x1 * x2, mode = \"coded\",          at = list(x1 = c(-1, 0, 1), x2 = c(-2, 2)))          # The following will yield the same results, but based on the decoded data emmeans::emmeans(CR.rs2, ~ Time * Temp, mode = \"decoded\",          at = list(Time = c(80, 85, 90), Temp = c(165, 185))) }"},{"path":"https://github.com/rvlenth/rsm/reference/steepest.html","id":null,"dir":"Reference","previous_headings":"","what":"Steepest-ascent methods for response surfaces — steepest","title":"Steepest-ascent methods for response surfaces — steepest","text":"functions provide path steepest ascent (descent)   fitted response surface produced rsm.","code":""},{"path":"https://github.com/rvlenth/rsm/reference/steepest.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Steepest-ascent methods for response surfaces — steepest","text":"","code":"steepest (object, dist = seq(0, 5, by = .5), descent = FALSE) canonical.path(object, which = ifelse(descent, length(object$b), 1),                dist = seq(-5, 5, by = 0.5), descent = FALSE, ...)"},{"path":"https://github.com/rvlenth/rsm/reference/steepest.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Steepest-ascent methods for response surfaces — steepest","text":"object rsm object analyzed. dist Vector desired distances along path steepest ascent descent.   steepest, must non-negative; canonical.path,   may want positive negative values, specify opposite directions stationary point. descent Set TRUE obtain path steepest descent,     FALSE obtain path steepest ascent.  value ignored     canonical.path specified. canonical direction (eigenvector) use. ... Optional arguments passed canonical.      Currently includes threshold.","code":""},{"path":"https://github.com/rvlenth/rsm/reference/steepest.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Steepest-ascent methods for response surfaces — steepest","text":"steepest returns linear path steepest ascent first-order models, path obtained ridge analysis (see Draper 1963) second-order models.  either case, path begins origin. canonical.path applies second-order models (least TWI term present).  determines linear path along one canonical variables, originating stationary point (origin).  need specify canonical variable use.   eigenvalues obtained canaonical analysis always decreasing order, first canonical direction path steepest ascent (slowest descent, eigenvalues negative) stationary point, last one path steepest descent (slowest ascent, eigenvalues positive).  defaults descent=FALSE descent=TRUE respectively. eigenvalues less (absolute value ) threshold taken zero. Increasing threshold may bring stationary point, hence canonical path, much closer design center, thus less extrapolation. either function, path uncoded units depends data coded.  Accordingly, important code predictor variables appropriately fitting response-surface model.  See coded.data relatives information.","code":""},{"path":"https://github.com/rvlenth/rsm/reference/steepest.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Steepest-ascent methods for response surfaces — steepest","text":"data.frame points along path steepest ascent (descent).   steepest, path originates center experiment; canonical.path,    starts stationary point.   coding information available, data frame also includes uncoded values variables. first-order response surfaces, steepest may used; path linear case.     second-order surfaces, steepest uses ridge analysis, path may curved.","code":""},{"path":"https://github.com/rvlenth/rsm/reference/steepest.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Steepest-ascent methods for response surfaces — steepest","text":"Draper, NR (1963), ``Ridge analysis response surfaces'',   Technometrics, 5, 469--479. Lenth RV (2009). ``Response-Surface Methods R, Using rsm'',    Journal Statistical Software, 32(7), 1--17.    doi:10.18637/jss.v032.i07","code":""},{"path":"https://github.com/rvlenth/rsm/reference/steepest.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Steepest-ascent methods for response surfaces — steepest","text":"Russell V. Lenth","code":""},{"path":"https://github.com/rvlenth/rsm/reference/steepest.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Steepest-ascent methods for response surfaces — steepest","text":"Take careful note fitted values along outputted path (labeled yhat).  example, stationary point maximum    (eigenvalues negative), fitted values steepest increase far stationary point, decrease proceed along now path slowest descent.","code":""},{"path":[]},{"path":"https://github.com/rvlenth/rsm/reference/steepest.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Steepest-ascent methods for response surfaces — steepest","text":"","code":"library(rsm) heli.rsm = rsm (ave ~ block + SO(x1, x2, x3, x4), data = heli)   steepest(heli.rsm) #> Path of steepest ascent from ridge analysis: #>    dist     x1    x2    x3     x4 |       A       R       W      L |    yhat #> 1   0.0  0.000 0.000 0.000  0.000 | 12.4000 2.52000 1.25000 2.0000 | 372.800 #> 2   0.5 -0.127 0.288 0.116 -0.371 | 12.3238 2.59488 1.27900 1.8145 | 377.106 #> 3   1.0 -0.351 0.538 0.312 -0.700 | 12.1894 2.65988 1.32800 1.6500 | 382.675 #> 4   1.5 -0.595 0.775 0.526 -1.009 | 12.0430 2.72150 1.38150 1.4955 | 389.783 #> 5   2.0 -0.846 1.007 0.745 -1.309 | 11.8924 2.78182 1.43625 1.3455 | 398.485 #> 6   2.5 -1.101 1.237 0.966 -1.605 | 11.7394 2.84162 1.49150 1.1975 | 408.819 #> 7   3.0 -1.356 1.465 1.189 -1.897 | 11.5864 2.90090 1.54725 1.0515 | 420.740 #> 8   3.5 -1.613 1.693 1.413 -2.188 | 11.4322 2.96018 1.60325 0.9060 | 434.322 #> 9   4.0 -1.870 1.920 1.637 -2.477 | 11.2780 3.01920 1.65925 0.7615 | 449.497 #> 10  4.5 -2.127 2.147 1.862 -2.766 | 11.1238 3.07822 1.71550 0.6170 | 466.323 #> 11  5.0 -2.385 2.373 2.086 -3.054 | 10.9690 3.13698 1.77150 0.4730 | 484.750  canonical.path(heli.rsm) #>    dist     x1     x2     x3     x4 |       A       R       W      L |    yhat #> 1  -5.0 -1.728  1.921  1.419 -2.967 | 11.3632 3.01946 1.60475 0.5165 | 453.627 #> 2  -4.5 -1.469  1.696  1.193 -2.682 | 11.5186 2.96096 1.54825 0.6590 | 438.150 #> 3  -4.0 -1.210  1.471  0.967 -2.397 | 11.6740 2.90246 1.49175 0.8015 | 424.302 #> 4  -3.5 -0.951  1.246  0.742 -2.112 | 11.8294 2.84396 1.43550 0.9440 | 412.094 #> 5  -3.0 -0.692  1.021  0.516 -1.827 | 11.9848 2.78546 1.37900 1.0865 | 401.504 #> 6  -2.5 -0.434  0.795  0.290 -1.541 | 12.1396 2.72670 1.32250 1.2295 | 392.534 #> 7  -2.0 -0.175  0.570  0.064 -1.256 | 12.2950 2.66820 1.26600 1.3720 | 385.203 #> 8  -1.5  0.084  0.345 -0.162 -0.971 | 12.4504 2.60970 1.20950 1.5145 | 379.502 #> 9  -1.0  0.343  0.120 -0.388 -0.686 | 12.6058 2.55120 1.15300 1.6570 | 375.429 #> 10 -0.5  0.602 -0.105 -0.614 -0.401 | 12.7612 2.49270 1.09650 1.7995 | 372.986 #> 11  0.0  0.861 -0.331 -0.839 -0.116 | 12.9166 2.43394 1.04025 1.9420 | 372.172 #> 12  0.5  1.120 -0.556 -1.065  0.169 | 13.0720 2.37544 0.98375 2.0845 | 372.987 #> 13  1.0  1.378 -0.781 -1.291  0.454 | 13.2268 2.31694 0.92725 2.2270 | 375.428 #> 14  1.5  1.637 -1.006 -1.517  0.739 | 13.3822 2.25844 0.87075 2.3695 | 379.499 #> 15  2.0  1.896 -1.232 -1.743  1.024 | 13.5376 2.19968 0.81425 2.5120 | 385.206 #> 16  2.5  2.155 -1.457 -1.969  1.309 | 13.6930 2.14118 0.75775 2.6545 | 392.538 #> 17  3.0  2.414 -1.682 -2.195  1.594 | 13.8484 2.08268 0.70125 2.7970 | 401.498 #> 18  3.5  2.673 -1.907 -2.421  1.879 | 14.0038 2.02418 0.64475 2.9395 | 412.088 #> 19  4.0  2.932 -2.132 -2.646  2.164 | 14.1592 1.96568 0.58850 3.0820 | 424.295 #> 20  4.5  3.190 -2.358 -2.872  2.449 | 14.3140 1.90692 0.53200 3.2245 | 438.140 #> 21  5.0  3.449 -2.583 -3.098  2.734 | 14.4694 1.84842 0.47550 3.3670 | 453.615"},{"path":"https://github.com/rvlenth/rsm/reference/varfcn.html","id":null,"dir":"Reference","previous_headings":"","what":"Display the scaled variance function for a design — varfcn","title":"Display the scaled variance function for a design — varfcn","text":"function computes scaled variance function design, based      specified model. Options include plotting separate curves several      directions center, contour plot two design factors.","code":""},{"path":"https://github.com/rvlenth/rsm/reference/varfcn.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Display the scaled variance function for a design — varfcn","text":"","code":"varfcn(design, formula, dist = seq(0, 2, by = 0.1), vectors, contour = FALSE,         plot = TRUE, main, ...)"},{"path":"https://github.com/rvlenth/rsm/reference/varfcn.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Display the scaled variance function for a design — varfcn","text":"design data.frame coded.data object formula model formula compute variance function dist Vector distances origin compute scaled variance vectors data.frame design variables. nonzero row specifies direction calculate scaled variance. contour logical variable. TRUE, contour plot produced; FALSE, curves plotted direction vectors. plot logical variable. TRUE, plot produced. main Title plot. default constructed based name design formula. ... arguments passed plot contour functions.","code":""},{"path":"https://github.com/rvlenth/rsm/reference/varfcn.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Display the scaled variance function for a design — varfcn","text":"scaled prediction variance particular design point variance predicted value, multiplied sample size N, divided error variance. (See, example, Montgomery et al., Section 8.2.1). depends design point, symmetric design, depends distance origin direction. function provides simple way examine variance function directly. (sophisticated methods available integrate-direction, example Vdgraph Vdgraph package.) vectors specified contour==FALSE, function generates default directions along one axis, diagonal corner dimension. example, four design variables, default directions (1,0,0,0), (1,1,0,0), (1,1,1,0), (1,1,1,1). graph produced shows scaled variance changes along vectors, distances provided. rotatable design, curves . countour==TRUE, ordering columns vectors matters. grid constructed distance range first two variables vectors. design points also plotted reference, different symbol sizes depending replications. two response-surface predictors, contour plot may misleading, display happens one simultaneously varies three variables.","code":""},{"path":"https://github.com/rvlenth/rsm/reference/varfcn.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Display the scaled variance function for a design — varfcn","text":"function invisibly returns data.frame containing data () plotted.","code":""},{"path":"https://github.com/rvlenth/rsm/reference/varfcn.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Display the scaled variance function for a design — varfcn","text":"Myers, RH Montgomery DC, Anderson-Cook CM (2009) Response Surface Methodology (3rd ed.), Wiley.","code":""},{"path":"https://github.com/rvlenth/rsm/reference/varfcn.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Display the scaled variance function for a design — varfcn","text":"Russell V. Lenth","code":""},{"path":[]},{"path":"https://github.com/rvlenth/rsm/reference/varfcn.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Display the scaled variance function for a design — varfcn","text":"","code":"des = ccd(~ x1 + x2 + x3, alpha = 1.5, block = Phase ~ x1*x2*x3, randomize=FALSE)   varfcn(des, ~ Phase + SO(x1, x2, x3))    varfcn(des, ~ Phase + SO(x1, x2, x3), contour=TRUE)       # 10 random directions   dirs = data.frame(x3=rnorm(10), x2=rnorm(10), x1=rnorm(10))   varfcn(des, ~ Phase + SO(x1, x2, x3), vectors = dirs)     # exclude some points to make it more interesting   lost = c(1,2,3,5,8,13,21)   varfcn(des[-lost, ], ~ Phase + SO(x1, x2, x3), contour=TRUE)       # different plot due to order of columns   varfcn(des[-lost, ], ~ Phase + SO(x1, x2, x3), vectors = dirs, contour=TRUE)"}]

<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="description" content="rsm">
<title>Response-Surface Methods in R, Using rsm • rsm</title>
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- bootstrap-toc --><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@v1.0.1/dist/bootstrap-toc.min.js" integrity="sha256-4veVQbu7//Lk5TSmc7YV48MxtMy98e26cf5MrgZYnwo=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.11/clipboard.min.js" integrity="sha512-7O5pXpc0oCRrxk8RUfDYFgn0nO1t+jLuIOQdOMRp4APB7uZ4vSjspzp5y6YDtDs4VzUSTbWzBFZ/LKJhnyFOKw==" crossorigin="anonymous" referrerpolicy="no-referrer"></script><!-- search --><script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.4.6/fuse.js" integrity="sha512-zv6Ywkjyktsohkbp9bb45V6tEMoWhzFzXis+LrMehmJZZSys19Yxf1dopHx7WzIKxr5tK2dVcYmaCk2uqdjF4A==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/autocomplete.js/0.38.0/autocomplete.jquery.min.js" integrity="sha512-GU9ayf+66Xx2TmpxqJpliWbT5PiGYxpaG8rfnBEk1LL8l1KGkRShhngwdXK1UgqhAzWpZHSiYPc09/NwDQIGyg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/mark.min.js" integrity="sha512-5CYOlHXGh6QpOFA/TeTylKLWfB3ftPsde7AnmhuitiTX4K5SqCLBeKro6sPS8ilsz1Q4NRx3v8Ko2IBiszzdww==" crossorigin="anonymous"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Response-Surface Methods in R, Using rsm">
<meta property="og:description" content="rsm">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>
    

    <nav class="navbar fixed-top navbar-light navbar-expand-lg bg-light" data-bs-theme="light"><div class="container">
    
    <a class="navbar-brand me-2" href="../index.html">rsm</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">2.10.5</small>

    
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item">
  <a class="nav-link" href="../reference/index.html">Reference</a>
</li>
<li class="active nav-item dropdown">
  <a href="#" class="nav-link dropdown-toggle" data-bs-toggle="dropdown" role="button" aria-expanded="false" aria-haspopup="true" id="dropdown-articles">Articles</a>
  <div class="dropdown-menu" aria-labelledby="dropdown-articles">
    <a class="dropdown-item" href="../articles/article-JSS.html">Response-Surface Methods in R, Using rsm</a>
    <a class="dropdown-item" href="../articles/illus.html">Response-surface illustration</a>
    <a class="dropdown-item" href="../articles/plots.html">Surface Plots in the rsm Package</a>
  </div>
</li>
      </ul>
<form class="form-inline my-2 my-lg-0" role="search">
        <input type="search" class="form-control me-sm-2" aria-label="Toggle navigation" name="search-input" data-search-index="../search.json" id="search-input" placeholder="Search for" autocomplete="off">
</form>

      <ul class="navbar-nav">
<li class="nav-item">
  <a class="nav-link" href="https://github.com/rvlenth/rsm/" aria-label="github">
    <span class="fab fa fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>

    
  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">
      <img src="" class="logo" alt=""><h1>Response-Surface Methods in R, Using rsm</h1>
                        <h4 data-toc-skip class="author">rsm package,
Version 2.10.5</h4>
            
      
      <small class="dont-index">Source: <a href="https://github.com/rvlenth/rsm/blob/HEAD/vignettes/article-JSS.rmd"><code>vignettes/article-JSS.rmd</code></a></small>
      <div class="d-none name"><code>article-JSS.rmd</code></div>
    </div>

    
    
<div class="section level3">
<h3 id="abstract">Abstract<a class="anchor" aria-label="anchor" href="#abstract"></a>
</h3>
<p>This introduction to the <strong>R</strong> package
<strong>rsm</strong> is a modified version of Lenth (2009), published in
the <em>Journal of Statistical Software</em>. The package
<strong>rsm</strong> was designed to provide <strong>R</strong> support
for standard response-surface methods. Functions are provided to
generate central-composite and Box-Behnken designs. For analysis of the
resulting data, the package provides for estimating the response
surface, testing its lack of fit, displaying an ensemble of contour
plots of the fitted surface, and doing follow-up analyses such as
steepest ascent, canonical analysis, and ridge analysis. It also
implements a coded-data structure to aid in this essential aspect of the
methodology. The functions are designed in hopes of providing an
intuitive and effective user interface. Potential exists for expanding
the package in a variety of ways.</p>
</div>
<div class="section level2">
<h2 id="introduction">Introduction<a class="anchor" aria-label="anchor" href="#introduction"></a>
</h2>
<p>Response-surface methodology comprises a body of methods for
exploring for optimum operating conditions through experimental methods.
Typically, this involves doing several experiments, using the results of
one experiment to provide direction for what to do next. This next
action could be to focus the experiment around a different set of
conditions, or to collect more data in the current experimental region
in order to fit a higher-order model or confirm what we seem to have
found.</p>
<p>Different levels or values of the operating conditions comprise the
factors in each experiment. Some may be categorical (e.g., the supplier
of raw material) and others may be quantitative (feed rates,
temperatures, and such). In practice, categorical variables must be
handled separately by comparing our best operating conditions with
respect to the quantitative variables across different combinations of
the categorical ones. The fundamental methods for quantitative variables
involve fitting first-order (linear) or second-order (quadratic)
functions of the predictors to one or more response variables, and then
examining the characteristics of the fitted surface to decide what
action is appropriate.</p>
<p>Given that, it may seem like response-surface analysis is simply a
regression problem. However, there are several intricacies in this
analysis and in how it is commonly used that are enough different from
routine regression problems that some special help is warranted. These
intricacies include the common use (and importance) of coded predictor
variables; the assessment of the fit; the different follow-up analyses
that are used depending on what type of model is fitted, as well as the
outcome of the analysis; and the importance of visualizing the response
surface. Response-surface methods also involve some unique
experimental-design issues, due to the emphasis on iterative
experimentation and the need for relatively sparse designs that can be
built-up piece-by-piece according to the evolving needs of the
experimenter.</p>
<p>The <strong>rsm</strong> package for <strong>R</strong> (R
Development Core Team 2009) provides several functions to facilitate
classical response-surface methods, as described in texts such as Box
and Draper (1987), Khuri and Cornell (1996, Chapters 1U5), Wu and Hamada
(2000, Chapter 9), Myers, Montgomery, and Anderson-Cook (2009), Box,
Hunter, and Hunter (2005, Chapters 11U12), and Ryan (2007, Chapter 10).
In its current form, <strong>rsm</strong> covers only the most standard
first-and second order designs and methods for one response variable;
but it covers those reasonably well, and it could be expanded in the
future. Multiple-response optimization is not covered in this package,
but the <strong>desirability</strong> package (Kuhn 2009) may be used in
conjunction with predictions obtained using the <strong>rsm</strong>
package. The <strong>rsm</strong> package is available from the
Comprehensive <strong>R</strong> Archive Network at <a href="http://CRAN.R-project.org/package=rsm" class="external-link uri">http://CRAN.R-project.org/package=rsm</a>.</p>
<p>Here is a general overview of <strong>rsm</strong>. First, it
provides functions and data types that provide for the coding and
decoding of factor levels, since appropriate coding is an important
element of response-surface analysis. These are discussed in the [coding
section]{#coding). Second, it provides functions for generating standard
designs (currently, central-composite and Box-Behnken), and building
blocks thereof, and examining their variance function; see the <a href="#designs">designs section</a>. Third the <a href="#fitting">fitting section</a> extends <strong>R</strong>’s
<code>lm</code> function to simplify the specification of standard
response-surface models, and provide appropriate summaries. Fourth, the
<a href="#contour">contour section</a> provides a means of visualizing a
fitted response surface (or in fact any <code>lm</code> object). Finally
the <a href="#steepest">steepest ascent section</a> provides guidance
for further experimentation, e.g., along the path of steepest ascent.
Most <strong>rsm</strong> functions take advantage of
<strong>R</strong>’s formula capabilities to provide intuitive and
transparent ways of obtaining the needed results.</p>
<p>To provide some context, there is good commercial software available
to help with designing and analyzing response-surface experiments. The
most popular include Design-Expert (StatEase, Inc. 2009), JMP (SAS
Institute, Inc. 2009), and Statgraphics (StatPoint Technologies,
Inc. 2009). These all provide for generating Box-Behnken and
central-composite designs, fitting first- and second-order response
surfaces, and visualizing them. These programs generally exceed
<strong>rsm</strong>’s capabilities (for example, more types of designs,
provisions for mixture experiments, etc.); but <strong>rsm</strong>
makes the most important methods available in <strong>R</strong>. To my
knowledge, the functionality of <strong>rsm</strong>’s
<code>ccd.pick</code> function is not provided in other software, and
<strong>rsm</strong> may exceed the capabilities of these programs in
the generality of central-composite designs that it can create.</p>
<p>The goal of this vignette is to present an overview of
<strong>rsm</strong> and how its functions may be used to design and
analyze response-surface experiments. While most important functions in
the package are illustrated, we do not provide comprehensive
documentation here; instead, the reader is referred to the manual and
online documentation provided with the package. The “Response-Surface
Illustration” vignette details a building-blockock approach to
generating designs and some other newer features in
<strong>rsm</strong>.</p>
</div>
<div class="section level2">
<h2 id="coding">Coding of data<a class="anchor" aria-label="anchor" href="#coding"></a>
</h2>
<p>An important aspect of response-surface analysis is using an
appropriate coding transformation of the data. The way the data are
coded affects the results of canonical analysis (see the sections on <a href="#fitting">fitting</a> and <a href="#steepest">steepest-ascent
analysis</a>); for example, unless the scaling factors are all equal,
the path of steepest ascent obtained by fitting a model to the raw
predictor values will differ from the path obtained in the coded units,
decoded to the original scale. Using a coding method that makes all
coded variables in the experiment vary over the same range is a way of
giving each predictor an equal share in potentially determining the
steepest-ascent path. Thus, coding is an important step in
response-surface analysis.</p>
<p>Accordingly, the <strong>rsm</strong> package provides for a
<code>coded.data</code> class of objects, an extension of
<code>data.frame</code>. The functions <code>coded.data</code>,
<code>as.coded.data</code>, <code>decode.data</code>,
<code>recode.data</code>, <code>code2val</code>, and
<code>val2code</code> create or decode such objects. If a
<code>coded.data</code> object is used in place of an ordinary
<code>data.frame</code> in the call to other <strong>rsm</strong>
functions such as <code>rsm</code> or <code>steepest</code>, then
appropriate additional output is provided that translates the results to
the original units. The <code>print</code> method for a
<code>coded.data</code> object displays the coding formulas and the data
in either coded or decoded form.</p>
<p>As an example, consider the provided dataset <code>ChemReact</code>,
which comes from Table 7.6 of Myers <em>et al.</em> (2009).</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va">`rsm`</span><span class="op">)</span></span>
<span><span class="va">ChemReact</span></span></code></pre></div>
<pre class="ro"><code><span><span class="co">##     Time   Temp Block Yield</span></span>
<span><span class="co">## 1  80.00 170.00    B1  80.5</span></span>
<span><span class="co">## 2  80.00 180.00    B1  81.5</span></span>
<span><span class="co">## 3  90.00 170.00    B1  82.0</span></span>
<span><span class="co">## 4  90.00 180.00    B1  83.5</span></span>
<span><span class="co">## 5  85.00 175.00    B1  83.9</span></span>
<span><span class="co">## 6  85.00 175.00    B1  84.3</span></span>
<span><span class="co">## 7  85.00 175.00    B1  84.0</span></span>
<span><span class="co">## 8  85.00 175.00    B2  79.7</span></span>
<span><span class="co">## 9  85.00 175.00    B2  79.8</span></span>
<span><span class="co">## 10 85.00 175.00    B2  79.5</span></span>
<span><span class="co">## 11 92.07 175.00    B2  78.4</span></span>
<span><span class="co">## 12 77.93 175.00    B2  75.6</span></span>
<span><span class="co">## 13 85.00 182.07    B2  78.5</span></span>
<span><span class="co">## 14 85.00 167.93    B2  77.0</span></span></code></pre>
<p>In this experiment, the data in block <code>B1</code> were collected
first and analyzed, after which block <code>B2</code> was added and a
new analysis was done. The provided datasets <code>ChemReact1</code> and
<code>ChemReact2</code> provide these separate blocks. The first block,
<code>ChemReact1</code>, uses factor settings of <span class="math inline">\(\text{Time}=85\pm5\)</span> and <span class="math inline">\(\text{Temp}=175\pm5\)</span>, with three center
points. Thus, the coded variables are <span class="math inline">\(x_1 =
(\text{Time}-85)/5\)</span> and <span class="math inline">\(x_1 =
(\text{Temp}-175)/5\)</span>. To create a coded dataset with the
appropriate codings, provide this information via formulas:</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">CR1</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/coded.data.html">coded.data</a></span><span class="op">(</span><span class="va">ChemReact1</span>, <span class="va">x1</span> <span class="op">~</span> <span class="op">(</span><span class="va">Time</span> <span class="op">-</span> <span class="fl">85</span><span class="op">)</span><span class="op">/</span><span class="fl">5</span>, <span class="va">x2</span> <span class="op">~</span> <span class="op">(</span><span class="va">Temp</span> <span class="op">-</span> <span class="fl">175</span><span class="op">)</span><span class="op">/</span><span class="fl">5</span><span class="op">)</span></span>
<span><span class="va">CR1</span></span></code></pre></div>
<pre class="ro"><code><span><span class="co">##   Time Temp Yield</span></span>
<span><span class="co">## 1   80  170  80.5</span></span>
<span><span class="co">## 2   80  180  81.5</span></span>
<span><span class="co">## 3   90  170  82.0</span></span>
<span><span class="co">## 4   90  180  83.5</span></span>
<span><span class="co">## 5   85  175  83.9</span></span>
<span><span class="co">## 6   85  175  84.3</span></span>
<span><span class="co">## 7   85  175  84.0</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Data are stored in coded form using these coding formulas ...</span></span>
<span><span class="co">## x1 ~ (Time - 85)/5</span></span>
<span><span class="co">## x2 ~ (Temp - 175)/5</span></span></code></pre>
<p>This listing looks much like the original data, but internally, the
data are saved in coded form, as can be seen by coercing it to a
<code>data.frame</code>:</p>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/as.data.frame.html" class="external-link">as.data.frame</a></span><span class="op">(</span><span class="va">CR1</span><span class="op">)</span></span></code></pre></div>
<pre class="ro"><code><span><span class="co">##   x1 x2 Yield</span></span>
<span><span class="co">## 1 -1 -1  80.5</span></span>
<span><span class="co">## 2 -1  1  81.5</span></span>
<span><span class="co">## 3  1 -1  82.0</span></span>
<span><span class="co">## 4  1  1  83.5</span></span>
<span><span class="co">## 5  0  0  83.9</span></span>
<span><span class="co">## 6  0  0  84.3</span></span>
<span><span class="co">## 7  0  0  84.0</span></span></code></pre>
<p>Any way of writing a linear transformation is acceptable; for
example, we could have written <code>x1 ~ 0.2 * Time - 17</code>.
Observe that <code>coded.data</code> actually transforms the predictor
values and replaces those variables with their coded versions. To create
a <code>coded.data</code> object from data that are already coded, use
<code>as.coded.data</code>.</p>
<p>The function <code>decode.data</code> decodes a
<code>coded.data</code> object. We may also easily encode or decode
matrices or data frames of arbitrary values; for example,</p>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/coded.data.html">code2val</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span>x1 <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0.25</span>, <span class="fl">0.5</span><span class="op">)</span>, x2 <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="op">-</span><span class="fl">1.5</span>, <span class="op">-</span><span class="fl">0.5</span><span class="op">)</span><span class="op">)</span>, <span class="fu"><a href="../reference/coded.data.html">codings</a></span><span class="op">(</span><span class="va">CR1</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<pre class="ro"><code><span><span class="co">##    Time  Temp</span></span>
<span><span class="co">## 1 86.25 167.5</span></span>
<span><span class="co">## 2 87.50 172.5</span></span></code></pre>
</div>
<div class="section level2">
<h2 id="designs">Generating a design<a class="anchor" aria-label="anchor" href="#designs"></a>
</h2>
<p>The functions <code>ccd</code> and <code>bbd</code> are available to
generate standard response-surface designs. For example, here we
generate a 3-factor Box-Behnken design (Box and Behnken, 1960) with two
center points:</p>
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/bbd.html">bbd</a></span><span class="op">(</span><span class="fl">3</span>, n0 <span class="op">=</span> <span class="fl">2</span>, coding <span class="op">=</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="va">x1</span> <span class="op">~</span> <span class="op">(</span><span class="va">Force</span> <span class="op">-</span> <span class="fl">20</span><span class="op">)</span><span class="op">/</span><span class="fl">3</span>, <span class="va">x2</span> <span class="op">~</span> <span class="op">(</span><span class="va">Rate</span> <span class="op">-</span> <span class="fl">50</span><span class="op">)</span><span class="op">/</span><span class="fl">10</span>, <span class="va">x3</span> <span class="op">~</span> <span class="va">Polish</span> <span class="op">-</span> <span class="fl">4</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<pre class="ro"><code><span><span class="co">##    run.order std.order Force Rate Polish</span></span>
<span><span class="co">## 1          1         8    23   50      5</span></span>
<span><span class="co">## 2          2        14    20   50      4</span></span>
<span><span class="co">## 3          3        11    20   40      5</span></span>
<span><span class="co">## 4          4         6    23   50      3</span></span>
<span><span class="co">## 5          5         4    23   60      4</span></span>
<span><span class="co">## 6          6         5    17   50      3</span></span>
<span><span class="co">## 7          7         2    23   40      4</span></span>
<span><span class="co">## 8          8        10    20   60      3</span></span>
<span><span class="co">## 9          9        12    20   60      5</span></span>
<span><span class="co">## 10        10         7    17   50      5</span></span>
<span><span class="co">## 11        11         9    20   40      3</span></span>
<span><span class="co">## 12        12         3    17   60      4</span></span>
<span><span class="co">## 13        13         1    17   40      4</span></span>
<span><span class="co">## 14        14        13    20   50      4</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Data are stored in coded form using these coding formulas ...</span></span>
<span><span class="co">## x1 ~ (Force - 20)/3</span></span>
<span><span class="co">## x2 ~ (Rate - 50)/10</span></span>
<span><span class="co">## x3 ~ Polish - 4</span></span></code></pre>
<p>By default, the variable names are <code>x1</code>, <code>x2</code>,
… and the experiment is randomized. If there are <span class="math inline">\(4\)</span> or <span class="math inline">\(5\)</span> factors, the design is blocked by
default (this is not possible for other numbers of factors), and the
blocks are randomized separately.</p>
<p>One of the most popular response-surface designs is the
central-composite design (CCD), due to Box and Wilson (1951). A simple
example is the chemical-reaction experiment presented in the preceding
section. These designs allow for sequential augmentation, so that we may
first experiment with just one block suitable for fitting a first-order
model, and then add more block(s) if a second-order fit is needed.<br>
The blocks in a CCD are of two types—one type, called a “cube” block,
contains design points from a two-level factorial or fractional
factorial design, plus center points; the other type, called a “star”
block, contains axis points plus center points.</p>
<p>In the following discussion, the term “design points” refers to the
non-center points in a block. The levels of the factors are coded, so
that the cube blocks contain design points with coordinate values all
equal to <span class="math inline">\(\pm1\)</span>, and center points at
<span class="math inline">\((0,0,\ldots,0)\)</span>. The design points
in the star blocks are at positions of <span class="math inline">\(\pm\alpha\)</span> along each coordinate axis. The
value of <span class="math inline">\(\alpha\)</span>, and choices of
replications of design points and center points, are often selected
based on considerations of rotatability (i.e., the variance of the
prediction depends only on the distance from the center) and
orthogonality of blocks (so that the coefficients of the fitted
response-surface equation are not correlated with block effects).</p>
<p>The table below displays the parameters of a CCD, along with the
names used by the function <code>ccd.pick</code> to be described
shortly. Suppose that there are <span class="math inline">\(k\)</span>
variables to be varied. For the cube blocks, we start with a given <span class="math inline">\(2^{k-p}\)</span> fractional factorial design (or
full factorial, when <span class="math inline">\(p=0\)</span>). We may
either use this design as-is to define the design points in the cube
block(s). Alternatively, we may confound one or more effects with blocks
to split this design into <code>blks.c</code> smaller cube blocks, in
which case each cube block contains <span class="math inline">\(2^{k-p}/\mathtt{blks.c}\)</span> distinct design
points. The star blocks always contain all <span class="math inline">\(2k\)</span> distinct design points—two on each
axis.</p>
<table class="table">
<colgroup>
<col width="31%">
<col width="34%">
<col width="34%">
</colgroup>
<thead><tr class="header">
<th align="left">Parameter(s)</th>
<th>Cube block(s)</th>
<th>Star block(s)</th>
</tr></thead>
<tbody>
<tr class="odd">
<td align="left">Design points</td>
<td><span class="math inline">\((\pm1,\pm1,...,\pm1)\)</span></td>
<td><span class="math inline">\((\pm\alpha,0,0,...,0),...,(0,0,...,\pm\alpha)\)</span></td>
</tr>
<tr class="even">
<td align="left">Center points</td>
<td><span class="math inline">\((0,0,\ldots,0)\)</span></td>
<td><span class="math inline">\((0,0,\ldots,0)\)</span></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td align="left"># <em>Distinct</em> design points</td>
<td>
<span class="math inline">\(2^{k-p}\)</span> (altogether)</td>
<td><span class="math inline">\(2k\)</span></td>
</tr>
<tr class="odd">
<td align="left"># Fractions of <span class="math inline">\(2^{k-p}\)</span>
</td>
<td><code>blks.c</code></td>
<td>–</td>
</tr>
<tr class="even">
<td align="left">Reps of each design point, within each block</td>
<td><code>wbr.c</code></td>
<td><code>wbr.s</code></td>
</tr>
<tr class="odd">
<td align="left"># Design pts each block</td>
<td>
<code>n.c</code> <span class="math inline">\(=
\mathtt{\frac{wbr.c}{blks.c}}\cdot2^{k-p}\)</span>
</td>
<td>
<code>n.s</code> <span class="math inline">\(=\mathtt{wbr.s}\cdot(2k)\)</span>
</td>
</tr>
<tr class="even">
<td align="left"># Center points</td>
<td><code>n0.c</code></td>
<td><code>n0.s</code></td>
</tr>
<tr class="odd">
<td align="left"># Points in each block</td>
<td><code>n.c + n0.c</code></td>
<td><code>n.s + n0.s</code></td>
</tr>
<tr class="even">
<td align="left">Reps of each block</td>
<td><code>bbr.c</code></td>
<td><code>bbr.s</code></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td align="left">Total observations (<code>N</code>)</td>
<td><code>blks.c * bbr.c * (n.c + n0.c)</code></td>
<td><code>+ bbr.s * (n.s + n0.s)</code></td>
</tr>
</tbody>
</table>
<p>Once the designs are decided, we may, if we like, replicate them
within blocks. We may also replicate the center points. The names
<code>wbr.c</code> and <code>wbr.s</code> (for “within-block reps”)
refer to the number of replicates of each design point within each cube
block or star block, respectively.<br>
Thus, each cube block has a total of <span class="math inline">\(\mathtt{n.c} =
\mathtt{wbr.c}\cdot2^{k-p}/\mathtt{blks.c}\)</span> design points, and
each star block contains <span class="math inline">\(\mathtt{wbr.s}\cdot2k\)</span> design points. We
may also replicate the center points—<code>n0.c</code> times in each
cube block, <code>n0.s</code> times within each star block.</p>
<p>Finally, we may replicate the blocks themselves; the numbers of such
between-block replications are denoted <code>bbr.c</code> and
<code>bbr.s</code> for cube blocks and star blocks, respectively. It is
important to understand that each block is separately randomized, in
effect a mini-experiment within the larger experiment. Having
between-block replications means repeating these mini-experiments. We
run an entire block before running another block.</p>
<p>The function <code>ccd.pick</code> is designed to help identify good
CCDs. It simply creates a grid of all combinations of design choices,
computes the <span class="math inline">\(\alpha\)</span> values required
for orthogonality and rotatability, sorts them by a specified criterion
(by default, a measure of the discrepancy between these two <span class="math inline">\(\alpha\)</span>s), and presents the best few.</p>
<p>For example, suppose that we want to experiment with <span class="math inline">\(k=5\)</span> factors, and we are willing to
consider CCDs with <span class="math inline">\(\mathtt{blks.c}=1\)</span>, <span class="math inline">\(2\)</span>, or <span class="math inline">\(4\)</span> cube blocks of sizes <span class="math inline">\(\mathtt{n.c}=8\)</span> or <span class="math inline">\(16\)</span> each.<br>
With this many factors, the number of different star points (<span class="math inline">\(2k=10\)</span>) is relatively small compared with
the size of some cube blocks (<span class="math inline">\(16\)</span>),
so it seems reasonable to consider either one or two replications (<span class="math inline">\(\mathtt{wbr.s}\in\{1,2\}\)</span>) of each point
within each star block.<br>
Finally, suppose that we want the total size of the experiment to be no
more than <span class="math inline">\(N=65\)</span> runs (see
<code>restrict</code> in the call below). Here are the ten best choices
based on these criteria:</p>
<div class="sourceCode" id="cb11"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/ccd.pick.html">ccd.pick</a></span><span class="op">(</span><span class="fl">5</span>, n.c <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">8</span>, <span class="fl">16</span><span class="op">)</span>, blks.c <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">2</span>, <span class="fl">4</span><span class="op">)</span>,</span>
<span>  wbr.s <span class="op">=</span> <span class="fl">1</span><span class="op">:</span><span class="fl">2</span>, restrict <span class="op">=</span> <span class="st">"N&lt;=65"</span><span class="op">)</span></span></code></pre></div>
<pre class="ro"><code><span><span class="co">##    n.c n0.c blks.c n.s n0.s bbr.c wbr.s bbr.s  N alpha.rot alpha.orth</span></span>
<span><span class="co">## 1   16    6      1  10    1     1     1     1 33  2.000000   2.000000</span></span>
<span><span class="co">## 2   16    8      1  10    2     1     1     1 36  2.000000   2.000000</span></span>
<span><span class="co">## 3   16   10      1  10    3     1     1     1 39  2.000000   2.000000</span></span>
<span><span class="co">## 4   16    5      2  20    1     1     2     1 63  2.000000   2.000000</span></span>
<span><span class="co">## 5   16    8      2  10    7     1     1     1 65  2.378414   2.380476</span></span>
<span><span class="co">## 6    8    4      4  10    7     1     1     1 65  2.378414   2.380476</span></span>
<span><span class="co">## 7   16    1      2  10    2     1     1     1 46  2.378414   2.376354</span></span>
<span><span class="co">## 8   16    5      2  10    5     1     1     1 57  2.378414   2.390457</span></span>
<span><span class="co">## 9   16    4      2  10    4     1     1     1 54  2.378414   2.366432</span></span>
<span><span class="co">## 10   8    2      4  10    4     1     1     1 54  2.378414   2.366432</span></span></code></pre>
<p>The first design listed is also the smallest; it consists of one cube
block of <span class="math inline">\(16\)</span> runs, plus <span class="math inline">\(6\)</span> center points; and one star block with
the points replicated once and one center point; thus, the total number
of runs is <span class="math inline">\(N=(16+6)+(10+1) = 33\)</span>. If
we choose <span class="math inline">\(\alpha=2\)</span>, this design is
both orthogonal and rotatable as seen by noting that
<code>alpha.rot</code> and <code>alpha.orth</code> are both equal to
<span class="math inline">\(2\)</span>. The <span class="math inline">\(16\)</span> design points in the cube block may be
generated by a <span class="math inline">\(2^{5-1}\)</span> fractional
factorial design.</p>
<p>While this is a small design, we have only one center point in the
star block, not providing a way to test lack of fit in the star portion.
The second and third designs remedy this slightly, but all these designs
are fairly lopsided in that the cube block is much larger than the star
block. The next few designs require considerably more runs. Design
number 4 is nicely balanced in that it consists of three blocks of <span class="math inline">\(21\)</span> runs each, and it is both rotatable
and orthogonal. However, we still have no lack-of-fit test in the star
blocks. Designs 5 and 6 differ only in whether they use two <span class="math inline">\(2^{5-1}\)</span> cubes or four <span class="math inline">\(2^{5-2}\)</span> cubes, but they provide several
center points for a lack-of-fit test. If we position the axis points at
<span class="math inline">\(\alpha=2.38\)</span>, the design is almost
orthogonal and almost rotatable. The remaining designs also come close
to meeting both criteria, but are also somewhat smaller, so that Designs
9 and 10 are essentially down-sized versions of Designs 5 and 6.</p>
<p>The choice of which design is best depends on the tradeoff between
economy and ability to assess the fitted surface. Design 1 is the only
one of these that is included in Table 7.6 of Myers <em>et al.</em>
(2009). It is good to be able to look at a broader range of choices.</p>
<p>Once we decide the design, the <code>ccd</code> function is used to
generate it. (Alternatively, starting with <strong>rsm</strong> version
2.0, the <code>cube</code>, <code>star</code>, <code>foldover</code>,
and <code>dupe</code> functions are available for generating and
randomizing a CCD in separate blocks, and then they may be combined
using <code>djoin</code>.) We first illustrate the generation of Design
1 above. This design requires a <span class="math inline">\(2^{5-1}\)</span> fraction for the cube block.
Typically, this is done by confounding the five-way interaction with the
mean; or equivalently, create a four-factor design, and generate the
levels of the fifth as the four-way interaction of the others. That is
the approach implemented by <code>ccd</code>. Suppose that we denote the
design factors by <span class="math inline">\(A,B,C,D,E\)</span>; let’s
opt to use <span class="math inline">\(E=-ABCD\)</span> as the
generator. The following call generates the design (results not
shown):</p>
<div class="sourceCode" id="cb13"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">des1</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/ccd.html">ccd</a></span> <span class="op">(</span><span class="va">y1</span> <span class="op">+</span> <span class="va">y2</span> <span class="op">~</span> <span class="va">A</span> <span class="op">+</span> <span class="va">B</span> <span class="op">+</span> <span class="va">C</span> <span class="op">+</span> <span class="va">D</span>,</span>
<span>  generators <span class="op">=</span> <span class="va">E</span> <span class="op">~</span> <span class="op">-</span> <span class="va">A</span> <span class="op">*</span> <span class="va">B</span> <span class="op">*</span> <span class="va">C</span> <span class="op">*</span> <span class="va">D</span>, n0 <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">6</span>, <span class="fl">1</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p>The value of <span class="math inline">\(\alpha\)</span> was not
specified, and by default it uses the <span class="math inline">\(\alpha\)</span> for orthogonality. The first
argument could have been just <code>4</code>, but then the generator
would have had to have been given in terms of the default variable names
<code>x1</code>, <code>x2</code>, …. The optional left-hand side in the
formula creates place-holders for response variable(s), to be filled-in
with data later. As in <code>bbd</code>, we could have added coding
formulas to create a <code>coded.data</code> object.</p>
<p>Next, we illustrate the generation of Design 10. This design has four
<span class="math inline">\(2^{5-2}\)</span> cube blocks with <span class="math inline">\(2\)</span> center points each, and one
unreplicated star block with <span class="math inline">\(4\)</span>
center points. The non-center points in the cube blocks comprise <span class="math inline">\(4\times8=32\)</span> runs, so we most likely want
to create them by dividing the full <span class="math inline">\(2^5\)</span> factorial into four fractional
blocks. We can for example opt to generate the blocks via the factors
<span class="math inline">\(b_1=ABC\)</span> and <span class="math inline">\(b_2=CDE\)</span>, so that the blocks are
determined by the four combinations of <span class="math inline">\(b_1\)</span> and <span class="math inline">\(b_2\)</span>. Then the block effects will be
confounded with the effects <span class="math inline">\(ABC\)</span>,
<span class="math inline">\(CDE\)</span>, and also the <span class="math inline">\(b_1b_2\)</span> interaction <span class="math inline">\(ABC^2DE=ABDE\)</span>. It is important in
response-surface work to avoid confounding second-order interactions,
and this scheme is thus acceptable. Unlike Design 1, this design
includes all <span class="math inline">\(2^5\)</span> factor
combinations, so we do not use the <code>generators</code> argument;
instead, we use <code>blocks</code> to do the fractionation:</p>
<div class="sourceCode" id="cb14"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">des10</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/ccd.html">ccd</a></span><span class="op">(</span> <span class="op">~</span> <span class="va">A</span> <span class="op">+</span> <span class="va">B</span> <span class="op">+</span> <span class="va">C</span> <span class="op">+</span> <span class="va">D</span> <span class="op">+</span> <span class="va">E</span>,</span>
<span>  blocks <span class="op">=</span> <span class="va">Blk</span> <span class="op">~</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="va">A</span> <span class="op">*</span> <span class="va">B</span> <span class="op">*</span> <span class="va">C</span>, <span class="va">C</span> <span class="op">*</span> <span class="va">D</span> <span class="op">*</span> <span class="va">E</span><span class="op">)</span>, n0 <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">2</span>, <span class="fl">4</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p>Each block is randomized separately, but the order of the blocks is
not randomized. In practice, we may opt to run the blocks in a different
sequence.<br>
With this design, just one of the cube blocks is sufficient to estimate
a first-order response surface.</p>
<p>It is also important to examine a design’s capabilities. First of
all, is it adequate to fit the needed first- or second-order model, and
how effective is it in predicting the response surface? The
<code>varfcn</code> function (a new addition starting
<strong>rsm</strong> version 2.0) is helpful in this regard. It
calculates a scaled version of the varaince of the fitted values over a
specified set of design points. By default, it computes this along paths
through <span class="math inline">\((1,0,\ldots,0),(1,1,\ldots,0),\ldots,(1,1,\ldots,1)\)</span>,
or on a grid with the first two variables. The right-hand side of the
intended model must be provided.</p>
<p>We illustrate this for Design 10:</p>
<div class="sourceCode" id="cb15"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/varfcn.html">varfcn</a></span><span class="op">(</span><span class="va">des10</span>, <span class="op">~</span> <span class="va">Blk</span> <span class="op">+</span> <span class="fu"><a href="../reference/FO.html">SO</a></span><span class="op">(</span><span class="va">A</span>,<span class="va">B</span>,<span class="va">C</span>,<span class="va">D</span>,<span class="va">E</span><span class="op">)</span>, dist <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">3</span>, by <span class="op">=</span> <span class="fl">.1</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p><img src="article-JSS_files/figure-html/unnamed-chunk-10-1.png" width="480"></p>
<div class="sourceCode" id="cb16"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/varfcn.html">varfcn</a></span><span class="op">(</span><span class="va">des10</span>, <span class="op">~</span> <span class="va">Blk</span> <span class="op">+</span> <span class="fu"><a href="../reference/FO.html">SO</a></span><span class="op">(</span><span class="va">A</span>,<span class="va">B</span>,<span class="va">C</span>,<span class="va">D</span>,<span class="va">E</span><span class="op">)</span>, dist <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">3</span>, by <span class="op">=</span> <span class="fl">.1</span><span class="op">)</span>, contour <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></code></pre></div>
<p><img src="article-JSS_files/figure-html/unnamed-chunk-10-2.png" width="480"></p>
<p>It shows that the design is nearly rotatable (it would be exactly so
if we had chosen <code>alpha = "rotatable"</code> in the call to
<code>ccd</code>). It can also be verified that any two of the cube
blocks plus the axis block is sufficient to estimate a second-order
response surface. Just one cube block plus the axis points, however, is
not sufficient.</p>
<p>It is possible to imagine a CCD that consists of a fractional
factorial divided into blocks. For such a design, both
<code>generators</code> and <code>blocks</code> would be needed. For
smaller numbers of factors, most CCDs require no fractionation of either
type, and obviously these are simple to generate.</p>
<p>Starting in version 1.40 of <strong>rsm</strong>, an
<code>inscribed</code> argument is available in <code>ccd</code>. This
scales the entire design so that it fits within a unit cube—useful for
situations when there are constraints on the region of operability.</p>
<div class="sourceCode" id="cb17"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/ccd.html">ccd</a></span><span class="op">(</span><span class="fl">2</span>, n0 <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">1</span><span class="op">)</span>, inscribed <span class="op">=</span> <span class="cn">TRUE</span>, randomize <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span></code></pre></div>
<pre class="ro"><code><span><span class="co">##    run.order std.order   x1.as.is   x2.as.is Block</span></span>
<span><span class="co">## 1          1         1 -0.7071068 -0.7071068     1</span></span>
<span><span class="co">## 2          2         2  0.7071068 -0.7071068     1</span></span>
<span><span class="co">## 3          3         3 -0.7071068  0.7071068     1</span></span>
<span><span class="co">## 4          4         4  0.7071068  0.7071068     1</span></span>
<span><span class="co">## 5          5         5  0.0000000  0.0000000     1</span></span>
<span><span class="co">## 6          1         1 -1.0000000  0.0000000     2</span></span>
<span><span class="co">## 7          2         2  1.0000000  0.0000000     2</span></span>
<span><span class="co">## 8          3         3  0.0000000 -1.0000000     2</span></span>
<span><span class="co">## 9          4         4  0.0000000  1.0000000     2</span></span>
<span><span class="co">## 10         5         5  0.0000000  0.0000000     2</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Data are stored in coded form using these coding formulas ...</span></span>
<span><span class="co">## x1 ~ x1.as.is</span></span>
<span><span class="co">## x2 ~ x2.as.is</span></span></code></pre>
<p>Note in this example that it is now the axis points that are at <span class="math inline">\(\pm1\)</span>, while the cube points are at <span class="math inline">\(\pm\sqrt{1/2}\)</span>. (Incidentally, this
example also illustrates the default codings used when no coding
formulas are specified.)</p>
<p>There are several other types of designs that are useful for response
surfaces, as mentioned in several of the books referenced in this
article. Provisions for generating those designs are an area of future
development in the <strong>rsm</strong> package.</p>
</div>
<div class="section level2">
<h2 id="fitting">Fitting a response-surface model<a class="anchor" aria-label="anchor" href="#fitting"></a>
</h2>
<p>A response surface is fitted using the <code>rsm</code> function.
This is an extension of <code>lm</code>, and works almost exactly like
it; however, the model formula for <code>rsm</code> must make use of the
special functions <code>FO</code>, <code>TWI</code>, <code>PQ</code>, or
<code>SO</code> (for “first-order,”, “two-way interaction,” “pure
quadratic,” and “second-order,” respectively), because the presence of
these specifies the response-surface portion of the model. Other terms
that don’t involve these functions may be included in the model; often,
these terms would include blocking factors and other categorical
predictors.</p>
<p>To illustrate this, let us revisit the <code>ChemReact</code> data
introduced in the <a href="#coding">coding</a> section. We have one
response variable, <code>Yield</code>, and two coded predictors
<code>x1</code> and <code>x2</code> as well as a blocking factor
<code>Block</code>. Supposing that the experiment was done in two
stages, we first act as though the data in the second block have not yet
been collected; and fit a first-order response-surface model to the data
in the first block:</p>
<div class="sourceCode" id="cb19"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">CR1.rsm</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/rsm.html">rsm</a></span><span class="op">(</span><span class="va">Yield</span> <span class="op">~</span> <span class="fu"><a href="../reference/FO.html">FO</a></span><span class="op">(</span><span class="va">x1</span>, <span class="va">x2</span><span class="op">)</span>, data <span class="op">=</span> <span class="va">CR1</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">CR1.rsm</span><span class="op">)</span></span></code></pre></div>
<pre class="ro"><code><span><span class="co">## </span></span>
<span><span class="co">## Call:</span></span>
<span><span class="co">## rsm(formula = Yield ~ FO(x1, x2), data = CR1)</span></span>
<span><span class="co">## </span></span>
<span><span class="co">##             Estimate Std. Error  t value  Pr(&gt;|t|)    </span></span>
<span><span class="co">## (Intercept) 82.81429    0.54719 151.3456 1.143e-08 ***</span></span>
<span><span class="co">## x1           0.87500    0.72386   1.2088    0.2933    </span></span>
<span><span class="co">## x2           0.62500    0.72386   0.8634    0.4366    </span></span>
<span><span class="co">## ---</span></span>
<span><span class="co">## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Multiple R-squared:  0.3555, Adjusted R-squared:  0.0333 </span></span>
<span><span class="co">## F-statistic: 1.103 on 2 and 4 DF,  p-value: 0.4153</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Analysis of Variance Table</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Response: Yield</span></span>
<span><span class="co">##             Df Sum Sq Mean Sq F value  Pr(&gt;F)</span></span>
<span><span class="co">## FO(x1, x2)   2 4.6250  2.3125  1.1033 0.41534</span></span>
<span><span class="co">## Residuals    4 8.3836  2.0959                </span></span>
<span><span class="co">## Lack of fit  2 8.2969  4.1485 95.7335 0.01034</span></span>
<span><span class="co">## Pure error   2 0.0867  0.0433                </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Direction of steepest ascent (at radius 1):</span></span>
<span><span class="co">##        x1        x2 </span></span>
<span><span class="co">## 0.8137335 0.5812382 </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Corresponding increment in original units:</span></span>
<span><span class="co">##     Time     Temp </span></span>
<span><span class="co">## 4.068667 2.906191</span></span></code></pre>
<p>What we see in the summary is the usual summary for a <code>lm</code>
object (with a subtle difference), followed by some additional
information particular to response surfaces. The subtle difference is
that the labeling of the regression coefficients is simplified (we don’t
see “FO” in there). The analysis-of-variance table shown includes a
breakdown of lack of fit and pure error, and we are also given
information about the direction of steepest ascent. Since the dataset is
a <code>coded.data</code> object, the steepest-ascent information is
also presented in original units. (While <code>rsm</code> does not
require a <code>coded.data</code> dataset, the use of one is highly
recommended.)</p>
<p>In this particular example, the steepest-ascent information is of
little use, because there is significant lack of fit for this model
(<span class="math inline">\(p \approx 0.01\)</span>). It suggests that
we should try a higher-order model. For example, we could add two-way
interactions:</p>
<div class="sourceCode" id="cb21"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">CR1.rsmi</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/update.html" class="external-link">update</a></span><span class="op">(</span><span class="va">CR1.rsm</span>, <span class="va">.</span> <span class="op">~</span> <span class="va">.</span> <span class="op">+</span> <span class="fu"><a href="../reference/FO.html">TWI</a></span><span class="op">(</span><span class="va">x1</span>, <span class="va">x2</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">CR1.rsmi</span><span class="op">)</span></span></code></pre></div>
<p>The results are not shown, but one finds there is still a small <span class="math inline">\(p\)</span> value for lack-of-fit.</p>
<p>To go further, we need more data. Thus, let us pretend that we now
collect the data in the second block. Then here are the data from the
combined blocks:</p>
<div class="sourceCode" id="cb22"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="op">(</span> <span class="va">CR2</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/djoin.html">djoin</a></span><span class="op">(</span><span class="va">CR1</span>, <span class="va">ChemReact2</span><span class="op">)</span> <span class="op">)</span></span></code></pre></div>
<pre class="ro"><code><span><span class="co">##     Time   Temp Yield Block</span></span>
<span><span class="co">## 1  80.00 170.00  80.5     1</span></span>
<span><span class="co">## 2  80.00 180.00  81.5     1</span></span>
<span><span class="co">## 3  90.00 170.00  82.0     1</span></span>
<span><span class="co">## 4  90.00 180.00  83.5     1</span></span>
<span><span class="co">## 5  85.00 175.00  83.9     1</span></span>
<span><span class="co">## 6  85.00 175.00  84.3     1</span></span>
<span><span class="co">## 7  85.00 175.00  84.0     1</span></span>
<span><span class="co">## 8  85.00 175.00  79.7     2</span></span>
<span><span class="co">## 9  85.00 175.00  79.8     2</span></span>
<span><span class="co">## 10 85.00 175.00  79.5     2</span></span>
<span><span class="co">## 11 92.07 175.00  78.4     2</span></span>
<span><span class="co">## 12 77.93 175.00  75.6     2</span></span>
<span><span class="co">## 13 85.00 182.07  78.5     2</span></span>
<span><span class="co">## 14 85.00 167.93  77.0     2</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Data are stored in coded form using these coding formulas ...</span></span>
<span><span class="co">## x1 ~ (Time - 85)/5</span></span>
<span><span class="co">## x2 ~ (Temp - 175)/5</span></span></code></pre>
<p>Notice that <code>djoin</code> figures out the fact that
<code>ChemReact2</code> is not coded but it has the appropriate uncoded
variables <code>Time</code> and <code>Temp</code>; so it codes those
variables appropriately. Also, the <code>Block</code> factor is added
automatically.</p>
<p>We are now in the position of fitting a full second-order model to
the combined data. This can be done by adding <code>PQ(x1, x2)</code> to
the above model with interaction, but the easier way is to use
<code>SO</code>, which is shorthand for a model with <code>FO</code>,
<code>TWI</code>, and <code>PQ</code> terms. Also, we now need to
account for the block effect since the data are collected in separate
experiments:</p>
<div class="sourceCode" id="cb24"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">CR2.rsm</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/rsm.html">rsm</a></span><span class="op">(</span><span class="va">Yield</span> <span class="op">~</span> <span class="va">Block</span> <span class="op">+</span> <span class="fu"><a href="../reference/FO.html">SO</a></span><span class="op">(</span><span class="va">x1</span>, <span class="va">x2</span><span class="op">)</span>, data <span class="op">=</span> <span class="va">CR2</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">CR2.rsm</span><span class="op">)</span></span></code></pre></div>
<pre class="ro"><code><span><span class="co">## </span></span>
<span><span class="co">## Call:</span></span>
<span><span class="co">## rsm(formula = Yield ~ Block + SO(x1, x2), data = CR2)</span></span>
<span><span class="co">## </span></span>
<span><span class="co">##              Estimate Std. Error  t value  Pr(&gt;|t|)    </span></span>
<span><span class="co">## (Intercept) 84.095427   0.079631 1056.067 &lt; 2.2e-16 ***</span></span>
<span><span class="co">## Block2      -4.457530   0.087226  -51.103 2.877e-10 ***</span></span>
<span><span class="co">## x1           0.932541   0.057699   16.162 8.444e-07 ***</span></span>
<span><span class="co">## x2           0.577712   0.057699   10.012 2.122e-05 ***</span></span>
<span><span class="co">## x1:x2        0.125000   0.081592    1.532    0.1694    </span></span>
<span><span class="co">## x1^2        -1.308555   0.060064  -21.786 1.083e-07 ***</span></span>
<span><span class="co">## x2^2        -0.933442   0.060064  -15.541 1.104e-06 ***</span></span>
<span><span class="co">## ---</span></span>
<span><span class="co">## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Multiple R-squared:  0.9981, Adjusted R-squared:  0.9964 </span></span>
<span><span class="co">## F-statistic: 607.2 on 6 and 7 DF,  p-value: 3.811e-09</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Analysis of Variance Table</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Response: Yield</span></span>
<span><span class="co">##             Df Sum Sq Mean Sq   F value    Pr(&gt;F)</span></span>
<span><span class="co">## Block        1 69.531  69.531 2611.0950 2.879e-10</span></span>
<span><span class="co">## FO(x1, x2)   2  9.626   4.813  180.7341 9.450e-07</span></span>
<span><span class="co">## TWI(x1, x2)  1  0.063   0.063    2.3470    0.1694</span></span>
<span><span class="co">## PQ(x1, x2)   2 17.791   8.896  334.0539 1.135e-07</span></span>
<span><span class="co">## Residuals    7  0.186   0.027                    </span></span>
<span><span class="co">## Lack of fit  3  0.053   0.018    0.5307    0.6851</span></span>
<span><span class="co">## Pure error   4  0.133   0.033                    </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Stationary point of response surface:</span></span>
<span><span class="co">##        x1        x2 </span></span>
<span><span class="co">## 0.3722954 0.3343802 </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Stationary point in original units:</span></span>
<span><span class="co">##      Time      Temp </span></span>
<span><span class="co">##  86.86148 176.67190 </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Eigenanalysis:</span></span>
<span><span class="co">## eigen() decomposition</span></span>
<span><span class="co">## $values</span></span>
<span><span class="co">## [1] -0.9233027 -1.3186949</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## $vectors</span></span>
<span><span class="co">##          [,1]       [,2]</span></span>
<span><span class="co">## x1 -0.1601375 -0.9870947</span></span>
<span><span class="co">## x2 -0.9870947  0.1601375</span></span></code></pre>
<p>The lack of fit is now non-significant (<span class="math inline">\(p
\approx 0.69\)</span>). The summary for a second-order model provides
results of a canonical analysis of the surface rather than for steepest
ascent. The analysis indicates that the stationary point of the fitted
surface is at <span class="math inline">\((0.37, 0.33)\)</span> in coded
units—well within the experimental region; and that both eigenvalues are
negative, indicating that the stationary point is a maximum. This is the
kind of situation we dream for in response-surface experimentation—clear
evidence of a nearby set of optimal conditions. We should probably
collect some confirmatory data near this estimated optimum at <span class="math inline">\(\text{Time}\approx87\)</span>, <span class="math inline">\(\text{Temp}\approx 177\)</span>, to make sure.</p>
<p>Another example that comes out a different way is a paper-helicopter
experiment (Box <em>et al.</em> 2005, Table 12.5). This is another
central-composite experiment, in four variables and two blocks. The data
are provided in the <strong>rsm</strong> dataset <code>heli</code>;
these data are already coded. The original variables are wing area
<code>A</code>, wing shape <code>R</code>, body width <code>W</code>,
and body length <code>L</code>. The goal is to make a paper helicopter
that flies for as long as possible. Each observation in the dataset
represents the results of ten replicated flights at each experimental
condition. Here we study the average flight time, variable name
<code>ave</code>, using a second-order surface.</p>
<div class="sourceCode" id="cb26"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">heli.rsm</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/rsm.html">rsm</a></span><span class="op">(</span><span class="va">ave</span> <span class="op">~</span> <span class="va">block</span> <span class="op">+</span> <span class="fu"><a href="../reference/FO.html">SO</a></span><span class="op">(</span><span class="va">x1</span>, <span class="va">x2</span>, <span class="va">x3</span>, <span class="va">x4</span><span class="op">)</span>, data <span class="op">=</span> <span class="va">heli</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">heli.rsm</span><span class="op">)</span></span></code></pre></div>
<pre class="ro"><code><span><span class="co">## </span></span>
<span><span class="co">## Call:</span></span>
<span><span class="co">## rsm(formula = ave ~ block + SO(x1, x2, x3, x4), data = heli)</span></span>
<span><span class="co">## </span></span>
<span><span class="co">##               Estimate Std. Error  t value  Pr(&gt;|t|)    </span></span>
<span><span class="co">## (Intercept) 372.800000   1.506375 247.4815 &lt; 2.2e-16 ***</span></span>
<span><span class="co">## block2       -2.950000   1.207787  -2.4425 0.0284522 *  </span></span>
<span><span class="co">## x1           -0.083333   0.636560  -0.1309 0.8977075    </span></span>
<span><span class="co">## x2            5.083333   0.636560   7.9856 1.398e-06 ***</span></span>
<span><span class="co">## x3            0.250000   0.636560   0.3927 0.7004292    </span></span>
<span><span class="co">## x4           -6.083333   0.636560  -9.5566 1.633e-07 ***</span></span>
<span><span class="co">## x1:x2        -2.875000   0.779623  -3.6877 0.0024360 ** </span></span>
<span><span class="co">## x1:x3        -3.750000   0.779623  -4.8100 0.0002773 ***</span></span>
<span><span class="co">## x1:x4         4.375000   0.779623   5.6117 6.412e-05 ***</span></span>
<span><span class="co">## x2:x3         4.625000   0.779623   5.9324 3.657e-05 ***</span></span>
<span><span class="co">## x2:x4        -1.500000   0.779623  -1.9240 0.0749257 .  </span></span>
<span><span class="co">## x3:x4        -2.125000   0.779623  -2.7257 0.0164099 *  </span></span>
<span><span class="co">## x1^2         -2.037500   0.603894  -3.3739 0.0045424 ** </span></span>
<span><span class="co">## x2^2         -1.662500   0.603894  -2.7530 0.0155541 *  </span></span>
<span><span class="co">## x3^2         -2.537500   0.603894  -4.2019 0.0008873 ***</span></span>
<span><span class="co">## x4^2         -0.162500   0.603894  -0.2691 0.7917877    </span></span>
<span><span class="co">## ---</span></span>
<span><span class="co">## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Multiple R-squared:  0.9555, Adjusted R-squared:  0.9078 </span></span>
<span><span class="co">## F-statistic: 20.04 on 15 and 14 DF,  p-value: 6.54e-07</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Analysis of Variance Table</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Response: ave</span></span>
<span><span class="co">##                     Df  Sum Sq Mean Sq F value    Pr(&gt;F)</span></span>
<span><span class="co">## block                1   16.81   16.81  1.7281  0.209786</span></span>
<span><span class="co">## FO(x1, x2, x3, x4)   4 1510.00  377.50 38.8175 1.965e-07</span></span>
<span><span class="co">## TWI(x1, x2, x3, x4)  6 1114.00  185.67 19.0917 5.355e-06</span></span>
<span><span class="co">## PQ(x1, x2, x3, x4)   4  282.54   70.64  7.2634  0.002201</span></span>
<span><span class="co">## Residuals           14  136.15    9.72                  </span></span>
<span><span class="co">## Lack of fit         10  125.40   12.54  4.6660  0.075500</span></span>
<span><span class="co">## Pure error           4   10.75    2.69                  </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Stationary point of response surface:</span></span>
<span><span class="co">##         x1         x2         x3         x4 </span></span>
<span><span class="co">##  0.8607107 -0.3307115 -0.8394866 -0.1161465 </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Stationary point in original units:</span></span>
<span><span class="co">##         A         R         W         L </span></span>
<span><span class="co">## 12.916426  2.434015  1.040128  1.941927 </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Eigenanalysis:</span></span>
<span><span class="co">## eigen() decomposition</span></span>
<span><span class="co">## $values</span></span>
<span><span class="co">## [1]  3.258222 -1.198324 -3.807935 -4.651963</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## $vectors</span></span>
<span><span class="co">##          [,1]       [,2]       [,3]        [,4]</span></span>
<span><span class="co">## x1  0.5177048 0.04099358  0.7608371 -0.38913772</span></span>
<span><span class="co">## x2 -0.4504231 0.58176202  0.5056034  0.45059647</span></span>
<span><span class="co">## x3 -0.4517232 0.37582195 -0.1219894 -0.79988915</span></span>
<span><span class="co">## x4  0.5701289 0.72015994 -0.3880860  0.07557783</span></span></code></pre>
<p>From the analysis of variance, it is clear that the second-order
(<code>TWI</code> and <code>PQ</code>) terms contribute significantly to
the model, so the canonical analysis is relevant. Again, the stationary
point is fairly near the experimental region, but the eigenvalues are of
mixed sign, indicating that it is a saddle point (neither a maximum nor
a minimum). We will do further analysis of these results in the
subsequent sections.</p>
</div>
<div class="section level2">
<h2 id="contour">Displaying a response surface<a class="anchor" aria-label="anchor" href="#contour"></a>
</h2>
<p>While the canonical analysis gives us a handle on the behavior of a
second-order response surface, an effective graph is a lot easier to
present and explain. To that end, <code>rsm</code> includes a function
for making contour plots of a fitted response surface. This function is
not restricted to <code>rsm</code> results, however; it can be used for
plotting any regression surface produced by <code>lm</code>. For more
detailed information, see the associated vignette We provide the
<code>lm</code> or <code>rsm</code> object, a formula for which
predictors to use, and various optional parameters. Consider the
paper-helicopter example in the preceding section; there are four
response-surface predictors, making six pairs of predictors. If we want
to visualize the behavior of the fitted surface around the stationary
point, we can provide that location as the <code>at</code> argument:</p>
<div class="sourceCode" id="cb28"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/par.html" class="external-link">par</a></span><span class="op">(</span>mfrow <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">2</span>, <span class="fl">3</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/contour.html" class="external-link">contour</a></span><span class="op">(</span><span class="va">heli.rsm</span>, <span class="op">~</span> <span class="va">x1</span> <span class="op">+</span> <span class="va">x2</span> <span class="op">+</span> <span class="va">x3</span> <span class="op">+</span> <span class="va">x4</span>, image <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>  at <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">heli.rsm</span><span class="op">)</span><span class="op">$</span><span class="va">canonical</span><span class="op">$</span><span class="va">xs</span><span class="op">)</span></span></code></pre></div>
<p><img src="article-JSS_files/figure-html/unnamed-chunk-17-1.png" width="768"></p>
<p>The <code>image</code> argument causes each plot to display a color
image overlaid by the contour lines. When multiple plots like this are
produced, the color levels are held consistent across all plots. Note
that the <code>at</code> condition does not set the center of the
coordinate systems (the default variable ranges are derived from the
data); it sets the values at which to hold variables other than those on
one of the coordinate axes, as shown in the subtitles.</p>
</div>
<div class="section level2">
<h2 id="steepest">Direction for further experimentation<a class="anchor" aria-label="anchor" href="#steepest"></a>
</h2>
<p>In many first-order cases, as well as second-order cases where we
find a saddle point or the stationary point is distant, the most useful
further action is to decide in which direction to explore further. In
the case of first-order models, one can follow the direction of steepest
ascent. As already seen in , the <code>summary</code> method for
<code>rsm</code> objects provides some information about this path. More
detailed information is available via the <code>steepest</code>
function; for example,</p>
<div class="sourceCode" id="cb29"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/steepest.html">steepest</a></span><span class="op">(</span><span class="va">CR1.rsm</span>, dist <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">0.5</span>, <span class="fl">1</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<pre class="ro"><code><span><span class="co">## Path of steepest ascent from ridge analysis:</span></span></code></pre>
<pre class="ro"><code><span><span class="co">##   dist    x1    x2 |   Time    Temp |   yhat</span></span>
<span><span class="co">## 1  0.0 0.000 0.000 | 85.000 175.000 | 82.814</span></span>
<span><span class="co">## 2  0.5 0.407 0.291 | 87.035 176.455 | 83.352</span></span>
<span><span class="co">## 3  1.0 0.814 0.581 | 89.070 177.905 | 83.890</span></span></code></pre>
<p>In general, we can specify any set of distances along the path. The
decoded coordinate values are displayed if the model was fitted to a
<code>coded.data</code> dataset.</p>
<p>At this point it is worth emphasizing that, although the fitted
values are also displayed, one must be careful to understand that these
are only predictions and that, as the distance increases, they are very
poor predictions and should be taken with a grain of salt. What one
should do is to conduct actual experimental runs at points along this
path, and use the observed response values, not these predictions, for
guidance on where to locate the next factorial experiment.</p>
<p>In the second-order case, the <code>steepest</code> function still
works, but it uses the ridge analysis method (Hoerl 1959; Draper 1963),
which is the analog of steepest ascent in the sense that for a specified
distance <span class="math inline">\(d\)</span>, it finds the point at
which the predicted response is a maximum among all predictor
combinations at radius <span class="math inline">\(d\)</span>. This
method makes sense when the stationary point is some distance away; but
when this point is nearby, it makes more sense to start at the saddle
point (rather than the origin) and follow the most steeply rising ridge
in <em>both</em> directions. This path is obtained using the
<code>canonical.path</code> function. In this function, distance is a
signed quantity, according to the direction along the ridge.</p>
<p>In the <code>heli</code> example, we do have a nearby stationary
point. Here are some points within a radius of <span class="math inline">\(5\)</span> along the canonical path:</p>
<div class="sourceCode" id="cb32"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/steepest.html">canonical.path</a></span><span class="op">(</span><span class="va">heli.rsm</span>, dist <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span><span class="op">-</span><span class="fl">5</span>, <span class="fl">5</span>, by <span class="op">=</span> <span class="fl">0.5</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<pre class="ro"><code><span><span class="co">##    dist     x1     x2     x3     x4 |       A       R       W      L |    yhat</span></span>
<span><span class="co">## 1  -5.0 -1.728  1.921  1.419 -2.967 | 11.3632 3.01946 1.60475 0.5165 | 453.627</span></span>
<span><span class="co">## 2  -4.5 -1.469  1.696  1.193 -2.682 | 11.5186 2.96096 1.54825 0.6590 | 438.150</span></span>
<span><span class="co">## 3  -4.0 -1.210  1.471  0.967 -2.397 | 11.6740 2.90246 1.49175 0.8015 | 424.302</span></span>
<span><span class="co">## 4  -3.5 -0.951  1.246  0.742 -2.112 | 11.8294 2.84396 1.43550 0.9440 | 412.094</span></span>
<span><span class="co">## 5  -3.0 -0.692  1.021  0.516 -1.827 | 11.9848 2.78546 1.37900 1.0865 | 401.504</span></span>
<span><span class="co">## 6  -2.5 -0.434  0.795  0.290 -1.541 | 12.1396 2.72670 1.32250 1.2295 | 392.534</span></span>
<span><span class="co">## 7  -2.0 -0.175  0.570  0.064 -1.256 | 12.2950 2.66820 1.26600 1.3720 | 385.203</span></span>
<span><span class="co">## 8  -1.5  0.084  0.345 -0.162 -0.971 | 12.4504 2.60970 1.20950 1.5145 | 379.502</span></span>
<span><span class="co">## 9  -1.0  0.343  0.120 -0.388 -0.686 | 12.6058 2.55120 1.15300 1.6570 | 375.429</span></span>
<span><span class="co">## 10 -0.5  0.602 -0.105 -0.614 -0.401 | 12.7612 2.49270 1.09650 1.7995 | 372.986</span></span>
<span><span class="co">## 11  0.0  0.861 -0.331 -0.839 -0.116 | 12.9166 2.43394 1.04025 1.9420 | 372.172</span></span>
<span><span class="co">## 12  0.5  1.120 -0.556 -1.065  0.169 | 13.0720 2.37544 0.98375 2.0845 | 372.987</span></span>
<span><span class="co">## 13  1.0  1.378 -0.781 -1.291  0.454 | 13.2268 2.31694 0.92725 2.2270 | 375.428</span></span>
<span><span class="co">## 14  1.5  1.637 -1.006 -1.517  0.739 | 13.3822 2.25844 0.87075 2.3695 | 379.499</span></span>
<span><span class="co">## 15  2.0  1.896 -1.232 -1.743  1.024 | 13.5376 2.19968 0.81425 2.5120 | 385.206</span></span>
<span><span class="co">## 16  2.5  2.155 -1.457 -1.969  1.309 | 13.6930 2.14118 0.75775 2.6545 | 392.538</span></span>
<span><span class="co">## 17  3.0  2.414 -1.682 -2.195  1.594 | 13.8484 2.08268 0.70125 2.7970 | 401.498</span></span>
<span><span class="co">## 18  3.5  2.673 -1.907 -2.421  1.879 | 14.0038 2.02418 0.64475 2.9395 | 412.088</span></span>
<span><span class="co">## 19  4.0  2.932 -2.132 -2.646  2.164 | 14.1592 1.96568 0.58850 3.0820 | 424.295</span></span>
<span><span class="co">## 20  4.5  3.190 -2.358 -2.872  2.449 | 14.3140 1.90692 0.53200 3.2245 | 438.140</span></span>
<span><span class="co">## 21  5.0  3.449 -2.583 -3.098  2.734 | 14.4694 1.84842 0.47550 3.3670 | 453.615</span></span></code></pre>
<p>Box <em>et al.</em> (2005, Table12.7 and Figure12.6) reports some
results of experimentation along this path. They found the most
promising location for the next experiment was at a distance of about
<span class="math inline">\(3.5\)</span> (<span class="math inline">\(-3.5\)</span> on their scale as their signs are
reversed from ours).</p>
</div>
<div class="section level2">
<h2 id="stationary-and-rising-ridge-situations">Stationary and rising-ridge situations<a class="anchor" aria-label="anchor" href="#stationary-and-rising-ridge-situations"></a>
</h2>
<p>Canonical analysis becomes unstable in cases where the matrix <span class="math inline">\(\mathbf{B}\)</span> of second-order coefficients
is singular or nearly so. As an example, consider the dataset
<code>codata</code> provided with <strong>rsm</strong> and used as an
example in Box <em>et al.</em> (2005). It comes in coded form, but to
relate things to the actual variables, let’s add the codings:</p>
<div class="sourceCode" id="cb34"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">CO</span> <span class="op">=</span> <span class="fu"><a href="../reference/coded.data.html">as.coded.data</a></span><span class="op">(</span><span class="va">codata</span>,  <span class="va">x1</span> <span class="op">~</span> <span class="op">(</span><span class="va">Ethanol</span> <span class="op">-</span> <span class="fl">0.2</span><span class="op">)</span><span class="op">/</span><span class="fl">0.1</span>,  <span class="va">x2</span> <span class="op">~</span> <span class="va">A.F.ratio</span> <span class="op">-</span> <span class="fl">15</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/names.html" class="external-link">names</a></span><span class="op">(</span><span class="va">CO</span><span class="op">)</span><span class="op">[</span><span class="fl">3</span><span class="op">]</span> <span class="op">=</span> <span class="st">"CO.conc"</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="va">CO</span><span class="op">)</span></span></code></pre></div>
<pre class="ro"><code><span><span class="co">##   Ethanol A.F.ratio CO.conc</span></span>
<span><span class="co">## 1     0.1        14    61.9</span></span>
<span><span class="co">## 2     0.1        14    65.6</span></span>
<span><span class="co">## 3     0.2        14    80.9</span></span>
<span><span class="co">## 4     0.2        14    78.0</span></span>
<span><span class="co">## 5     0.3        14    89.7</span></span>
<span><span class="co">## 6     0.3        14    93.8</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Data are stored in coded form using these coding formulas ...</span></span>
<span><span class="co">## x1 ~ (Ethanol - 0.2)/0.1</span></span>
<span><span class="co">## x2 ~ A.F.ratio - 15</span></span></code></pre>
<p>This is a <span class="math inline">\(3^2\)</span> design in one
block. We fit a second-order model and obtain the canonical
analysis:</p>
<div class="sourceCode" id="cb36"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">CO.rsm</span> <span class="op">=</span> <span class="fu"><a href="../reference/rsm.html">rsm</a></span><span class="op">(</span><span class="va">CO.conc</span> <span class="op">~</span> <span class="fu"><a href="../reference/FO.html">SO</a></span><span class="op">(</span><span class="va">x1</span>,<span class="va">x2</span><span class="op">)</span>, data <span class="op">=</span> <span class="va">CO</span><span class="op">)</span></span>
<span><span class="fu"><a href="../reference/rsm.html">canonical</a></span><span class="op">(</span><span class="va">CO.rsm</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## Near-stationary-ridge situation detected -- stationary point altered</span></span>
<span><span class="co">##  Change 'threshold' if this is not what you intend</span></span></code></pre>
<pre class="ro"><code><span><span class="co">## $xs</span></span>
<span><span class="co">##          x1          x2 </span></span>
<span><span class="co">## -0.06302658 -0.05997463 </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## $eigen</span></span>
<span><span class="co">## eigen() decomposition</span></span>
<span><span class="co">## $values</span></span>
<span><span class="co">## [1]  0.000000 -8.886833</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## $vectors</span></span>
<span><span class="co">##          [,1]       [,2]</span></span>
<span><span class="co">## x1  0.6893497 -0.7244288</span></span>
<span><span class="co">## x2 -0.7244288 -0.6893497</span></span></code></pre>
<p>Note that, due to an automatic thresholding provision, one of the
eigenvalues has been set to zero. This causes the stationary point to be
estimated based only on the surviving eigenvector, with the other one
assumed to be a stationary ridge. To ignore this thresholding, set the
threshold to zero:</p>
<div class="sourceCode" id="cb39"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/rsm.html">canonical</a></span><span class="op">(</span><span class="va">CO.rsm</span>, threshold <span class="op">=</span> <span class="fl">0</span><span class="op">)</span></span></code></pre></div>
<pre class="ro"><code><span><span class="co">## $xs</span></span>
<span><span class="co">##        x1        x2 </span></span>
<span><span class="co">## -14.81387  15.44149 </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## $eigen</span></span>
<span><span class="co">## eigen() decomposition</span></span>
<span><span class="co">## $values</span></span>
<span><span class="co">## [1]  0.1868328 -8.8868328</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## $vectors</span></span>
<span><span class="co">##          [,1]       [,2]</span></span>
<span><span class="co">## x1  0.6893497 -0.7244288</span></span>
<span><span class="co">## x2 -0.7244288 -0.6893497</span></span></code></pre>
<p>Now, the stationary point is at about <span class="math inline">\((-15,15)\)</span> in coded units—very distant from
the design center.</p>
<p>The following statements produce an illustrative plot of this
situation.</p>
<div class="sourceCode" id="cb41"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/contour.html" class="external-link">contour</a></span><span class="op">(</span><span class="va">CO.rsm</span>, <span class="va">x2</span> <span class="op">~</span> <span class="va">x1</span>, bounds <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>x1 <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="op">-</span><span class="fl">16</span>, <span class="fl">2</span><span class="op">)</span>, x2 <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="op">-</span><span class="fl">2</span>, <span class="fl">16</span><span class="op">)</span><span class="op">)</span>, </span>
<span>        zlim <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="op">-</span><span class="fl">100</span>, <span class="fl">100</span><span class="op">)</span>, col <span class="op">=</span> <span class="st">"gray"</span>, decode <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/lines.html" class="external-link">lines</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="op">-</span><span class="fl">1</span>,<span class="fl">1</span>,<span class="fl">1</span>,<span class="op">-</span><span class="fl">1</span>,<span class="op">-</span><span class="fl">1</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="op">-</span><span class="fl">1</span>,<span class="op">-</span><span class="fl">1</span>,<span class="fl">1</span>,<span class="fl">1</span>,<span class="op">-</span><span class="fl">1</span><span class="op">)</span>, col <span class="op">=</span> <span class="st">"green"</span><span class="op">)</span> <span class="co"># design region</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/points.html" class="external-link">points</a></span><span class="op">(</span><span class="va">x2</span> <span class="op">~</span> <span class="va">x1</span>, data <span class="op">=</span> <span class="fu"><a href="../reference/steepest.html">canonical.path</a></span><span class="op">(</span><span class="va">CO.rsm</span><span class="op">)</span>, </span>
<span>        col <span class="op">=</span> <span class="st">"blue"</span>, pch <span class="op">=</span> <span class="fl">1</span> <span class="op">+</span> <span class="fl">6</span><span class="op">*</span><span class="op">(</span><span class="va">dist</span> <span class="op">==</span> <span class="fl">0</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/points.html" class="external-link">points</a></span><span class="op">(</span><span class="va">x2</span> <span class="op">~</span> <span class="va">x1</span>, data <span class="op">=</span> <span class="fu"><a href="../reference/steepest.html">canonical.path</a></span><span class="op">(</span><span class="va">CO.rsm</span>, threshold <span class="op">=</span> <span class="fl">0</span><span class="op">)</span>, </span>
<span>        col <span class="op">=</span> <span class="st">"red"</span>, pch <span class="op">=</span> <span class="fl">1</span> <span class="op">+</span> <span class="fl">6</span><span class="op">*</span><span class="op">(</span><span class="va">dist</span> <span class="op">==</span> <span class="fl">0</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/points.html" class="external-link">points</a></span><span class="op">(</span><span class="va">x2</span> <span class="op">~</span> <span class="va">x1</span>, data<span class="op">=</span><span class="fu"><a href="../reference/steepest.html">steepest</a></span><span class="op">(</span><span class="va">CO.rsm</span><span class="op">)</span>, </span>
<span>        col <span class="op">=</span> <span class="st">"magenta"</span>, pch <span class="op">=</span> <span class="fl">1</span> <span class="op">+</span> <span class="fl">6</span><span class="op">*</span><span class="op">(</span><span class="va">dist</span> <span class="op">==</span> <span class="fl">0</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p><img src="article-JSS_files/figure-html/unnamed-chunk-23-1.png" width="432"></p>
<pre class="ro"><code><span><span class="co">## Path of steepest ascent from ridge analysis:</span></span>
<span><span class="co">## Path of steepest ascent from ridge analysis:</span></span></code></pre>
<p>It displays the fitted response surface, as well as the results from
<code>canonical.path</code> with and without the threshold (blue and red
points, respectively). The region of the design is shown as a green box.
The stationary point (different symbol) is seen to be a saddle point
near the upper-left corner when not thresholded, and near the design
center whern thresholded. Otherwise, the canonical paths are much the
same but with different origins. Both form a path along the rising ridge
that occurs in the vicinity of the design.</p>
<p>It is important to note that the stationary point obtained by the
default thresholding is not really a stationary point, but rather a
nearby point that represents a center for the most important canonical
directions. In this example, the true stationary point is very distant,
and the thresholded stationary point is the nearest place on a rising
ridge that emanates from the true stationary point. The thresholded
<code>canonical.path</code> results give us a much more usable set of
factor settings to explore than the ones without a threshold.</p>
<div class="section level3">
<h3 id="technical-details">Technical details<a class="anchor" aria-label="anchor" href="#technical-details"></a>
</h3>
<p>This subsection provides some technical backing for canonical
analysis and what we do when a threshold is active, in case you’re
interested.</p>
<p>Let <span class="math inline">\(\mathbf{b}\)</span> and <span class="math inline">\(\mathbf{B}\)</span> denote the first and
second-order coefficients of the fitted second-order surface, so that
the fitted value at a coded point <span class="math inline">\(\mathbf{x}\)</span> is <span class="math inline">\(\hat{y}(\mathbf{x}) = b_0 +
\mathbf{b}'\mathbf{x} +
\mathbf{x}'\mathbf{B}\mathbf{x}\)</span>. The stationary point <span class="math inline">\(\mathbf{x}_s\)</span> solves the equation <span class="math inline">\(2\mathbf{B}\mathbf{x}_s + \mathbf{b} =
\mathbf{0}\)</span>, i.e., <span class="math inline">\(\mathbf{x}_s =
-\frac12\mathbf{B}^{-1}\mathbf{b}\)</span>. The canonical analysis
yields the decomposition <span class="math display">\[ \mathbf{B} =
\mathbf{U}\mathbf{\Lambda}\mathbf{U}' =
\lambda_1\mathbf{u}_1\mathbf{u}_1' +
\lambda_2\mathbf{u}_2\mathbf{u}_2' + \cdots +
\lambda_k\mathbf{u}_k\mathbf{u}_k' \]</span> where there are <span class="math inline">\(k\)</span> predictors, the <span class="math inline">\(\mathbf{u}_j\)</span> form orthonormal columns of
<span class="math inline">\(\mathbf{U}\)</span>, and the <span class="math inline">\(\lambda_j\)</span> are the eigenvalues, and <span class="math inline">\(\mathbf{\Lambda} =
\mathrm{diag}(\lambda_1,\lambda_2,\ldots,\lambda_k)\)</span>. It also
happens to be true that <span class="math display">\[ \mathbf{B}^{-1} =
\mathbf{U}\mathbf{\Lambda}^{-1}\mathbf{U}'
= \textstyle\frac1{\lambda_1}\mathbf{u}_1\mathbf{u}_1' +
\frac1{\lambda_2}\mathbf{u}_2\mathbf{u}_2' + \cdots +
\frac1{\lambda_k}\mathbf{u}_k\mathbf{u}_k'  \]</span> Thus, a really
small value of <span class="math inline">\(\lambda_j\)</span> hardly
affects <span class="math inline">\(\mathbf{B}\)</span>, but has a huge
influence on <span class="math inline">\(\mathbf{B}^{-1}\)</span>.</p>
<p>Now, for some <span class="math inline">\(m&lt;k\)</span>, let <span class="math inline">\(\mathbf{\Lambda}_*\)</span> be the <span class="math inline">\(m\times m\)</span> diagonal matrix with only some
subset of <span class="math inline">\(m\)</span> eigenvalues; and let
<span class="math inline">\(\mathbf{U}_*\)</span> be the <span class="math inline">\(k \times m\)</span> matrix with the corresponding
<span class="math inline">\(\mathbf{u}_j\)</span>. If we excluded the
smallest absolute eigenvalues, then <span class="math inline">\(\mathbf{B}_* =
\mathbf{U}_*\mathbf{\Lambda}_*\mathbf{U}'_* \approx
\mathbf{B}\)</span>. Moreover, by orthogonality, <span class="math inline">\(\mathbf{U}'\mathbf{B} =
\mathbf{\Lambda}\mathbf{U}'\)</span> and <span class="math inline">\(\mathbf{U}_*'\mathbf{B} =
\mathbf{\Lambda}_*\mathbf{U}_*'\)</span>. The stationary point
satisfies <span class="math inline">\(2\mathbf{B}\mathbf{x} + \mathbf{b}
= \mathbf{0}\)</span> so that <span class="math inline">\(2\mathbf{U}_*'\mathbf{B}\mathbf{x} +
\mathbf{U}_*'\mathbf{b} = \mathbf{0}\)</span>. Accordingly, we
propose to define a pseudo-stationary point <span class="math inline">\(\mathbf{x}_*\)</span> such that <span class="math inline">\(2\mathbf{U}_*'\mathbf{B}\mathbf{x}_* +
\mathbf{U}_*'\mathbf{b} = \mathbf{0}\)</span>; i.e., <span class="math inline">\(2\mathbf{\Lambda}_*\mathbf{U}_*'\mathbf{x}_* +
\mathbf{U}_*'\mathbf{b} = \mathbf{0}\)</span>.</p>
<p>This comprises <span class="math inline">\(m\)</span> equations in
<span class="math inline">\(k&gt;m\)</span> unknowns. To make it unique,
we opt to choose the solution that is closest to the origin; that is,
minimize <span class="math inline">\(\mathbf{x}'\mathbf{x}\)</span>
subject to the constraint that <span class="math inline">\(2\mathbf{\Lambda}_*\mathbf{U}_*'\mathbf{x} +
\mathbf{U}_*'\mathbf{b} = \mathbf{0}\)</span>. Using variational
methods (Lagrange multipliers), we find that the resulting solution is
<span class="math inline">\(\mathbf{x}_*=
-\frac12\mathbf{U}_*\mathbf{\Lambda}_*^{-1}\mathbf{U}_*'\mathbf{b}\)</span>.
In other words, we simply exclude some terms corresponding to small
<span class="math inline">\(\lambda_i\)</span> in the above expression
for <span class="math inline">\(\mathbf{B}^{-1}\)</span>. This is the
stationary point returned in <strong>rsm</strong>’s
<code>canonical</code> and related functions when a threshold is used to
exclude some small eigenvalues.</p>
</div>
</div>
<div class="section level2">
<h2 id="discussion">Discussion<a class="anchor" aria-label="anchor" href="#discussion"></a>
</h2>
<p>The current version of <strong>rsm</strong> provides only the most
standard tools for first- and second-order response-surface design and
analysis. The package can be quite useful for those standard situations,
and it implements many of the analyses presented in textbooks. However,
clearly a great deal of work has been done in response-surface methods
that is not represented here. Even a quick glance at a review article
such as Myers, Montgomery, Vining, Borror, and Kowalski (2004) – or even
an older one such as Hill and Hunter (1989) – reveals that there is a
great deal that could be added to future editions of
<strong>rsm</strong>. There are many other useful designs besides
central composites and Box-Behnken designs. We can consider higher-order
models or the use of predictor transformations. Mixture designs are not
yet provided for. There are important relationships between these
methods and robust parameter design, and with computer experiments. The
list goes on. However, we now at least have a good collection of basic
tools for the <strong>R</strong> platform, and that is a starting
point.</p>
</div>
<div class="section level2">
<h2 id="references">References<a class="anchor" aria-label="anchor" href="#references"></a>
</h2>
<p>Box GEP,Behnken DW(1960). “Some New Three Level Designs for the Study
of Quantitative Variables.” <em>Technometrics</em>, <strong>2</strong>,
455–475.</p>
<p>Box GEP, Draper NR (1987). <em>Empirical Model-Building and Response
Surfaces</em>. John Wiley &amp; Sons, New York.</p>
<p>Box GEP, Hunter WG, Hunter JS (2005). <em>Statistics for
Experimenters: An Introduction to Design, Data Analysis, and Model
Building</em>. 2nd edition. John Wiley &amp; Sons, New York.</p>
<p>Box GEP, Wilson KB (1951). “On the Experimental Attainment of Optimum
Conditions.” <em>Journal of the Royal Statistical Society B</em>,
<strong>13</strong>, 1–45.</p>
<p>Draper NR (1963). “‘Ridge Analysis’ of Response Surfaces.”
<em>Technometrics</em>, <strong>5</strong>, 469–479.</p>
<p>Hill WJ, Hunter WG (1989). “A Review of Response Surface Methodology:
A Literature Review.” <em>Technometrics</em>, <strong>8</strong>,
571–590.</p>
<p>Hoerl AE (1959). “Optimum Solution of Many Variables Equations.”
<em>Chemical Engineering Progress</em>, <strong>55</strong>, 67–78.</p>
<p>Khuri AI, Cornell JA (1996). Responses Surfaces: Design and Analyses.
2nd edition. Marcel Dekker, Monticello, NY.</p>
<p>Kuhn M (2009). desirability: Desirability Function Optimization and
Ranking. R package version 1.02, URL <a href="http://CRAN.R-project.org/package=desirability" class="external-link uri">http://CRAN.R-project.org/package=desirability</a>.</p>
<p>Lenth RV (2009). “Response-Surface Methods in R, Using rsm.”
<em>Journal of Statistical Software</em>, <strong>32</strong>(7), 1–17.
URL <a href="https://www.jstatsoft.org/v32/i07/" class="external-link uri">https://www.jstatsoft.org/v32/i07/</a>.</p>
<p>Myers RH, Montgomery DC, Anderson-Cook CM (2009). <em>Response
Surface Methodology: Product and Process Optimization Using Designed
Experiments</em>. 3nd edition. John Wiley &amp; Sons, New York.</p>
<p>Myers RH, Montgomery DC, Vining GG, Borror CM, Kowalski SM (2004).
“Response Surface Methodology: A Retrospective and Literature Survey.”
<em>Journal of Quality Technology</em>, <strong>36</strong>, 53–78.</p>
<p>R Development Core Team (2009). <em>R: A Language and Environment for
Statistical Computing</em>. R Foundation for Statistical Computing,
Vienna, Austria. ISBN 3-900051-07-0, URL http: //www.R-project.org/.</p>
<p>Ryan TP (2007). <em>Modern Experimental Design</em>. John Wiley &amp;
Sons, New York.</p>
<p>SAS Institute, Inc (2009). JMP 8: Statistical Discovery Software.
Cary, NC. URL http: //www.jmp.com/.</p>
<p>Stat-Ease, Inc (2009). <em>Design-Expert 7 for Windows: Software for
Design of Experiments (DOE)</em>. Minneapolis, MN. URL <a href="http://www.statease.com/" class="external-link uri">http://www.statease.com/</a>.</p>
<p>StatPoint Technologies, Inc (2009). <em>Statgraphics Centurion: Data
Analysis and Statistical Software</em>. Warrenton, VA. URL <a href="http://www.statgraphics.com/" class="external-link uri">http://www.statgraphics.com/</a>.</p>
<p>Wu CFJ, Hamada M (2000). <em>Experiments: Planning, Analysis, and
Parameter Design Optimization</em>. John Wiley &amp; Sons, New York.</p>
</div>
  </main><aside class="col-md-3"><nav id="toc"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p>Developed by Russell Lenth.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.0.9.</p>
</div>

    </footer>
</div>

  

  

  </body>
</html>

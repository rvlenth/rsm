<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>Response-Surface Methods in R, Using rsm â€¢ rsm</title>
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.5.2/css/all.min.css" rel="stylesheet">
<link href="../deps/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet">
<script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Response-Surface Methods in R, Using rsm">
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-light" data-bs-theme="light" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">rsm</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">2.10.6</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="active nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-articles" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Articles</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-articles">
<li><a class="dropdown-item" href="../articles/article-JSS.html">Response-Surface Methods in R, Using rsm</a></li>
    <li><a class="dropdown-item" href="../articles/illus.html">Response-surface illustration</a></li>
    <li><a class="dropdown-item" href="../articles/plots.html">Surface Plots in the rsm Package</a></li>
  </ul>
</li>
      </ul>
<ul class="navbar-nav">
<li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json">
</form></li>
<li class="nav-item"><a class="nav-link" href="https://github.com/rvlenth/rsm/" aria-label="GitHub"><span class="fa fab fa-github fa-lg"></span></a></li>
      </ul>
</div>


  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">

      <h1>Response-Surface Methods in R, Using rsm</h1>
                        <h4 data-toc-skip class="author">rsm package,
Version 2.10.6</h4>
            
      
      <small class="dont-index">Source: <a href="https://github.com/rvlenth/rsm/blob/master/vignettes/article-JSS.rmd"><code>vignettes/article-JSS.rmd</code></a></small>
      <div class="d-none name"><code>article-JSS.rmd</code></div>
    </div>

    
    
<div class="section level3">
<h3 id="abstract">Abstract<a class="anchor" aria-label="anchor" href="#abstract"></a>
</h3>
<p>This introduction to the <strong>R</strong> package
<strong>rsm</strong> is a modified version of Lenth (2009), published in
the <em>Journal of Statistical Software</em>. The package
<strong>rsm</strong> was designed to provide <strong>R</strong> support
for standard response-surface methods. Functions are provided to
generate central-composite and Box-Behnken designs. For analysis of the
resulting data, the package provides for estimating the response
surface, testing its lack of fit, displaying an ensemble of contour
plots of the fitted surface, and doing follow-up analyses such as
steepest ascent, canonical analysis, and ridge analysis. It also
implements a coded-data structure to aid in this essential aspect of the
methodology. The functions are designed in hopes of providing an
intuitive and effective user interface. Potential exists for expanding
the package in a variety of ways.</p>
</div>
<div class="section level2">
<h2 id="introduction">Introduction<a class="anchor" aria-label="anchor" href="#introduction"></a>
</h2>
<p>Response-surface methodology comprises a body of methods for
exploring for optimum operating conditions through experimental methods.
Typically, this involves doing several experiments, using the results of
one experiment to provide direction for what to do next. This next
action could be to focus the experiment around a different set of
conditions, or to collect more data in the current experimental region
in order to fit a higher-order model or confirm what we seem to have
found.</p>
<p>Different levels or values of the operating conditions comprise the
factors in each experiment. Some may be categorical (e.g., the supplier
of raw material) and others may be quantitative (feed rates,
temperatures, and such). In practice, categorical variables must be
handled separately by comparing our best operating conditions with
respect to the quantitative variables across different combinations of
the categorical ones. The fundamental methods for quantitative variables
involve fitting first-order (linear) or second-order (quadratic)
functions of the predictors to one or more response variables, and then
examining the characteristics of the fitted surface to decide what
action is appropriate.</p>
<p>Given that, it may seem like response-surface analysis is simply a
regression problem. However, there are several intricacies in this
analysis and in how it is commonly used that are enough different from
routine regression problems that some special help is warranted. These
intricacies include the common use (and importance) of coded predictor
variables; the assessment of the fit; the different follow-up analyses
that are used depending on what type of model is fitted, as well as the
outcome of the analysis; and the importance of visualizing the response
surface. Response-surface methods also involve some unique
experimental-design issues, due to the emphasis on iterative
experimentation and the need for relatively sparse designs that can be
built-up piece-by-piece according to the evolving needs of the
experimenter.</p>
<p>The <strong>rsm</strong> package for <strong>R</strong> (R
Development Core Team 2009) provides several functions to facilitate
classical response-surface methods, as described in texts such as Box
and Draper (1987), Khuri and Cornell (1996, Chapters 1U5), Wu and Hamada
(2000, Chapter 9), Myers, Montgomery, and Anderson-Cook (2009), Box,
Hunter, and Hunter (2005, Chapters 11U12), and Ryan (2007, Chapter 10).
In its current form, <strong>rsm</strong> covers only the most standard
first-and second order designs and methods for one response variable;
but it covers those reasonably well, and it could be expanded in the
future. Multiple-response optimization is not covered in this package,
but the <strong>desirability</strong> package (Kuhn 2009) may be used in
conjunction with predictions obtained using the <strong>rsm</strong>
package. The <strong>rsm</strong> package is available from the
Comprehensive <strong>R</strong> Archive Network at <a href="https://CRAN.R-project.org/package=rsm" class="external-link uri">https://CRAN.R-project.org/package=rsm</a>.</p>
<p>Here is a general overview of <strong>rsm</strong>. First, it
provides functions and data types that provide for the coding and
decoding of factor levels, since appropriate coding is an important
element of response-surface analysis. These are discussed in the [coding
section]{#coding). Second, it provides functions for generating standard
designs (currently, central-composite and Box-Behnken), and building
blocks thereof, and examining their variance function; see the <a href="#designs">designs section</a>. Third the <a href="#fitting">fitting section</a> extends <strong>R</strong>â€™s
<code>lm</code> function to simplify the specification of standard
response-surface models, and provide appropriate summaries. Fourth, the
<a href="#contour">contour section</a> provides a means of visualizing a
fitted response surface (or in fact any <code>lm</code> object). Finally
the <a href="#steepest">steepest ascent section</a> provides guidance
for further experimentation, e.g., along the path of steepest ascent.
Most <strong>rsm</strong> functions take advantage of
<strong>R</strong>â€™s formula capabilities to provide intuitive and
transparent ways of obtaining the needed results.</p>
<p>To provide some context, there is good commercial software available
to help with designing and analyzing response-surface experiments. The
most popular include Design-Expert (StatEase, Inc.Â 2009), JMP (SAS
Institute, Inc.Â 2009), and Statgraphics (StatPoint Technologies,
Inc.Â 2009). These all provide for generating Box-Behnken and
central-composite designs, fitting first- and second-order response
surfaces, and visualizing them. These programs generally exceed
<strong>rsm</strong>â€™s capabilities (for example, more types of designs,
provisions for mixture experiments, etc.); but <strong>rsm</strong>
makes the most important methods available in <strong>R</strong>. To my
knowledge, the functionality of <strong>rsm</strong>â€™s
<code>ccd.pick</code> function is not provided in other software, and
<strong>rsm</strong> may exceed the capabilities of these programs in
the generality of central-composite designs that it can create.</p>
<p>The goal of this vignette is to present an overview of
<strong>rsm</strong> and how its functions may be used to design and
analyze response-surface experiments. While most important functions in
the package are illustrated, we do not provide comprehensive
documentation here; instead, the reader is referred to the manual and
online documentation provided with the package. The â€œResponse-Surface
Illustrationâ€ vignette details a building-blockock approach to
generating designs and some other newer features in
<strong>rsm</strong>.</p>
</div>
<div class="section level2">
<h2 id="coding">Coding of data<a class="anchor" aria-label="anchor" href="#coding"></a>
</h2>
<p>An important aspect of response-surface analysis is using an
appropriate coding transformation of the data. The way the data are
coded affects the results of canonical analysis (see the sections on <a href="#fitting">fitting</a> and <a href="#steepest">steepest-ascent
analysis</a>); for example, unless the scaling factors are all equal,
the path of steepest ascent obtained by fitting a model to the raw
predictor values will differ from the path obtained in the coded units,
decoded to the original scale. Using a coding method that makes all
coded variables in the experiment vary over the same range is a way of
giving each predictor an equal share in potentially determining the
steepest-ascent path. Thus, coding is an important step in
response-surface analysis.</p>
<p>Accordingly, the <strong>rsm</strong> package provides for a
<code>coded.data</code> class of objects, an extension of
<code>data.frame</code>. The functions <code>coded.data</code>,
<code>as.coded.data</code>, <code>decode.data</code>,
<code>recode.data</code>, <code>code2val</code>, and
<code>val2code</code> create or decode such objects. If a
<code>coded.data</code> object is used in place of an ordinary
<code>data.frame</code> in the call to other <strong>rsm</strong>
functions such as <code>rsm</code> or <code>steepest</code>, then
appropriate additional output is provided that translates the results to
the original units. The <code>print</code> method for a
<code>coded.data</code> object displays the coding formulas and the data
in either coded or decoded form.</p>
<p>As an example, consider the provided dataset <code>ChemReact</code>,
which comes from Table 7.6 of Myers <em>et al.</em> (2009).</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va">`rsm`</span><span class="op">)</span></span>
<span><span class="va">ChemReact</span></span></code></pre></div>
<pre class="ro"><code><span><span class="co">##     Time   Temp Block Yield</span></span>
<span><span class="co">## 1  80.00 170.00    B1  80.5</span></span>
<span><span class="co">## 2  80.00 180.00    B1  81.5</span></span>
<span><span class="co">## 3  90.00 170.00    B1  82.0</span></span>
<span><span class="co">## 4  90.00 180.00    B1  83.5</span></span>
<span><span class="co">## 5  85.00 175.00    B1  83.9</span></span>
<span><span class="co">## 6  85.00 175.00    B1  84.3</span></span>
<span><span class="co">## 7  85.00 175.00    B1  84.0</span></span>
<span><span class="co">## 8  85.00 175.00    B2  79.7</span></span>
<span><span class="co">## 9  85.00 175.00    B2  79.8</span></span>
<span><span class="co">## 10 85.00 175.00    B2  79.5</span></span>
<span><span class="co">## 11 92.07 175.00    B2  78.4</span></span>
<span><span class="co">## 12 77.93 175.00    B2  75.6</span></span>
<span><span class="co">## 13 85.00 182.07    B2  78.5</span></span>
<span><span class="co">## 14 85.00 167.93    B2  77.0</span></span></code></pre>
<p>In this experiment, the data in block <code>B1</code> were collected
first and analyzed, after which block <code>B2</code> was added and a
new analysis was done. The provided datasets <code>ChemReact1</code> and
<code>ChemReact2</code> provide these separate blocks. The first block,
<code>ChemReact1</code>, uses factor settings of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">Time</mtext><mo>=</mo><mn>85</mn><mo>Â±</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">\text{Time}=85\pm5</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">Temp</mtext><mo>=</mo><mn>175</mn><mo>Â±</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">\text{Temp}=175\pm5</annotation></semantics></math>,
with three center points. Thus, the coded variables are
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mtext mathvariant="normal">Time</mtext><mo>âˆ’</mo><mn>85</mn><mo stretchy="true" form="postfix">)</mo></mrow><mi>/</mi><mn>5</mn></mrow><annotation encoding="application/x-tex">x_1 = (\text{Time}-85)/5</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mtext mathvariant="normal">Temp</mtext><mo>âˆ’</mo><mn>175</mn><mo stretchy="true" form="postfix">)</mo></mrow><mi>/</mi><mn>5</mn></mrow><annotation encoding="application/x-tex">x_1 = (\text{Temp}-175)/5</annotation></semantics></math>.
To create a coded dataset with the appropriate codings, provide this
information via formulas:</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">CR1</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/coded.data.html">coded.data</a></span><span class="op">(</span><span class="va">ChemReact1</span>, <span class="va">x1</span> <span class="op">~</span> <span class="op">(</span><span class="va">Time</span> <span class="op">-</span> <span class="fl">85</span><span class="op">)</span><span class="op">/</span><span class="fl">5</span>, <span class="va">x2</span> <span class="op">~</span> <span class="op">(</span><span class="va">Temp</span> <span class="op">-</span> <span class="fl">175</span><span class="op">)</span><span class="op">/</span><span class="fl">5</span><span class="op">)</span></span>
<span><span class="va">CR1</span></span></code></pre></div>
<pre class="ro"><code><span><span class="co">##   Time Temp Yield</span></span>
<span><span class="co">## 1   80  170  80.5</span></span>
<span><span class="co">## 2   80  180  81.5</span></span>
<span><span class="co">## 3   90  170  82.0</span></span>
<span><span class="co">## 4   90  180  83.5</span></span>
<span><span class="co">## 5   85  175  83.9</span></span>
<span><span class="co">## 6   85  175  84.3</span></span>
<span><span class="co">## 7   85  175  84.0</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Data are stored in coded form using these coding formulas ...</span></span>
<span><span class="co">## x1 ~ (Time - 85)/5</span></span>
<span><span class="co">## x2 ~ (Temp - 175)/5</span></span></code></pre>
<p>This listing looks much like the original data, but internally, the
data are saved in coded form, as can be seen by coercing it to a
<code>data.frame</code>:</p>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/as.data.frame.html" class="external-link">as.data.frame</a></span><span class="op">(</span><span class="va">CR1</span><span class="op">)</span></span></code></pre></div>
<pre class="ro"><code><span><span class="co">##   x1 x2 Yield</span></span>
<span><span class="co">## 1 -1 -1  80.5</span></span>
<span><span class="co">## 2 -1  1  81.5</span></span>
<span><span class="co">## 3  1 -1  82.0</span></span>
<span><span class="co">## 4  1  1  83.5</span></span>
<span><span class="co">## 5  0  0  83.9</span></span>
<span><span class="co">## 6  0  0  84.3</span></span>
<span><span class="co">## 7  0  0  84.0</span></span></code></pre>
<p>Any way of writing a linear transformation is acceptable; for
example, we could have written <code>x1 ~ 0.2 * Time - 17</code>.
Observe that <code>coded.data</code> actually transforms the predictor
values and replaces those variables with their coded versions. To create
a <code>coded.data</code> object from data that are already coded, use
<code>as.coded.data</code>.</p>
<p>The function <code>decode.data</code> decodes a
<code>coded.data</code> object. We may also easily encode or decode
matrices or data frames of arbitrary values; for example,</p>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/coded.data.html">code2val</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span>x1 <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0.25</span>, <span class="fl">0.5</span><span class="op">)</span>, x2 <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="op">-</span><span class="fl">1.5</span>, <span class="op">-</span><span class="fl">0.5</span><span class="op">)</span><span class="op">)</span>, <span class="fu"><a href="../reference/coded.data.html">codings</a></span><span class="op">(</span><span class="va">CR1</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<pre class="ro"><code><span><span class="co">##    Time  Temp</span></span>
<span><span class="co">## 1 86.25 167.5</span></span>
<span><span class="co">## 2 87.50 172.5</span></span></code></pre>
</div>
<div class="section level2">
<h2 id="designs">Generating a design<a class="anchor" aria-label="anchor" href="#designs"></a>
</h2>
<p>The functions <code>ccd</code> and <code>bbd</code> are available to
generate standard response-surface designs. For example, here we
generate a 3-factor Box-Behnken design (Box and Behnken, 1960) with two
center points:</p>
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/bbd.html">bbd</a></span><span class="op">(</span><span class="fl">3</span>, n0 <span class="op">=</span> <span class="fl">2</span>, coding <span class="op">=</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="va">x1</span> <span class="op">~</span> <span class="op">(</span><span class="va">Force</span> <span class="op">-</span> <span class="fl">20</span><span class="op">)</span><span class="op">/</span><span class="fl">3</span>, <span class="va">x2</span> <span class="op">~</span> <span class="op">(</span><span class="va">Rate</span> <span class="op">-</span> <span class="fl">50</span><span class="op">)</span><span class="op">/</span><span class="fl">10</span>, <span class="va">x3</span> <span class="op">~</span> <span class="va">Polish</span> <span class="op">-</span> <span class="fl">4</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<pre class="ro"><code><span><span class="co">##    run.order std.order Force Rate Polish</span></span>
<span><span class="co">## 1          1         8    23   50      5</span></span>
<span><span class="co">## 2          2        14    20   50      4</span></span>
<span><span class="co">## 3          3        11    20   40      5</span></span>
<span><span class="co">## 4          4         6    23   50      3</span></span>
<span><span class="co">## 5          5         4    23   60      4</span></span>
<span><span class="co">## 6          6         5    17   50      3</span></span>
<span><span class="co">## 7          7         2    23   40      4</span></span>
<span><span class="co">## 8          8        10    20   60      3</span></span>
<span><span class="co">## 9          9        12    20   60      5</span></span>
<span><span class="co">## 10        10         7    17   50      5</span></span>
<span><span class="co">## 11        11         9    20   40      3</span></span>
<span><span class="co">## 12        12         3    17   60      4</span></span>
<span><span class="co">## 13        13         1    17   40      4</span></span>
<span><span class="co">## 14        14        13    20   50      4</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Data are stored in coded form using these coding formulas ...</span></span>
<span><span class="co">## x1 ~ (Force - 20)/3</span></span>
<span><span class="co">## x2 ~ (Rate - 50)/10</span></span>
<span><span class="co">## x3 ~ Polish - 4</span></span></code></pre>
<p>By default, the variable names are <code>x1</code>, <code>x2</code>,
â€¦ and the experiment is randomized. If there are
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>4</mn><annotation encoding="application/x-tex">4</annotation></semantics></math>
or
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>5</mn><annotation encoding="application/x-tex">5</annotation></semantics></math>
factors, the design is blocked by default (this is not possible for
other numbers of factors), and the blocks are randomized separately.</p>
<p>One of the most popular response-surface designs is the
central-composite design (CCD), due to Box and Wilson (1951). A simple
example is the chemical-reaction experiment presented in the preceding
section. These designs allow for sequential augmentation, so that we may
first experiment with just one block suitable for fitting a first-order
model, and then add more block(s) if a second-order fit is needed.<br>
The blocks in a CCD are of two typesâ€”one type, called a â€œcubeâ€ block,
contains design points from a two-level factorial or fractional
factorial design, plus center points; the other type, called a â€œstarâ€
block, contains axis points plus center points.</p>
<p>In the following discussion, the term â€œdesign pointsâ€ refers to the
non-center points in a block. The levels of the factors are coded, so
that the cube blocks contain design points with coordinate values all
equal to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>Â±</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\pm1</annotation></semantics></math>,
and center points at
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo>,</mo><mn>0</mn><mo>,</mo><mi>â€¦</mi><mo>,</mo><mn>0</mn><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(0,0,\ldots,0)</annotation></semantics></math>.
The design points in the star blocks are at positions of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>Â±</mo><mi>Î±</mi></mrow><annotation encoding="application/x-tex">\pm\alpha</annotation></semantics></math>
along each coordinate axis. The value of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Î±</mi><annotation encoding="application/x-tex">\alpha</annotation></semantics></math>,
and choices of replications of design points and center points, are
often selected based on considerations of rotatability (i.e., the
variance of the prediction depends only on the distance from the center)
and orthogonality of blocks (so that the coefficients of the fitted
response-surface equation are not correlated with block effects).</p>
<p>The table below displays the parameters of a CCD, along with the
names used by the function <code>ccd.pick</code> to be described
shortly. Suppose that there are
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>
variables to be varied. For the cube blocks, we start with a given
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>2</mn><mrow><mi>k</mi><mo>âˆ’</mo><mi>p</mi></mrow></msup><annotation encoding="application/x-tex">2^{k-p}</annotation></semantics></math>
fractional factorial design (or full factorial, when
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">p=0</annotation></semantics></math>).
We may either use this design as-is to define the design points in the
cube block(s). Alternatively, we may confound one or more effects with
blocks to split this design into <code>blks.c</code> smaller cube
blocks, in which case each cube block contains
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mi>k</mi><mo>âˆ’</mo><mi>p</mi></mrow></msup><mi>/</mi><mrow><mi>ğš‹</mi><mi>ğš•</mi><mi>ğš”</mi><mi>ğšœ</mi><mi mathvariant="monospace">.</mi><mi>ğšŒ</mi></mrow></mrow><annotation encoding="application/x-tex">2^{k-p}/\mathtt{blks.c}</annotation></semantics></math>
distinct design points. The star blocks always contain all
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>k</mi></mrow><annotation encoding="application/x-tex">2k</annotation></semantics></math>
distinct design pointsâ€”two on each axis.</p>
<table class="table">
<colgroup>
<col width="30%">
<col width="34%">
<col width="34%">
</colgroup>
<thead><tr class="header">
<th align="left">Parameter(s)</th>
<th align="left">Cube block(s)</th>
<th align="left">Star block(s)</th>
</tr></thead>
<tbody>
<tr class="odd">
<td align="left">Design points</td>
<td align="left"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mo>Â±</mo><mn>1</mn><mo>,</mo><mo>Â±</mo><mn>1</mn><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><mo>Â±</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(\pm1,\pm1,...,\pm1)</annotation></semantics></math></td>
<td align="left"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">(</mo><mo>Â±</mo><mi>Î±</mi><mo>,</mo><mn>0</mn><mo>,</mo><mn>0</mn><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><mn>0</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo>,</mo><mn>0</mn><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><mo>Â±</mo><mi>Î±</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">(\pm\alpha,0,0,...,0),...,(0,0,...,\pm\alpha)</annotation></semantics></math></td>
</tr>
<tr class="even">
<td align="left">Center points</td>
<td align="left"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo>,</mo><mn>0</mn><mo>,</mo><mi>â€¦</mi><mo>,</mo><mn>0</mn><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(0,0,\ldots,0)</annotation></semantics></math></td>
<td align="left"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo>,</mo><mn>0</mn><mo>,</mo><mi>â€¦</mi><mo>,</mo><mn>0</mn><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(0,0,\ldots,0)</annotation></semantics></math></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left"># <em>Distinct</em> design points</td>
<td align="left">
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>2</mn><mrow><mi>k</mi><mo>âˆ’</mo><mi>p</mi></mrow></msup><annotation encoding="application/x-tex">2^{k-p}</annotation></semantics></math>
(altogether)</td>
<td align="left"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>k</mi></mrow><annotation encoding="application/x-tex">2k</annotation></semantics></math></td>
</tr>
<tr class="odd">
<td align="left"># Fractions of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>2</mn><mrow><mi>k</mi><mo>âˆ’</mo><mi>p</mi></mrow></msup><annotation encoding="application/x-tex">2^{k-p}</annotation></semantics></math>
</td>
<td align="left"><code>blks.c</code></td>
<td align="left">â€“</td>
</tr>
<tr class="even">
<td align="left">Reps of each design point, within each block</td>
<td align="left"><code>wbr.c</code></td>
<td align="left"><code>wbr.s</code></td>
</tr>
<tr class="odd">
<td align="left"># Design pts each block</td>
<td align="left">
<code>n.c</code>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>=</mo><mfrac><mrow><mi>ğš </mi><mi>ğš‹</mi><mi>ğš›</mi><mi mathvariant="monospace">.</mi><mi>ğšŒ</mi></mrow><mrow><mi>ğš‹</mi><mi>ğš•</mi><mi>ğš”</mi><mi>ğšœ</mi><mi mathvariant="monospace">.</mi><mi>ğšŒ</mi></mrow></mfrac><mo>â‹…</mo><msup><mn>2</mn><mrow><mi>k</mi><mo>âˆ’</mo><mi>p</mi></mrow></msup></mrow><annotation encoding="application/x-tex">= \mathtt{\frac{wbr.c}{blks.c}}\cdot2^{k-p}</annotation></semantics></math>
</td>
<td align="left">
<code>n.s</code>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>=</mo><mrow><mi>ğš </mi><mi>ğš‹</mi><mi>ğš›</mi><mi mathvariant="monospace">.</mi><mi>ğšœ</mi></mrow><mo>â‹…</mo><mrow><mo stretchy="true" form="prefix">(</mo><mn>2</mn><mi>k</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">=\mathtt{wbr.s}\cdot(2k)</annotation></semantics></math>
</td>
</tr>
<tr class="even">
<td align="left"># Center points</td>
<td align="left"><code>n0.c</code></td>
<td align="left"><code>n0.s</code></td>
</tr>
<tr class="odd">
<td align="left"># Points in each block</td>
<td align="left"><code>n.c + n0.c</code></td>
<td align="left"><code>n.s + n0.s</code></td>
</tr>
<tr class="even">
<td align="left">Reps of each block</td>
<td align="left"><code>bbr.c</code></td>
<td align="left"><code>bbr.s</code></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left">Total observations (<code>N</code>)</td>
<td align="left"><code>blks.c * bbr.c * (n.c + n0.c)</code></td>
<td align="left"><code>+ bbr.s * (n.s + n0.s)</code></td>
</tr>
</tbody>
</table>
<p>Once the designs are decided, we may, if we like, replicate them
within blocks. We may also replicate the center points. The names
<code>wbr.c</code> and <code>wbr.s</code> (for â€œwithin-block repsâ€)
refer to the number of replicates of each design point within each cube
block or star block, respectively.<br>
Thus, each cube block has a total of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>ğš—</mi><mi mathvariant="monospace">.</mi><mi>ğšŒ</mi></mrow><mo>=</mo><mrow><mi>ğš </mi><mi>ğš‹</mi><mi>ğš›</mi><mi mathvariant="monospace">.</mi><mi>ğšŒ</mi></mrow><mo>â‹…</mo><msup><mn>2</mn><mrow><mi>k</mi><mo>âˆ’</mo><mi>p</mi></mrow></msup><mi>/</mi><mrow><mi>ğš‹</mi><mi>ğš•</mi><mi>ğš”</mi><mi>ğšœ</mi><mi mathvariant="monospace">.</mi><mi>ğšŒ</mi></mrow></mrow><annotation encoding="application/x-tex">\mathtt{n.c} = \mathtt{wbr.c}\cdot2^{k-p}/\mathtt{blks.c}</annotation></semantics></math>
design points, and each star block contains
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>ğš </mi><mi>ğš‹</mi><mi>ğš›</mi><mi mathvariant="monospace">.</mi><mi>ğšœ</mi></mrow><mo>â‹…</mo><mn>2</mn><mi>k</mi></mrow><annotation encoding="application/x-tex">\mathtt{wbr.s}\cdot2k</annotation></semantics></math>
design points. We may also replicate the center pointsâ€”<code>n0.c</code>
times in each cube block, <code>n0.s</code> times within each star
block.</p>
<p>Finally, we may replicate the blocks themselves; the numbers of such
between-block replications are denoted <code>bbr.c</code> and
<code>bbr.s</code> for cube blocks and star blocks, respectively. It is
important to understand that each block is separately randomized, in
effect a mini-experiment within the larger experiment. Having
between-block replications means repeating these mini-experiments. We
run an entire block before running another block.</p>
<p>The function <code>ccd.pick</code> is designed to help identify good
CCDs. It simply creates a grid of all combinations of design choices,
computes the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Î±</mi><annotation encoding="application/x-tex">\alpha</annotation></semantics></math>
values required for orthogonality and rotatability, sorts them by a
specified criterion (by default, a measure of the discrepancy between
these two
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Î±</mi><annotation encoding="application/x-tex">\alpha</annotation></semantics></math>s),
and presents the best few.</p>
<p>For example, suppose that we want to experiment with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">k=5</annotation></semantics></math>
factors, and we are willing to consider CCDs with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>ğš‹</mi><mi>ğš•</mi><mi>ğš”</mi><mi>ğšœ</mi><mi mathvariant="monospace">.</mi><mi>ğšŒ</mi></mrow><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\mathtt{blks.c}=1</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>2</mn><annotation encoding="application/x-tex">2</annotation></semantics></math>,
or
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>4</mn><annotation encoding="application/x-tex">4</annotation></semantics></math>
cube blocks of sizes
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>ğš—</mi><mi mathvariant="monospace">.</mi><mi>ğšŒ</mi></mrow><mo>=</mo><mn>8</mn></mrow><annotation encoding="application/x-tex">\mathtt{n.c}=8</annotation></semantics></math>
or
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>16</mn><annotation encoding="application/x-tex">16</annotation></semantics></math>
each.<br>
With this many factors, the number of different star points
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>k</mi><mo>=</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">2k=10</annotation></semantics></math>)
is relatively small compared with the size of some cube blocks
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>16</mn><annotation encoding="application/x-tex">16</annotation></semantics></math>),
so it seems reasonable to consider either one or two replications
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>ğš </mi><mi>ğš‹</mi><mi>ğš›</mi><mi mathvariant="monospace">.</mi><mi>ğšœ</mi></mrow><mo>âˆˆ</mo><mo stretchy="false" form="prefix">{</mo><mn>1</mn><mo>,</mo><mn>2</mn><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\mathtt{wbr.s}\in\{1,2\}</annotation></semantics></math>)
of each point within each star block.<br>
Finally, suppose that we want the total size of the experiment to be no
more than
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>=</mo><mn>65</mn></mrow><annotation encoding="application/x-tex">N=65</annotation></semantics></math>
runs (see <code>restrict</code> in the call below). Here are the ten
best choices based on these criteria:</p>
<div class="sourceCode" id="cb11"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/ccd.pick.html">ccd.pick</a></span><span class="op">(</span><span class="fl">5</span>, n.c <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">8</span>, <span class="fl">16</span><span class="op">)</span>, blks.c <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">2</span>, <span class="fl">4</span><span class="op">)</span>,</span>
<span>  wbr.s <span class="op">=</span> <span class="fl">1</span><span class="op">:</span><span class="fl">2</span>, restrict <span class="op">=</span> <span class="st">"N&lt;=65"</span><span class="op">)</span></span></code></pre></div>
<pre class="ro"><code><span><span class="co">##    n.c n0.c blks.c n.s n0.s bbr.c wbr.s bbr.s  N alpha.rot alpha.orth</span></span>
<span><span class="co">## 1   16    6      1  10    1     1     1     1 33  2.000000   2.000000</span></span>
<span><span class="co">## 2   16    8      1  10    2     1     1     1 36  2.000000   2.000000</span></span>
<span><span class="co">## 3   16   10      1  10    3     1     1     1 39  2.000000   2.000000</span></span>
<span><span class="co">## 4   16    5      2  20    1     1     2     1 63  2.000000   2.000000</span></span>
<span><span class="co">## 5   16    8      2  10    7     1     1     1 65  2.378414   2.380476</span></span>
<span><span class="co">## 6    8    4      4  10    7     1     1     1 65  2.378414   2.380476</span></span>
<span><span class="co">## 7   16    1      2  10    2     1     1     1 46  2.378414   2.376354</span></span>
<span><span class="co">## 8   16    5      2  10    5     1     1     1 57  2.378414   2.390457</span></span>
<span><span class="co">## 9   16    4      2  10    4     1     1     1 54  2.378414   2.366432</span></span>
<span><span class="co">## 10   8    2      4  10    4     1     1     1 54  2.378414   2.366432</span></span></code></pre>
<p>The first design listed is also the smallest; it consists of one cube
block of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>16</mn><annotation encoding="application/x-tex">16</annotation></semantics></math>
runs, plus
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>6</mn><annotation encoding="application/x-tex">6</annotation></semantics></math>
center points; and one star block with the points replicated once and
one center point; thus, the total number of runs is
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mn>16</mn><mo>+</mo><mn>6</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mrow><mo stretchy="true" form="prefix">(</mo><mn>10</mn><mo>+</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mn>33</mn></mrow><annotation encoding="application/x-tex">N=(16+6)+(10+1) = 33</annotation></semantics></math>.
If we choose
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Î±</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">\alpha=2</annotation></semantics></math>,
this design is both orthogonal and rotatable as seen by noting that
<code>alpha.rot</code> and <code>alpha.orth</code> are both equal to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>2</mn><annotation encoding="application/x-tex">2</annotation></semantics></math>.
The
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>16</mn><annotation encoding="application/x-tex">16</annotation></semantics></math>
design points in the cube block may be generated by a
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>2</mn><mrow><mn>5</mn><mo>âˆ’</mo><mn>1</mn></mrow></msup><annotation encoding="application/x-tex">2^{5-1}</annotation></semantics></math>
fractional factorial design.</p>
<p>While this is a small design, we have only one center point in the
star block, not providing a way to test lack of fit in the star portion.
The second and third designs remedy this slightly, but all these designs
are fairly lopsided in that the cube block is much larger than the star
block. The next few designs require considerably more runs. Design
number 4 is nicely balanced in that it consists of three blocks of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>21</mn><annotation encoding="application/x-tex">21</annotation></semantics></math>
runs each, and it is both rotatable and orthogonal. However, we still
have no lack-of-fit test in the star blocks. Designs 5 and 6 differ only
in whether they use two
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>2</mn><mrow><mn>5</mn><mo>âˆ’</mo><mn>1</mn></mrow></msup><annotation encoding="application/x-tex">2^{5-1}</annotation></semantics></math>
cubes or four
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>2</mn><mrow><mn>5</mn><mo>âˆ’</mo><mn>2</mn></mrow></msup><annotation encoding="application/x-tex">2^{5-2}</annotation></semantics></math>
cubes, but they provide several center points for a lack-of-fit test. If
we position the axis points at
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Î±</mi><mo>=</mo><mn>2.38</mn></mrow><annotation encoding="application/x-tex">\alpha=2.38</annotation></semantics></math>,
the design is almost orthogonal and almost rotatable. The remaining
designs also come close to meeting both criteria, but are also somewhat
smaller, so that Designs 9 and 10 are essentially down-sized versions of
Designs 5 and 6.</p>
<p>The choice of which design is best depends on the tradeoff between
economy and ability to assess the fitted surface. Design 1 is the only
one of these that is included in Table 7.6 of Myers <em>et al.</em>
(2009). It is good to be able to look at a broader range of choices.</p>
<p>Once we decide the design, the <code>ccd</code> function is used to
generate it. (Alternatively, starting with <strong>rsm</strong> version
2.0, the <code>cube</code>, <code>star</code>, <code>foldover</code>,
and <code>dupe</code> functions are available for generating and
randomizing a CCD in separate blocks, and then they may be combined
using <code>djoin</code>.) We first illustrate the generation of Design
1 above. This design requires a
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>2</mn><mrow><mn>5</mn><mo>âˆ’</mo><mn>1</mn></mrow></msup><annotation encoding="application/x-tex">2^{5-1}</annotation></semantics></math>
fraction for the cube block. Typically, this is done by confounding the
five-way interaction with the mean; or equivalently, create a
four-factor design, and generate the levels of the fifth as the four-way
interaction of the others. That is the approach implemented by
<code>ccd</code>. Suppose that we denote the design factors by
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>,</mo><mi>B</mi><mo>,</mo><mi>C</mi><mo>,</mo><mi>D</mi><mo>,</mo><mi>E</mi></mrow><annotation encoding="application/x-tex">A,B,C,D,E</annotation></semantics></math>;
letâ€™s opt to use
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo>=</mo><mo>âˆ’</mo><mi>A</mi><mi>B</mi><mi>C</mi><mi>D</mi></mrow><annotation encoding="application/x-tex">E=-ABCD</annotation></semantics></math>
as the generator. The following call generates the design (results not
shown):</p>
<div class="sourceCode" id="cb13"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">des1</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/ccd.html">ccd</a></span> <span class="op">(</span><span class="va">y1</span> <span class="op">+</span> <span class="va">y2</span> <span class="op">~</span> <span class="va">A</span> <span class="op">+</span> <span class="va">B</span> <span class="op">+</span> <span class="va">C</span> <span class="op">+</span> <span class="va">D</span>,</span>
<span>  generators <span class="op">=</span> <span class="va">E</span> <span class="op">~</span> <span class="op">-</span> <span class="va">A</span> <span class="op">*</span> <span class="va">B</span> <span class="op">*</span> <span class="va">C</span> <span class="op">*</span> <span class="va">D</span>, n0 <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">6</span>, <span class="fl">1</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p>The value of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Î±</mi><annotation encoding="application/x-tex">\alpha</annotation></semantics></math>
was not specified, and by default it uses the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Î±</mi><annotation encoding="application/x-tex">\alpha</annotation></semantics></math>
for orthogonality. The first argument could have been just
<code>4</code>, but then the generator would have had to have been given
in terms of the default variable names <code>x1</code>, <code>x2</code>,
â€¦. The optional left-hand side in the formula creates place-holders for
response variable(s), to be filled-in with data later. As in
<code>bbd</code>, we could have added coding formulas to create a
<code>coded.data</code> object.</p>
<p>Next, we illustrate the generation of Design 10. This design has four
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>2</mn><mrow><mn>5</mn><mo>âˆ’</mo><mn>2</mn></mrow></msup><annotation encoding="application/x-tex">2^{5-2}</annotation></semantics></math>
cube blocks with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>2</mn><annotation encoding="application/x-tex">2</annotation></semantics></math>
center points each, and one unreplicated star block with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>4</mn><annotation encoding="application/x-tex">4</annotation></semantics></math>
center points. The non-center points in the cube blocks comprise
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mo>Ã—</mo><mn>8</mn><mo>=</mo><mn>32</mn></mrow><annotation encoding="application/x-tex">4\times8=32</annotation></semantics></math>
runs, so we most likely want to create them by dividing the full
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>2</mn><mn>5</mn></msup><annotation encoding="application/x-tex">2^5</annotation></semantics></math>
factorial into four fractional blocks. We can for example opt to
generate the blocks via the factors
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>b</mi><mn>1</mn></msub><mo>=</mo><mi>A</mi><mi>B</mi><mi>C</mi></mrow><annotation encoding="application/x-tex">b_1=ABC</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>b</mi><mn>2</mn></msub><mo>=</mo><mi>C</mi><mi>D</mi><mi>E</mi></mrow><annotation encoding="application/x-tex">b_2=CDE</annotation></semantics></math>,
so that the blocks are determined by the four combinations of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>b</mi><mn>1</mn></msub><annotation encoding="application/x-tex">b_1</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>b</mi><mn>2</mn></msub><annotation encoding="application/x-tex">b_2</annotation></semantics></math>.
Then the block effects will be confounded with the effects
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>B</mi><mi>C</mi></mrow><annotation encoding="application/x-tex">ABC</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>D</mi><mi>E</mi></mrow><annotation encoding="application/x-tex">CDE</annotation></semantics></math>,
and also the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>b</mi><mn>1</mn></msub><msub><mi>b</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">b_1b_2</annotation></semantics></math>
interaction
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>B</mi><msup><mi>C</mi><mn>2</mn></msup><mi>D</mi><mi>E</mi><mo>=</mo><mi>A</mi><mi>B</mi><mi>D</mi><mi>E</mi></mrow><annotation encoding="application/x-tex">ABC^2DE=ABDE</annotation></semantics></math>.
It is important in response-surface work to avoid confounding
second-order interactions, and this scheme is thus acceptable. Unlike
Design 1, this design includes all
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>2</mn><mn>5</mn></msup><annotation encoding="application/x-tex">2^5</annotation></semantics></math>
factor combinations, so we do not use the <code>generators</code>
argument; instead, we use <code>blocks</code> to do the
fractionation:</p>
<div class="sourceCode" id="cb14"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">des10</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/ccd.html">ccd</a></span><span class="op">(</span> <span class="op">~</span> <span class="va">A</span> <span class="op">+</span> <span class="va">B</span> <span class="op">+</span> <span class="va">C</span> <span class="op">+</span> <span class="va">D</span> <span class="op">+</span> <span class="va">E</span>,</span>
<span>  blocks <span class="op">=</span> <span class="va">Blk</span> <span class="op">~</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="va">A</span> <span class="op">*</span> <span class="va">B</span> <span class="op">*</span> <span class="va">C</span>, <span class="va">C</span> <span class="op">*</span> <span class="va">D</span> <span class="op">*</span> <span class="va">E</span><span class="op">)</span>, n0 <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">2</span>, <span class="fl">4</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p>Each block is randomized separately, but the order of the blocks is
not randomized. In practice, we may opt to run the blocks in a different
sequence.<br>
With this design, just one of the cube blocks is sufficient to estimate
a first-order response surface.</p>
<p>It is also important to examine a designâ€™s capabilities. First of
all, is it adequate to fit the needed first- or second-order model, and
how effective is it in predicting the response surface? The
<code>varfcn</code> function (a new addition starting
<strong>rsm</strong> version 2.0) is helpful in this regard. It
calculates a scaled version of the varaince of the fitted values over a
specified set of design points. By default, it computes this along paths
through
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>,</mo><mn>0</mn><mo>,</mo><mi>â€¦</mi><mo>,</mo><mn>0</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>,</mo><mn>1</mn><mo>,</mo><mi>â€¦</mi><mo>,</mo><mn>0</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mi>â€¦</mi><mo>,</mo><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>,</mo><mn>1</mn><mo>,</mo><mi>â€¦</mi><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">(1,0,\ldots,0),(1,1,\ldots,0),\ldots,(1,1,\ldots,1)</annotation></semantics></math>,
or on a grid with the first two variables. The right-hand side of the
intended model must be provided.</p>
<p>We illustrate this for Design 10:</p>
<div class="sourceCode" id="cb15"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/varfcn.html">varfcn</a></span><span class="op">(</span><span class="va">des10</span>, <span class="op">~</span> <span class="va">Blk</span> <span class="op">+</span> <span class="fu"><a href="../reference/FO.html">SO</a></span><span class="op">(</span><span class="va">A</span>,<span class="va">B</span>,<span class="va">C</span>,<span class="va">D</span>,<span class="va">E</span><span class="op">)</span>, dist <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">3</span>, by <span class="op">=</span> <span class="fl">.1</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p><img src="article-JSS_files/figure-html/unnamed-chunk-10-1.png" width="480"></p>
<div class="sourceCode" id="cb16"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/varfcn.html">varfcn</a></span><span class="op">(</span><span class="va">des10</span>, <span class="op">~</span> <span class="va">Blk</span> <span class="op">+</span> <span class="fu"><a href="../reference/FO.html">SO</a></span><span class="op">(</span><span class="va">A</span>,<span class="va">B</span>,<span class="va">C</span>,<span class="va">D</span>,<span class="va">E</span><span class="op">)</span>, dist <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">3</span>, by <span class="op">=</span> <span class="fl">.1</span><span class="op">)</span>, contour <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></code></pre></div>
<p><img src="article-JSS_files/figure-html/unnamed-chunk-10-2.png" width="480"></p>
<p>It shows that the design is nearly rotatable (it would be exactly so
if we had chosen <code>alpha = "rotatable"</code> in the call to
<code>ccd</code>). It can also be verified that any two of the cube
blocks plus the axis block is sufficient to estimate a second-order
response surface. Just one cube block plus the axis points, however, is
not sufficient.</p>
<p>It is possible to imagine a CCD that consists of a fractional
factorial divided into blocks. For such a design, both
<code>generators</code> and <code>blocks</code> would be needed. For
smaller numbers of factors, most CCDs require no fractionation of either
type, and obviously these are simple to generate.</p>
<p>Starting in version 1.40 of <strong>rsm</strong>, an
<code>inscribed</code> argument is available in <code>ccd</code>. This
scales the entire design so that it fits within a unit cubeâ€”useful for
situations when there are constraints on the region of operability.</p>
<div class="sourceCode" id="cb17"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/ccd.html">ccd</a></span><span class="op">(</span><span class="fl">2</span>, n0 <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">1</span><span class="op">)</span>, inscribed <span class="op">=</span> <span class="cn">TRUE</span>, randomize <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span></code></pre></div>
<pre class="ro"><code><span><span class="co">##    run.order std.order   x1.as.is   x2.as.is Block</span></span>
<span><span class="co">## 1          1         1 -0.7071068 -0.7071068     1</span></span>
<span><span class="co">## 2          2         2  0.7071068 -0.7071068     1</span></span>
<span><span class="co">## 3          3         3 -0.7071068  0.7071068     1</span></span>
<span><span class="co">## 4          4         4  0.7071068  0.7071068     1</span></span>
<span><span class="co">## 5          5         5  0.0000000  0.0000000     1</span></span>
<span><span class="co">## 6          1         1 -1.0000000  0.0000000     2</span></span>
<span><span class="co">## 7          2         2  1.0000000  0.0000000     2</span></span>
<span><span class="co">## 8          3         3  0.0000000 -1.0000000     2</span></span>
<span><span class="co">## 9          4         4  0.0000000  1.0000000     2</span></span>
<span><span class="co">## 10         5         5  0.0000000  0.0000000     2</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Data are stored in coded form using these coding formulas ...</span></span>
<span><span class="co">## x1 ~ x1.as.is</span></span>
<span><span class="co">## x2 ~ x2.as.is</span></span></code></pre>
<p>Note in this example that it is now the axis points that are at
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>Â±</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\pm1</annotation></semantics></math>,
while the cube points are at
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>Â±</mo><msqrt><mrow><mn>1</mn><mi>/</mi><mn>2</mn></mrow></msqrt></mrow><annotation encoding="application/x-tex">\pm\sqrt{1/2}</annotation></semantics></math>.
(Incidentally, this example also illustrates the default codings used
when no coding formulas are specified.)</p>
<p>There are several other types of designs that are useful for response
surfaces, as mentioned in several of the books referenced in this
article. Provisions for generating those designs are an area of future
development in the <strong>rsm</strong> package.</p>
</div>
<div class="section level2">
<h2 id="fitting">Fitting a response-surface model<a class="anchor" aria-label="anchor" href="#fitting"></a>
</h2>
<p>A response surface is fitted using the <code>rsm</code> function.
This is an extension of <code>lm</code>, and works almost exactly like
it; however, the model formula for <code>rsm</code> must make use of the
special functions <code>FO</code>, <code>TWI</code>, <code>PQ</code>, or
<code>SO</code> (for â€œfirst-order,â€, â€œtwo-way interaction,â€ â€œpure
quadratic,â€ and â€œsecond-order,â€ respectively), because the presence of
these specifies the response-surface portion of the model. Other terms
that donâ€™t involve these functions may be included in the model; often,
these terms would include blocking factors and other categorical
predictors.</p>
<p>To illustrate this, let us revisit the <code>ChemReact</code> data
introduced in the <a href="#coding">coding</a> section. We have one
response variable, <code>Yield</code>, and two coded predictors
<code>x1</code> and <code>x2</code> as well as a blocking factor
<code>Block</code>. Supposing that the experiment was done in two
stages, we first act as though the data in the second block have not yet
been collected; and fit a first-order response-surface model to the data
in the first block:</p>
<div class="sourceCode" id="cb19"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">CR1.rsm</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/rsm.html">rsm</a></span><span class="op">(</span><span class="va">Yield</span> <span class="op">~</span> <span class="fu"><a href="../reference/FO.html">FO</a></span><span class="op">(</span><span class="va">x1</span>, <span class="va">x2</span><span class="op">)</span>, data <span class="op">=</span> <span class="va">CR1</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">CR1.rsm</span><span class="op">)</span></span></code></pre></div>
<pre class="ro"><code><span><span class="co">## </span></span>
<span><span class="co">## Call:</span></span>
<span><span class="co">## rsm(formula = Yield ~ FO(x1, x2), data = CR1)</span></span>
<span><span class="co">## </span></span>
<span><span class="co">##             Estimate Std. Error  t value  Pr(&gt;|t|)    </span></span>
<span><span class="co">## (Intercept) 82.81429    0.54719 151.3456 1.143e-08 ***</span></span>
<span><span class="co">## x1           0.87500    0.72386   1.2088    0.2933    </span></span>
<span><span class="co">## x2           0.62500    0.72386   0.8634    0.4366    </span></span>
<span><span class="co">## ---</span></span>
<span><span class="co">## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Multiple R-squared:  0.3555, Adjusted R-squared:  0.0333 </span></span>
<span><span class="co">## F-statistic: 1.103 on 2 and 4 DF,  p-value: 0.4153</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Analysis of Variance Table</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Response: Yield</span></span>
<span><span class="co">##             Df Sum Sq Mean Sq F value  Pr(&gt;F)</span></span>
<span><span class="co">## FO(x1, x2)   2 4.6250  2.3125  1.1033 0.41534</span></span>
<span><span class="co">## Residuals    4 8.3836  2.0959                </span></span>
<span><span class="co">## Lack of fit  2 8.2969  4.1485 95.7335 0.01034</span></span>
<span><span class="co">## Pure error   2 0.0867  0.0433                </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Direction of steepest ascent (at radius 1):</span></span>
<span><span class="co">##        x1        x2 </span></span>
<span><span class="co">## 0.8137335 0.5812382 </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Corresponding increment in original units:</span></span>
<span><span class="co">##     Time     Temp </span></span>
<span><span class="co">## 4.068667 2.906191</span></span></code></pre>
<p>What we see in the summary is the usual summary for a <code>lm</code>
object (with a subtle difference), followed by some additional
information particular to response surfaces. The subtle difference is
that the labeling of the regression coefficients is simplified (we donâ€™t
see â€œFOâ€ in there). The analysis-of-variance table shown includes a
breakdown of lack of fit and pure error, and we are also given
information about the direction of steepest ascent. Since the dataset is
a <code>coded.data</code> object, the steepest-ascent information is
also presented in original units. (While <code>rsm</code> does not
require a <code>coded.data</code> dataset, the use of one is highly
recommended.)</p>
<p>In this particular example, the steepest-ascent information is of
little use, because there is significant lack of fit for this model
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>â‰ˆ</mo><mn>0.01</mn></mrow><annotation encoding="application/x-tex">p \approx 0.01</annotation></semantics></math>).
It suggests that we should try a higher-order model. For example, we
could add two-way interactions:</p>
<div class="sourceCode" id="cb21"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">CR1.rsmi</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/update.html" class="external-link">update</a></span><span class="op">(</span><span class="va">CR1.rsm</span>, <span class="va">.</span> <span class="op">~</span> <span class="va">.</span> <span class="op">+</span> <span class="fu"><a href="../reference/FO.html">TWI</a></span><span class="op">(</span><span class="va">x1</span>, <span class="va">x2</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">CR1.rsmi</span><span class="op">)</span></span></code></pre></div>
<p>The results are not shown, but one finds there is still a small
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>
value for lack-of-fit.</p>
<p>To go further, we need more data. Thus, let us pretend that we now
collect the data in the second block. Then here are the data from the
combined blocks:</p>
<div class="sourceCode" id="cb22"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="op">(</span> <span class="va">CR2</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/djoin.html">djoin</a></span><span class="op">(</span><span class="va">CR1</span>, <span class="va">ChemReact2</span><span class="op">)</span> <span class="op">)</span></span></code></pre></div>
<pre class="ro"><code><span><span class="co">##     Time   Temp Yield Block</span></span>
<span><span class="co">## 1  80.00 170.00  80.5     1</span></span>
<span><span class="co">## 2  80.00 180.00  81.5     1</span></span>
<span><span class="co">## 3  90.00 170.00  82.0     1</span></span>
<span><span class="co">## 4  90.00 180.00  83.5     1</span></span>
<span><span class="co">## 5  85.00 175.00  83.9     1</span></span>
<span><span class="co">## 6  85.00 175.00  84.3     1</span></span>
<span><span class="co">## 7  85.00 175.00  84.0     1</span></span>
<span><span class="co">## 8  85.00 175.00  79.7     2</span></span>
<span><span class="co">## 9  85.00 175.00  79.8     2</span></span>
<span><span class="co">## 10 85.00 175.00  79.5     2</span></span>
<span><span class="co">## 11 92.07 175.00  78.4     2</span></span>
<span><span class="co">## 12 77.93 175.00  75.6     2</span></span>
<span><span class="co">## 13 85.00 182.07  78.5     2</span></span>
<span><span class="co">## 14 85.00 167.93  77.0     2</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Data are stored in coded form using these coding formulas ...</span></span>
<span><span class="co">## x1 ~ (Time - 85)/5</span></span>
<span><span class="co">## x2 ~ (Temp - 175)/5</span></span></code></pre>
<p>Notice that <code>djoin</code> figures out the fact that
<code>ChemReact2</code> is not coded but it has the appropriate uncoded
variables <code>Time</code> and <code>Temp</code>; so it codes those
variables appropriately. Also, the <code>Block</code> factor is added
automatically.</p>
<p>We are now in the position of fitting a full second-order model to
the combined data. This can be done by adding <code>PQ(x1, x2)</code> to
the above model with interaction, but the easier way is to use
<code>SO</code>, which is shorthand for a model with <code>FO</code>,
<code>TWI</code>, and <code>PQ</code> terms. Also, we now need to
account for the block effect since the data are collected in separate
experiments:</p>
<div class="sourceCode" id="cb24"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">CR2.rsm</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/rsm.html">rsm</a></span><span class="op">(</span><span class="va">Yield</span> <span class="op">~</span> <span class="va">Block</span> <span class="op">+</span> <span class="fu"><a href="../reference/FO.html">SO</a></span><span class="op">(</span><span class="va">x1</span>, <span class="va">x2</span><span class="op">)</span>, data <span class="op">=</span> <span class="va">CR2</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">CR2.rsm</span><span class="op">)</span></span></code></pre></div>
<pre class="ro"><code><span><span class="co">## </span></span>
<span><span class="co">## Call:</span></span>
<span><span class="co">## rsm(formula = Yield ~ Block + SO(x1, x2), data = CR2)</span></span>
<span><span class="co">## </span></span>
<span><span class="co">##              Estimate Std. Error  t value  Pr(&gt;|t|)    </span></span>
<span><span class="co">## (Intercept) 84.095427   0.079631 1056.067 &lt; 2.2e-16 ***</span></span>
<span><span class="co">## Block2      -4.457530   0.087226  -51.103 2.877e-10 ***</span></span>
<span><span class="co">## x1           0.932541   0.057699   16.162 8.444e-07 ***</span></span>
<span><span class="co">## x2           0.577712   0.057699   10.012 2.122e-05 ***</span></span>
<span><span class="co">## x1:x2        0.125000   0.081592    1.532    0.1694    </span></span>
<span><span class="co">## x1^2        -1.308555   0.060064  -21.786 1.083e-07 ***</span></span>
<span><span class="co">## x2^2        -0.933442   0.060064  -15.541 1.104e-06 ***</span></span>
<span><span class="co">## ---</span></span>
<span><span class="co">## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Multiple R-squared:  0.9981, Adjusted R-squared:  0.9964 </span></span>
<span><span class="co">## F-statistic: 607.2 on 6 and 7 DF,  p-value: 3.811e-09</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Analysis of Variance Table</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Response: Yield</span></span>
<span><span class="co">##             Df Sum Sq Mean Sq   F value    Pr(&gt;F)</span></span>
<span><span class="co">## Block        1 69.531  69.531 2611.0950 2.879e-10</span></span>
<span><span class="co">## FO(x1, x2)   2  9.626   4.813  180.7341 9.450e-07</span></span>
<span><span class="co">## TWI(x1, x2)  1  0.063   0.063    2.3470    0.1694</span></span>
<span><span class="co">## PQ(x1, x2)   2 17.791   8.896  334.0539 1.135e-07</span></span>
<span><span class="co">## Residuals    7  0.186   0.027                    </span></span>
<span><span class="co">## Lack of fit  3  0.053   0.018    0.5307    0.6851</span></span>
<span><span class="co">## Pure error   4  0.133   0.033                    </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Stationary point of response surface:</span></span>
<span><span class="co">##        x1        x2 </span></span>
<span><span class="co">## 0.3722954 0.3343802 </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Stationary point in original units:</span></span>
<span><span class="co">##      Time      Temp </span></span>
<span><span class="co">##  86.86148 176.67190 </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Eigenanalysis:</span></span>
<span><span class="co">## eigen() decomposition</span></span>
<span><span class="co">## $values</span></span>
<span><span class="co">## [1] -0.9233027 -1.3186949</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## $vectors</span></span>
<span><span class="co">##          [,1]       [,2]</span></span>
<span><span class="co">## x1 -0.1601375 -0.9870947</span></span>
<span><span class="co">## x2 -0.9870947  0.1601375</span></span></code></pre>
<p>The lack of fit is now non-significant
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>â‰ˆ</mo><mn>0.69</mn></mrow><annotation encoding="application/x-tex">p \approx 0.69</annotation></semantics></math>).
The summary for a second-order model provides results of a canonical
analysis of the surface rather than for steepest ascent. The analysis
indicates that the stationary point of the fitted surface is at
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mn>0.37</mn><mo>,</mo><mn>0.33</mn><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(0.37, 0.33)</annotation></semantics></math>
in coded unitsâ€”well within the experimental region; and that both
eigenvalues are negative, indicating that the stationary point is a
maximum. This is the kind of situation we dream for in response-surface
experimentationâ€”clear evidence of a nearby set of optimal conditions. We
should probably collect some confirmatory data near this estimated
optimum at
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">Time</mtext><mo>â‰ˆ</mo><mn>87</mn></mrow><annotation encoding="application/x-tex">\text{Time}\approx87</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">Temp</mtext><mo>â‰ˆ</mo><mn>177</mn></mrow><annotation encoding="application/x-tex">\text{Temp}\approx 177</annotation></semantics></math>,
to make sure.</p>
<p>Another example that comes out a different way is a paper-helicopter
experiment (Box <em>et al.</em> 2005, Table 12.5). This is another
central-composite experiment, in four variables and two blocks. The data
are provided in the <strong>rsm</strong> dataset <code>heli</code>;
these data are already coded. The original variables are wing area
<code>A</code>, wing shape <code>R</code>, body width <code>W</code>,
and body length <code>L</code>. The goal is to make a paper helicopter
that flies for as long as possible. Each observation in the dataset
represents the results of ten replicated flights at each experimental
condition. Here we study the average flight time, variable name
<code>ave</code>, using a second-order surface.</p>
<div class="sourceCode" id="cb26"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">heli.rsm</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/rsm.html">rsm</a></span><span class="op">(</span><span class="va">ave</span> <span class="op">~</span> <span class="va">block</span> <span class="op">+</span> <span class="fu"><a href="../reference/FO.html">SO</a></span><span class="op">(</span><span class="va">x1</span>, <span class="va">x2</span>, <span class="va">x3</span>, <span class="va">x4</span><span class="op">)</span>, data <span class="op">=</span> <span class="va">heli</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">heli.rsm</span><span class="op">)</span></span></code></pre></div>
<pre class="ro"><code><span><span class="co">## </span></span>
<span><span class="co">## Call:</span></span>
<span><span class="co">## rsm(formula = ave ~ block + SO(x1, x2, x3, x4), data = heli)</span></span>
<span><span class="co">## </span></span>
<span><span class="co">##               Estimate Std. Error  t value  Pr(&gt;|t|)    </span></span>
<span><span class="co">## (Intercept) 372.800000   1.506375 247.4815 &lt; 2.2e-16 ***</span></span>
<span><span class="co">## block2       -2.950000   1.207787  -2.4425 0.0284522 *  </span></span>
<span><span class="co">## x1           -0.083333   0.636560  -0.1309 0.8977075    </span></span>
<span><span class="co">## x2            5.083333   0.636560   7.9856 1.398e-06 ***</span></span>
<span><span class="co">## x3            0.250000   0.636560   0.3927 0.7004292    </span></span>
<span><span class="co">## x4           -6.083333   0.636560  -9.5566 1.633e-07 ***</span></span>
<span><span class="co">## x1:x2        -2.875000   0.779623  -3.6877 0.0024360 ** </span></span>
<span><span class="co">## x1:x3        -3.750000   0.779623  -4.8100 0.0002773 ***</span></span>
<span><span class="co">## x1:x4         4.375000   0.779623   5.6117 6.412e-05 ***</span></span>
<span><span class="co">## x2:x3         4.625000   0.779623   5.9324 3.657e-05 ***</span></span>
<span><span class="co">## x2:x4        -1.500000   0.779623  -1.9240 0.0749257 .  </span></span>
<span><span class="co">## x3:x4        -2.125000   0.779623  -2.7257 0.0164099 *  </span></span>
<span><span class="co">## x1^2         -2.037500   0.603894  -3.3739 0.0045424 ** </span></span>
<span><span class="co">## x2^2         -1.662500   0.603894  -2.7530 0.0155541 *  </span></span>
<span><span class="co">## x3^2         -2.537500   0.603894  -4.2019 0.0008873 ***</span></span>
<span><span class="co">## x4^2         -0.162500   0.603894  -0.2691 0.7917877    </span></span>
<span><span class="co">## ---</span></span>
<span><span class="co">## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Multiple R-squared:  0.9555, Adjusted R-squared:  0.9078 </span></span>
<span><span class="co">## F-statistic: 20.04 on 15 and 14 DF,  p-value: 6.54e-07</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Analysis of Variance Table</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Response: ave</span></span>
<span><span class="co">##                     Df  Sum Sq Mean Sq F value    Pr(&gt;F)</span></span>
<span><span class="co">## block                1   16.81   16.81  1.7281  0.209786</span></span>
<span><span class="co">## FO(x1, x2, x3, x4)   4 1510.00  377.50 38.8175 1.965e-07</span></span>
<span><span class="co">## TWI(x1, x2, x3, x4)  6 1114.00  185.67 19.0917 5.355e-06</span></span>
<span><span class="co">## PQ(x1, x2, x3, x4)   4  282.54   70.64  7.2634  0.002201</span></span>
<span><span class="co">## Residuals           14  136.15    9.72                  </span></span>
<span><span class="co">## Lack of fit         10  125.40   12.54  4.6660  0.075500</span></span>
<span><span class="co">## Pure error           4   10.75    2.69                  </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Stationary point of response surface:</span></span>
<span><span class="co">##         x1         x2         x3         x4 </span></span>
<span><span class="co">##  0.8607107 -0.3307115 -0.8394866 -0.1161465 </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Stationary point in original units:</span></span>
<span><span class="co">##         A         R         W         L </span></span>
<span><span class="co">## 12.916426  2.434015  1.040128  1.941927 </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Eigenanalysis:</span></span>
<span><span class="co">## eigen() decomposition</span></span>
<span><span class="co">## $values</span></span>
<span><span class="co">## [1]  3.258222 -1.198324 -3.807935 -4.651963</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## $vectors</span></span>
<span><span class="co">##          [,1]       [,2]       [,3]        [,4]</span></span>
<span><span class="co">## x1  0.5177048 0.04099358  0.7608371 -0.38913772</span></span>
<span><span class="co">## x2 -0.4504231 0.58176202  0.5056034  0.45059647</span></span>
<span><span class="co">## x3 -0.4517232 0.37582195 -0.1219894 -0.79988915</span></span>
<span><span class="co">## x4  0.5701289 0.72015994 -0.3880860  0.07557783</span></span></code></pre>
<p>From the analysis of variance, it is clear that the second-order
(<code>TWI</code> and <code>PQ</code>) terms contribute significantly to
the model, so the canonical analysis is relevant. Again, the stationary
point is fairly near the experimental region, but the eigenvalues are of
mixed sign, indicating that it is a saddle point (neither a maximum nor
a minimum). We will do further analysis of these results in the
subsequent sections.</p>
</div>
<div class="section level2">
<h2 id="contour">Displaying a response surface<a class="anchor" aria-label="anchor" href="#contour"></a>
</h2>
<p>While the canonical analysis gives us a handle on the behavior of a
second-order response surface, an effective graph is a lot easier to
present and explain. To that end, <code>rsm</code> includes a function
for making contour plots of a fitted response surface. This function is
not restricted to <code>rsm</code> results, however; it can be used for
plotting any regression surface produced by <code>lm</code>. For more
detailed information, see the associated vignette We provide the
<code>lm</code> or <code>rsm</code> object, a formula for which
predictors to use, and various optional parameters. Consider the
paper-helicopter example in the preceding section; there are four
response-surface predictors, making six pairs of predictors. If we want
to visualize the behavior of the fitted surface around the stationary
point, we can provide that location as the <code>at</code> argument:</p>
<div class="sourceCode" id="cb28"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/par.html" class="external-link">par</a></span><span class="op">(</span>mfrow <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">2</span>, <span class="fl">3</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/contour.html" class="external-link">contour</a></span><span class="op">(</span><span class="va">heli.rsm</span>, <span class="op">~</span> <span class="va">x1</span> <span class="op">+</span> <span class="va">x2</span> <span class="op">+</span> <span class="va">x3</span> <span class="op">+</span> <span class="va">x4</span>, image <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>  at <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">heli.rsm</span><span class="op">)</span><span class="op">$</span><span class="va">canonical</span><span class="op">$</span><span class="va">xs</span><span class="op">)</span></span></code></pre></div>
<p><img src="article-JSS_files/figure-html/unnamed-chunk-17-1.png" width="768"></p>
<p>The <code>image</code> argument causes each plot to display a color
image overlaid by the contour lines. When multiple plots like this are
produced, the color levels are held consistent across all plots. Note
that the <code>at</code> condition does not set the center of the
coordinate systems (the default variable ranges are derived from the
data); it sets the values at which to hold variables other than those on
one of the coordinate axes, as shown in the subtitles.</p>
</div>
<div class="section level2">
<h2 id="steepest">Direction for further experimentation<a class="anchor" aria-label="anchor" href="#steepest"></a>
</h2>
<p>In many first-order cases, as well as second-order cases where we
find a saddle point or the stationary point is distant, the most useful
further action is to decide in which direction to explore further. In
the case of first-order models, one can follow the direction of steepest
ascent. As already seen in , the <code>summary</code> method for
<code>rsm</code> objects provides some information about this path. More
detailed information is available via the <code>steepest</code>
function; for example,</p>
<div class="sourceCode" id="cb29"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/steepest.html">steepest</a></span><span class="op">(</span><span class="va">CR1.rsm</span>, dist <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">0.5</span>, <span class="fl">1</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<pre class="ro"><code><span><span class="co">## Path of steepest ascent from ridge analysis:</span></span></code></pre>
<pre class="ro"><code><span><span class="co">##   dist    x1    x2 |   Time    Temp |   yhat</span></span>
<span><span class="co">## 1  0.0 0.000 0.000 | 85.000 175.000 | 82.814</span></span>
<span><span class="co">## 2  0.5 0.407 0.291 | 87.035 176.455 | 83.352</span></span>
<span><span class="co">## 3  1.0 0.814 0.581 | 89.070 177.905 | 83.890</span></span></code></pre>
<p>In general, we can specify any set of distances along the path. The
decoded coordinate values are displayed if the model was fitted to a
<code>coded.data</code> dataset.</p>
<p>At this point it is worth emphasizing that, although the fitted
values are also displayed, one must be careful to understand that these
are only predictions and that, as the distance increases, they are very
poor predictions and should be taken with a grain of salt. What one
should do is to conduct actual experimental runs at points along this
path, and use the observed response values, not these predictions, for
guidance on where to locate the next factorial experiment.</p>
<p>In the second-order case, the <code>steepest</code> function still
works, but it uses the ridge analysis method (Hoerl 1959; Draper 1963),
which is the analog of steepest ascent in the sense that for a specified
distance
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>d</mi><annotation encoding="application/x-tex">d</annotation></semantics></math>,
it finds the point at which the predicted response is a maximum among
all predictor combinations at radius
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>d</mi><annotation encoding="application/x-tex">d</annotation></semantics></math>.
This method makes sense when the stationary point is some distance away;
but when this point is nearby, it makes more sense to start at the
saddle point (rather than the origin) and follow the most steeply rising
ridge in <em>both</em> directions. This path is obtained using the
<code>canonical.path</code> function. In this function, distance is a
signed quantity, according to the direction along the ridge.</p>
<p>In the <code>heli</code> example, we do have a nearby stationary
point. Here are some points within a radius of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>5</mn><annotation encoding="application/x-tex">5</annotation></semantics></math>
along the canonical path:</p>
<div class="sourceCode" id="cb32"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/steepest.html">canonical.path</a></span><span class="op">(</span><span class="va">heli.rsm</span>, dist <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span><span class="op">-</span><span class="fl">5</span>, <span class="fl">5</span>, by <span class="op">=</span> <span class="fl">0.5</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<pre class="ro"><code><span><span class="co">##    dist     x1     x2     x3     x4 |       A       R       W      L |    yhat</span></span>
<span><span class="co">## 1  -5.0 -1.728  1.921  1.419 -2.967 | 11.3632 3.01946 1.60475 0.5165 | 453.627</span></span>
<span><span class="co">## 2  -4.5 -1.469  1.696  1.193 -2.682 | 11.5186 2.96096 1.54825 0.6590 | 438.150</span></span>
<span><span class="co">## 3  -4.0 -1.210  1.471  0.967 -2.397 | 11.6740 2.90246 1.49175 0.8015 | 424.302</span></span>
<span><span class="co">## 4  -3.5 -0.951  1.246  0.742 -2.112 | 11.8294 2.84396 1.43550 0.9440 | 412.094</span></span>
<span><span class="co">## 5  -3.0 -0.692  1.021  0.516 -1.827 | 11.9848 2.78546 1.37900 1.0865 | 401.504</span></span>
<span><span class="co">## 6  -2.5 -0.434  0.795  0.290 -1.541 | 12.1396 2.72670 1.32250 1.2295 | 392.534</span></span>
<span><span class="co">## 7  -2.0 -0.175  0.570  0.064 -1.256 | 12.2950 2.66820 1.26600 1.3720 | 385.203</span></span>
<span><span class="co">## 8  -1.5  0.084  0.345 -0.162 -0.971 | 12.4504 2.60970 1.20950 1.5145 | 379.502</span></span>
<span><span class="co">## 9  -1.0  0.343  0.120 -0.388 -0.686 | 12.6058 2.55120 1.15300 1.6570 | 375.429</span></span>
<span><span class="co">## 10 -0.5  0.602 -0.105 -0.614 -0.401 | 12.7612 2.49270 1.09650 1.7995 | 372.986</span></span>
<span><span class="co">## 11  0.0  0.861 -0.331 -0.839 -0.116 | 12.9166 2.43394 1.04025 1.9420 | 372.172</span></span>
<span><span class="co">## 12  0.5  1.120 -0.556 -1.065  0.169 | 13.0720 2.37544 0.98375 2.0845 | 372.987</span></span>
<span><span class="co">## 13  1.0  1.378 -0.781 -1.291  0.454 | 13.2268 2.31694 0.92725 2.2270 | 375.428</span></span>
<span><span class="co">## 14  1.5  1.637 -1.006 -1.517  0.739 | 13.3822 2.25844 0.87075 2.3695 | 379.499</span></span>
<span><span class="co">## 15  2.0  1.896 -1.232 -1.743  1.024 | 13.5376 2.19968 0.81425 2.5120 | 385.206</span></span>
<span><span class="co">## 16  2.5  2.155 -1.457 -1.969  1.309 | 13.6930 2.14118 0.75775 2.6545 | 392.538</span></span>
<span><span class="co">## 17  3.0  2.414 -1.682 -2.195  1.594 | 13.8484 2.08268 0.70125 2.7970 | 401.498</span></span>
<span><span class="co">## 18  3.5  2.673 -1.907 -2.421  1.879 | 14.0038 2.02418 0.64475 2.9395 | 412.088</span></span>
<span><span class="co">## 19  4.0  2.932 -2.132 -2.646  2.164 | 14.1592 1.96568 0.58850 3.0820 | 424.295</span></span>
<span><span class="co">## 20  4.5  3.190 -2.358 -2.872  2.449 | 14.3140 1.90692 0.53200 3.2245 | 438.140</span></span>
<span><span class="co">## 21  5.0  3.449 -2.583 -3.098  2.734 | 14.4694 1.84842 0.47550 3.3670 | 453.615</span></span></code></pre>
<p>Box <em>et al.</em> (2005, Table12.7 and Figure12.6) reports some
results of experimentation along this path. They found the most
promising location for the next experiment was at a distance of about
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>3.5</mn><annotation encoding="application/x-tex">3.5</annotation></semantics></math>
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>âˆ’</mo><mn>3.5</mn></mrow><annotation encoding="application/x-tex">-3.5</annotation></semantics></math>
on their scale as their signs are reversed from ours).</p>
</div>
<div class="section level2">
<h2 id="stationary-and-rising-ridge-situations">Stationary and rising-ridge situations<a class="anchor" aria-label="anchor" href="#stationary-and-rising-ridge-situations"></a>
</h2>
<p>Canonical analysis becomes unstable in cases where the matrix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ</mi><annotation encoding="application/x-tex">\mathbf{B}</annotation></semantics></math>
of second-order coefficients is singular or nearly so. As an example,
consider the dataset <code>codata</code> provided with
<strong>rsm</strong> and used as an example in Box <em>et al.</em>
(2005). It comes in coded form, but to relate things to the actual
variables, letâ€™s add the codings:</p>
<div class="sourceCode" id="cb34"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">CO</span> <span class="op">=</span> <span class="fu"><a href="../reference/coded.data.html">as.coded.data</a></span><span class="op">(</span><span class="va">codata</span>,  <span class="va">x1</span> <span class="op">~</span> <span class="op">(</span><span class="va">Ethanol</span> <span class="op">-</span> <span class="fl">0.2</span><span class="op">)</span><span class="op">/</span><span class="fl">0.1</span>,  <span class="va">x2</span> <span class="op">~</span> <span class="va">A.F.ratio</span> <span class="op">-</span> <span class="fl">15</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/names.html" class="external-link">names</a></span><span class="op">(</span><span class="va">CO</span><span class="op">)</span><span class="op">[</span><span class="fl">3</span><span class="op">]</span> <span class="op">=</span> <span class="st">"CO.conc"</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="va">CO</span><span class="op">)</span></span></code></pre></div>
<pre class="ro"><code><span><span class="co">##   Ethanol A.F.ratio CO.conc</span></span>
<span><span class="co">## 1     0.1        14    61.9</span></span>
<span><span class="co">## 2     0.1        14    65.6</span></span>
<span><span class="co">## 3     0.2        14    80.9</span></span>
<span><span class="co">## 4     0.2        14    78.0</span></span>
<span><span class="co">## 5     0.3        14    89.7</span></span>
<span><span class="co">## 6     0.3        14    93.8</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Data are stored in coded form using these coding formulas ...</span></span>
<span><span class="co">## x1 ~ (Ethanol - 0.2)/0.1</span></span>
<span><span class="co">## x2 ~ A.F.ratio - 15</span></span></code></pre>
<p>This is a
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>3</mn><mn>2</mn></msup><annotation encoding="application/x-tex">3^2</annotation></semantics></math>
design in one block. We fit a second-order model and obtain the
canonical analysis:</p>
<div class="sourceCode" id="cb36"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">CO.rsm</span> <span class="op">=</span> <span class="fu"><a href="../reference/rsm.html">rsm</a></span><span class="op">(</span><span class="va">CO.conc</span> <span class="op">~</span> <span class="fu"><a href="../reference/FO.html">SO</a></span><span class="op">(</span><span class="va">x1</span>,<span class="va">x2</span><span class="op">)</span>, data <span class="op">=</span> <span class="va">CO</span><span class="op">)</span></span>
<span><span class="fu"><a href="../reference/rsm.html">canonical</a></span><span class="op">(</span><span class="va">CO.rsm</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## Near-stationary-ridge situation detected -- stationary point altered</span></span>
<span><span class="co">##  Change 'threshold' if this is not what you intend</span></span></code></pre>
<pre class="ro"><code><span><span class="co">## $xs</span></span>
<span><span class="co">##          x1          x2 </span></span>
<span><span class="co">## -0.06302658 -0.05997463 </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## $eigen</span></span>
<span><span class="co">## eigen() decomposition</span></span>
<span><span class="co">## $values</span></span>
<span><span class="co">## [1]  0.000000 -8.886833</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## $vectors</span></span>
<span><span class="co">##          [,1]       [,2]</span></span>
<span><span class="co">## x1  0.6893497 -0.7244288</span></span>
<span><span class="co">## x2 -0.7244288 -0.6893497</span></span></code></pre>
<p>Note that, due to an automatic thresholding provision, one of the
eigenvalues has been set to zero. This causes the stationary point to be
estimated based only on the surviving eigenvector, with the other one
assumed to be a stationary ridge. To ignore this thresholding, set the
threshold to zero:</p>
<div class="sourceCode" id="cb39"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/rsm.html">canonical</a></span><span class="op">(</span><span class="va">CO.rsm</span>, threshold <span class="op">=</span> <span class="fl">0</span><span class="op">)</span></span></code></pre></div>
<pre class="ro"><code><span><span class="co">## $xs</span></span>
<span><span class="co">##        x1        x2 </span></span>
<span><span class="co">## -14.81387  15.44149 </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## $eigen</span></span>
<span><span class="co">## eigen() decomposition</span></span>
<span><span class="co">## $values</span></span>
<span><span class="co">## [1]  0.1868328 -8.8868328</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## $vectors</span></span>
<span><span class="co">##          [,1]       [,2]</span></span>
<span><span class="co">## x1  0.6893497 -0.7244288</span></span>
<span><span class="co">## x2 -0.7244288 -0.6893497</span></span></code></pre>
<p>Now, the stationary point is at about
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mo>âˆ’</mo><mn>15</mn><mo>,</mo><mn>15</mn><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(-15,15)</annotation></semantics></math>
in coded unitsâ€”very distant from the design center.</p>
<p>The following statements produce an illustrative plot of this
situation.</p>
<div class="sourceCode" id="cb41"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/contour.html" class="external-link">contour</a></span><span class="op">(</span><span class="va">CO.rsm</span>, <span class="va">x2</span> <span class="op">~</span> <span class="va">x1</span>, bounds <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>x1 <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="op">-</span><span class="fl">16</span>, <span class="fl">2</span><span class="op">)</span>, x2 <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="op">-</span><span class="fl">2</span>, <span class="fl">16</span><span class="op">)</span><span class="op">)</span>, </span>
<span>        zlim <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="op">-</span><span class="fl">100</span>, <span class="fl">100</span><span class="op">)</span>, col <span class="op">=</span> <span class="st">"gray"</span>, decode <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/lines.html" class="external-link">lines</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="op">-</span><span class="fl">1</span>,<span class="fl">1</span>,<span class="fl">1</span>,<span class="op">-</span><span class="fl">1</span>,<span class="op">-</span><span class="fl">1</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="op">-</span><span class="fl">1</span>,<span class="op">-</span><span class="fl">1</span>,<span class="fl">1</span>,<span class="fl">1</span>,<span class="op">-</span><span class="fl">1</span><span class="op">)</span>, col <span class="op">=</span> <span class="st">"green"</span><span class="op">)</span> <span class="co"># design region</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/points.html" class="external-link">points</a></span><span class="op">(</span><span class="va">x2</span> <span class="op">~</span> <span class="va">x1</span>, data <span class="op">=</span> <span class="fu"><a href="../reference/steepest.html">canonical.path</a></span><span class="op">(</span><span class="va">CO.rsm</span><span class="op">)</span>, </span>
<span>        col <span class="op">=</span> <span class="st">"blue"</span>, pch <span class="op">=</span> <span class="fl">1</span> <span class="op">+</span> <span class="fl">6</span><span class="op">*</span><span class="op">(</span><span class="va">dist</span> <span class="op">==</span> <span class="fl">0</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/points.html" class="external-link">points</a></span><span class="op">(</span><span class="va">x2</span> <span class="op">~</span> <span class="va">x1</span>, data <span class="op">=</span> <span class="fu"><a href="../reference/steepest.html">canonical.path</a></span><span class="op">(</span><span class="va">CO.rsm</span>, threshold <span class="op">=</span> <span class="fl">0</span><span class="op">)</span>, </span>
<span>        col <span class="op">=</span> <span class="st">"red"</span>, pch <span class="op">=</span> <span class="fl">1</span> <span class="op">+</span> <span class="fl">6</span><span class="op">*</span><span class="op">(</span><span class="va">dist</span> <span class="op">==</span> <span class="fl">0</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/points.html" class="external-link">points</a></span><span class="op">(</span><span class="va">x2</span> <span class="op">~</span> <span class="va">x1</span>, data<span class="op">=</span><span class="fu"><a href="../reference/steepest.html">steepest</a></span><span class="op">(</span><span class="va">CO.rsm</span><span class="op">)</span>, </span>
<span>        col <span class="op">=</span> <span class="st">"magenta"</span>, pch <span class="op">=</span> <span class="fl">1</span> <span class="op">+</span> <span class="fl">6</span><span class="op">*</span><span class="op">(</span><span class="va">dist</span> <span class="op">==</span> <span class="fl">0</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p><img src="article-JSS_files/figure-html/unnamed-chunk-23-1.png" width="432"></p>
<pre class="ro"><code><span><span class="co">## Path of steepest ascent from ridge analysis:</span></span>
<span><span class="co">## Path of steepest ascent from ridge analysis:</span></span></code></pre>
<p>It displays the fitted response surface, as well as the results from
<code>canonical.path</code> with and without the threshold (blue and red
points, respectively). The region of the design is shown as a green box.
The stationary point (different symbol) is seen to be a saddle point
near the upper-left corner when not thresholded, and near the design
center whern thresholded. Otherwise, the canonical paths are much the
same but with different origins. Both form a path along the rising ridge
that occurs in the vicinity of the design.</p>
<p>It is important to note that the stationary point obtained by the
default thresholding is not really a stationary point, but rather a
nearby point that represents a center for the most important canonical
directions. In this example, the true stationary point is very distant,
and the thresholded stationary point is the nearest place on a rising
ridge that emanates from the true stationary point. The thresholded
<code>canonical.path</code> results give us a much more usable set of
factor settings to explore than the ones without a threshold.</p>
<div class="section level3">
<h3 id="technical-details">Technical details<a class="anchor" aria-label="anchor" href="#technical-details"></a>
</h3>
<p>This subsection provides some technical backing for canonical
analysis and what we do when a threshold is active, in case youâ€™re
interested.</p>
<p>Let
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ›</mi><annotation encoding="application/x-tex">\mathbf{b}</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ</mi><annotation encoding="application/x-tex">\mathbf{B}</annotation></semantics></math>
denote the first and second-order coefficients of the fitted
second-order surface, so that the fitted value at a coded point
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ±</mi><annotation encoding="application/x-tex">\mathbf{x}</annotation></semantics></math>
is
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>y</mi><mo accent="true">Ì‚</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>ğ±</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msub><mi>b</mi><mn>0</mn></msub><mo>+</mo><mi>ğ›</mi><mi>â€²</mi><mi>ğ±</mi><mo>+</mo><mi>ğ±</mi><mi>â€²</mi><mi>ğ</mi><mi>ğ±</mi></mrow><annotation encoding="application/x-tex">\hat{y}(\mathbf{x}) = b_0 + \mathbf{b}'\mathbf{x} + \mathbf{x}'\mathbf{B}\mathbf{x}</annotation></semantics></math>.
The stationary point
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ğ±</mi><mi>s</mi></msub><annotation encoding="application/x-tex">\mathbf{x}_s</annotation></semantics></math>
solves the equation
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>ğ</mi><msub><mi>ğ±</mi><mi>s</mi></msub><mo>+</mo><mi>ğ›</mi><mo>=</mo><mn>ğŸ</mn></mrow><annotation encoding="application/x-tex">2\mathbf{B}\mathbf{x}_s + \mathbf{b} = \mathbf{0}</annotation></semantics></math>,
i.e.,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ğ±</mi><mi>s</mi></msub><mo>=</mo><mo>âˆ’</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><msup><mi>ğ</mi><mrow><mo>âˆ’</mo><mn>1</mn></mrow></msup><mi>ğ›</mi></mrow><annotation encoding="application/x-tex">\mathbf{x}_s = -\frac12\mathbf{B}^{-1}\mathbf{b}</annotation></semantics></math>.
The canonical analysis yields the decomposition
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ</mi><mo>=</mo><mi>ğ”</mi><mi>ğš²</mi><mi>ğ”</mi><mi>â€²</mi><mo>=</mo><msub><mi>Î»</mi><mn>1</mn></msub><msub><mi>ğ®</mi><mn>1</mn></msub><msub><mi>ğ®</mi><mn>1</mn></msub><mi>â€²</mi><mo>+</mo><msub><mi>Î»</mi><mn>2</mn></msub><msub><mi>ğ®</mi><mn>2</mn></msub><msub><mi>ğ®</mi><mn>2</mn></msub><mi>â€²</mi><mo>+</mo><mi>â‹¯</mi><mo>+</mo><msub><mi>Î»</mi><mi>k</mi></msub><msub><mi>ğ®</mi><mi>k</mi></msub><msub><mi>ğ®</mi><mi>k</mi></msub><mi>â€²</mi></mrow><annotation encoding="application/x-tex"> \mathbf{B} = \mathbf{U}\mathbf{\Lambda}\mathbf{U}' = \lambda_1\mathbf{u}_1\mathbf{u}_1' + \lambda_2\mathbf{u}_2\mathbf{u}_2' + \cdots + \lambda_k\mathbf{u}_k\mathbf{u}_k' </annotation></semantics></math>
where there are
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>
predictors, the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ğ®</mi><mi>j</mi></msub><annotation encoding="application/x-tex">\mathbf{u}_j</annotation></semantics></math>
form orthonormal columns of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ”</mi><annotation encoding="application/x-tex">\mathbf{U}</annotation></semantics></math>,
and the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Î»</mi><mi>j</mi></msub><annotation encoding="application/x-tex">\lambda_j</annotation></semantics></math>
are the eigenvalues, and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğš²</mi><mo>=</mo><mrow><mi mathvariant="normal">d</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">g</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>Î»</mi><mn>1</mn></msub><mo>,</mo><msub><mi>Î»</mi><mn>2</mn></msub><mo>,</mo><mi>â€¦</mi><mo>,</mo><msub><mi>Î»</mi><mi>k</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathbf{\Lambda} = \mathrm{diag}(\lambda_1,\lambda_2,\ldots,\lambda_k)</annotation></semantics></math>.
It also happens to be true that
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>ğ</mi><mrow><mo>âˆ’</mo><mn>1</mn></mrow></msup><mo>=</mo><mi>ğ”</mi><msup><mi>ğš²</mi><mrow><mo>âˆ’</mo><mn>1</mn></mrow></msup><mi>ğ”</mi><mi>â€²</mi><mo>=</mo><mfrac><mn>1</mn><msub><mi>Î»</mi><mn>1</mn></msub></mfrac><msub><mi>ğ®</mi><mn>1</mn></msub><msub><mi>ğ®</mi><mn>1</mn></msub><mi>â€²</mi><mo>+</mo><mfrac><mn>1</mn><msub><mi>Î»</mi><mn>2</mn></msub></mfrac><msub><mi>ğ®</mi><mn>2</mn></msub><msub><mi>ğ®</mi><mn>2</mn></msub><mi>â€²</mi><mo>+</mo><mi>â‹¯</mi><mo>+</mo><mfrac><mn>1</mn><msub><mi>Î»</mi><mi>k</mi></msub></mfrac><msub><mi>ğ®</mi><mi>k</mi></msub><msub><mi>ğ®</mi><mi>k</mi></msub><mi>â€²</mi></mrow><annotation encoding="application/x-tex"> \mathbf{B}^{-1} = \mathbf{U}\mathbf{\Lambda}^{-1}\mathbf{U}'
= \textstyle\frac1{\lambda_1}\mathbf{u}_1\mathbf{u}_1' + \frac1{\lambda_2}\mathbf{u}_2\mathbf{u}_2' + \cdots + \frac1{\lambda_k}\mathbf{u}_k\mathbf{u}_k'  </annotation></semantics></math>
Thus, a really small value of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Î»</mi><mi>j</mi></msub><annotation encoding="application/x-tex">\lambda_j</annotation></semantics></math>
hardly affects
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ</mi><annotation encoding="application/x-tex">\mathbf{B}</annotation></semantics></math>,
but has a huge influence on
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>ğ</mi><mrow><mo>âˆ’</mo><mn>1</mn></mrow></msup><annotation encoding="application/x-tex">\mathbf{B}^{-1}</annotation></semantics></math>.</p>
<p>Now, for some
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>&lt;</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">m&lt;k</annotation></semantics></math>,
let
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ğš²</mi><mo>*</mo></msub><annotation encoding="application/x-tex">\mathbf{\Lambda}_*</annotation></semantics></math>
be the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>Ã—</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">m\times m</annotation></semantics></math>
diagonal matrix with only some subset of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>
eigenvalues; and let
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ğ”</mi><mo>*</mo></msub><annotation encoding="application/x-tex">\mathbf{U}_*</annotation></semantics></math>
be the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>Ã—</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">k \times m</annotation></semantics></math>
matrix with the corresponding
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ğ®</mi><mi>j</mi></msub><annotation encoding="application/x-tex">\mathbf{u}_j</annotation></semantics></math>.
If we excluded the smallest absolute eigenvalues, then
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ğ</mi><mo>*</mo></msub><mo>=</mo><msub><mi>ğ”</mi><mo>*</mo></msub><msub><mi>ğš²</mi><mo>*</mo></msub><mi>ğ”</mi><msub><mi>â€²</mi><mo>*</mo></msub><mo>â‰ˆ</mo><mi>ğ</mi></mrow><annotation encoding="application/x-tex">\mathbf{B}_* = \mathbf{U}_*\mathbf{\Lambda}_*\mathbf{U}'_* \approx \mathbf{B}</annotation></semantics></math>.
Moreover, by orthogonality,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ”</mi><mi>â€²</mi><mi>ğ</mi><mo>=</mo><mi>ğš²</mi><mi>ğ”</mi><mi>â€²</mi></mrow><annotation encoding="application/x-tex">\mathbf{U}'\mathbf{B} = \mathbf{\Lambda}\mathbf{U}'</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ğ”</mi><mo>*</mo></msub><mi>â€²</mi><mi>ğ</mi><mo>=</mo><msub><mi>ğš²</mi><mo>*</mo></msub><msub><mi>ğ”</mi><mo>*</mo></msub><mi>â€²</mi></mrow><annotation encoding="application/x-tex">\mathbf{U}_*'\mathbf{B} = \mathbf{\Lambda}_*\mathbf{U}_*'</annotation></semantics></math>.
The stationary point satisfies
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>ğ</mi><mi>ğ±</mi><mo>+</mo><mi>ğ›</mi><mo>=</mo><mn>ğŸ</mn></mrow><annotation encoding="application/x-tex">2\mathbf{B}\mathbf{x} + \mathbf{b} = \mathbf{0}</annotation></semantics></math>
so that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><msub><mi>ğ”</mi><mo>*</mo></msub><mi>â€²</mi><mi>ğ</mi><mi>ğ±</mi><mo>+</mo><msub><mi>ğ”</mi><mo>*</mo></msub><mi>â€²</mi><mi>ğ›</mi><mo>=</mo><mn>ğŸ</mn></mrow><annotation encoding="application/x-tex">2\mathbf{U}_*'\mathbf{B}\mathbf{x} + \mathbf{U}_*'\mathbf{b} = \mathbf{0}</annotation></semantics></math>.
Accordingly, we propose to define a pseudo-stationary point
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ğ±</mi><mo>*</mo></msub><annotation encoding="application/x-tex">\mathbf{x}_*</annotation></semantics></math>
such that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><msub><mi>ğ”</mi><mo>*</mo></msub><mi>â€²</mi><mi>ğ</mi><msub><mi>ğ±</mi><mo>*</mo></msub><mo>+</mo><msub><mi>ğ”</mi><mo>*</mo></msub><mi>â€²</mi><mi>ğ›</mi><mo>=</mo><mn>ğŸ</mn></mrow><annotation encoding="application/x-tex">2\mathbf{U}_*'\mathbf{B}\mathbf{x}_* + \mathbf{U}_*'\mathbf{b} = \mathbf{0}</annotation></semantics></math>;
i.e.,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><msub><mi>ğš²</mi><mo>*</mo></msub><msub><mi>ğ”</mi><mo>*</mo></msub><mi>â€²</mi><msub><mi>ğ±</mi><mo>*</mo></msub><mo>+</mo><msub><mi>ğ”</mi><mo>*</mo></msub><mi>â€²</mi><mi>ğ›</mi><mo>=</mo><mn>ğŸ</mn></mrow><annotation encoding="application/x-tex">2\mathbf{\Lambda}_*\mathbf{U}_*'\mathbf{x}_* + \mathbf{U}_*'\mathbf{b} = \mathbf{0}</annotation></semantics></math>.</p>
<p>This comprises
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>
equations in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>&gt;</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">k&gt;m</annotation></semantics></math>
unknowns. To make it unique, we opt to choose the solution that is
closest to the origin; that is, minimize
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ±</mi><mi>â€²</mi><mi>ğ±</mi></mrow><annotation encoding="application/x-tex">\mathbf{x}'\mathbf{x}</annotation></semantics></math>
subject to the constraint that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><msub><mi>ğš²</mi><mo>*</mo></msub><msub><mi>ğ”</mi><mo>*</mo></msub><mi>â€²</mi><mi>ğ±</mi><mo>+</mo><msub><mi>ğ”</mi><mo>*</mo></msub><mi>â€²</mi><mi>ğ›</mi><mo>=</mo><mn>ğŸ</mn></mrow><annotation encoding="application/x-tex">2\mathbf{\Lambda}_*\mathbf{U}_*'\mathbf{x} + \mathbf{U}_*'\mathbf{b} = \mathbf{0}</annotation></semantics></math>.
Using variational methods (Lagrange multipliers), we find that the
resulting solution is
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ğ±</mi><mo>*</mo></msub><mo>=</mo><mo>âˆ’</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><msub><mi>ğ”</mi><mo>*</mo></msub><msubsup><mi>ğš²</mi><mo>*</mo><mrow><mo>âˆ’</mo><mn>1</mn></mrow></msubsup><msub><mi>ğ”</mi><mo>*</mo></msub><mi>â€²</mi><mi>ğ›</mi></mrow><annotation encoding="application/x-tex">\mathbf{x}_*= -\frac12\mathbf{U}_*\mathbf{\Lambda}_*^{-1}\mathbf{U}_*'\mathbf{b}</annotation></semantics></math>.
In other words, we simply exclude some terms corresponding to small
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Î»</mi><mi>i</mi></msub><annotation encoding="application/x-tex">\lambda_i</annotation></semantics></math>
in the above expression for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>ğ</mi><mrow><mo>âˆ’</mo><mn>1</mn></mrow></msup><annotation encoding="application/x-tex">\mathbf{B}^{-1}</annotation></semantics></math>.
This is the stationary point returned in <strong>rsm</strong>â€™s
<code>canonical</code> and related functions when a threshold is used to
exclude some small eigenvalues.</p>
</div>
</div>
<div class="section level2">
<h2 id="discussion">Discussion<a class="anchor" aria-label="anchor" href="#discussion"></a>
</h2>
<p>The current version of <strong>rsm</strong> provides only the most
standard tools for first- and second-order response-surface design and
analysis. The package can be quite useful for those standard situations,
and it implements many of the analyses presented in textbooks. However,
clearly a great deal of work has been done in response-surface methods
that is not represented here. Even a quick glance at a review article
such as Myers, Montgomery, Vining, Borror, and Kowalski (2004) â€“ or even
an older one such as Hill and Hunter (1989) â€“ reveals that there is a
great deal that could be added to future editions of
<strong>rsm</strong>. There are many other useful designs besides
central composites and Box-Behnken designs. We can consider higher-order
models or the use of predictor transformations. Mixture designs are not
yet provided for. There are important relationships between these
methods and robust parameter design, and with computer experiments. The
list goes on. However, we now at least have a good collection of basic
tools for the <strong>R</strong> platform, and that is a starting
point.</p>
</div>
<div class="section level2">
<h2 id="references">References<a class="anchor" aria-label="anchor" href="#references"></a>
</h2>
<p>Box GEP,Behnken DW(1960). â€œSome New Three Level Designs for the Study
of Quantitative Variables.â€ <em>Technometrics</em>, <strong>2</strong>,
455â€“475.</p>
<p>Box GEP, Draper NR (1987). <em>Empirical Model-Building and Response
Surfaces</em>. John Wiley &amp; Sons, New York.</p>
<p>Box GEP, Hunter WG, Hunter JS (2005). <em>Statistics for
Experimenters: An Introduction to Design, Data Analysis, and Model
Building</em>. 2nd edition. John Wiley &amp; Sons, New York.</p>
<p>Box GEP, Wilson KB (1951). â€œOn the Experimental Attainment of Optimum
Conditions.â€ <em>Journal of the Royal Statistical Society B</em>,
<strong>13</strong>, 1â€“45.</p>
<p>Draper NR (1963). â€œâ€˜Ridge Analysisâ€™ of Response Surfaces.â€
<em>Technometrics</em>, <strong>5</strong>, 469â€“479.</p>
<p>Hill WJ, Hunter WG (1989). â€œA Review of Response Surface Methodology:
A Literature Review.â€ <em>Technometrics</em>, <strong>8</strong>,
571â€“590.</p>
<p>Hoerl AE (1959). â€œOptimum Solution of Many Variables Equations.â€
<em>Chemical Engineering Progress</em>, <strong>55</strong>, 67â€“78.</p>
<p>Khuri AI, Cornell JA (1996). Responses Surfaces: Design and Analyses.
2nd edition. Marcel Dekker, Monticello, NY.</p>
<p>Kuhn M (2009). desirability: Desirability Function Optimization and
Ranking. R package version 1.02, URL <a href="https://CRAN.R-project.org/package=desirability" class="external-link uri">https://CRAN.R-project.org/package=desirability</a></p>
<p>Lenth RV (2009). â€œResponse-Surface Methods in R, Using rsm.â€
<em>Journal of Statistical Software</em>, <strong>32</strong>(7), 1â€“17.
URL <a href="https://www.jstatsoft.org/v32/i07/" class="external-link uri">https://www.jstatsoft.org/v32/i07/</a>.</p>
<p>Myers RH, Montgomery DC, Anderson-Cook CM (2009). <em>Response
Surface Methodology: Product and Process Optimization Using Designed
Experiments</em>. 3nd edition. John Wiley &amp; Sons, New York.</p>
<p>Myers RH, Montgomery DC, Vining GG, Borror CM, Kowalski SM (2004).
â€œResponse Surface Methodology: A Retrospective and Literature Survey.â€
<em>Journal of Quality Technology</em>, <strong>36</strong>, 53â€“78.</p>
<p>R Development Core Team (2009). <em>R: A Language and Environment for
Statistical Computing</em>. R Foundation for Statistical Computing,
Vienna, Austria. ISBN 3-900051-07-0, URL http: //www.R-project.org/.</p>
<p>Ryan TP (2007). <em>Modern Experimental Design</em>. John Wiley &amp;
Sons, New York.</p>
<p>SAS Institute, Inc (2009). JMP 8: Statistical Discovery Software.
Cary, NC. URL http: //www.jmp.com/.</p>
<p>Stat-Ease, Inc (2009). <em>Design-Expert 7 for Windows: Software for
Design of Experiments (DOE)</em>. Minneapolis, MN. URL <a href="https://www.statease.com/software/design-expert/" class="external-link uri">https://www.statease.com/software/design-expert/</a>.</p>
<p>StatPoint Technologies, Inc (2009). <em>Statgraphics Centurion: Data
Analysis and Statistical Software</em>. Warrenton, VA. URL <a href="https://www.statgraphics.com/" class="external-link uri">https://www.statgraphics.com/</a>.</p>
<p>Wu CFJ, Hamada M (2000). <em>Experiments: Planning, Analysis, and
Parameter Design Optimization</em>. John Wiley &amp; Sons, New York.</p>
</div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p>Developed by Russell Lenth.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.1.</p>
</div>

    </footer>
</div>





  </body>
</html>
